{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#onshape-robotics-toolkit","title":"onshape-robotics-toolkit","text":"<p><code>onshape-robotics-toolkit</code> is a feature-rich Python library that significantly extends the capabilities of Onshape's web-based CAD platform. The library provides a comprehensive API for automating robot design tasks, including solid model manipulation, robot assembly management, graph-based visualizations, and exporting CAD assemblies to URDF files for simulation and control. Intended as a resource for the robotics community, this library leverages Onshape's REST API to facilitate advanced workflows that bridge CAD design and robotics applications.</p> <p></p> <p>\u00a0 This library was inspired by onshape-to-robot, a tool renowned for its streamlined approach to URDF generation. While onshape-to-robot library focuses on predefined workflows and design-time considerations, the <code>onshape-robotics-toolkit</code> library offers greater flexibility. It provides access to nearly all of Onshape's REST API calls, enabling headless manipulation, detailed analysis, and seamless export of CAD assemblies. Users can programmatically edit variable studios, generate graph-based visualizations, and export URDF files tailored to their specific needs\u2014all without being restricted by rigid workflows or naming conventions. By removing these constraints, the <code>onshape-robotics-toolkit</code> library empowers the robotics and CAD communities to create custom solutions for algorithmic design, optimization, and automation.</p> <p> </p>"},{"location":"#key-features-of-onshape-robotics-toolkit","title":"Key Features of <code>onshape-robotics-toolkit</code>","text":"<p>The <code>onshape-robotics-toolkit</code> library is designed for users seeking a scalable, versatile API that empowers innovative robot design and control workflows. By integrating Onshape into algorithmic processes such as design optimization and automation, it unlocks the full potential of Onshape's cloud-based CAD system, fostering creativity and efficiency in robotics and beyond.</p> <p> </p> Feature <code>onshape-robotics-toolkit</code> <code>onshape-to-robot</code> Workflow Flexibility \u2705 Open-ended and customizable \u274c Predefined and rigid Design-Time Considerations \u2705 None \u274c Requires specific naming conventions Custom URDF Workflow \u2705 Supports any assembly \u274c Limited by design rules Variable Studio Editing \u2705 Yes \u274c No Ease of Setup \u274c Moderate (requires python coding) \u2705 Easy (no coding required) Headless Integration \u2705 Yes (e.g., optimization) \u274c No out-of-the-box support Access to Full Onshape API \u2705 Yes \u274c Limited Graph Visualization and Analysis \u2705 Supports graph generation \u274c Not supported"},{"location":"#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have the following:</p> <ul> <li>Python 3.10 or higher installed on your machine.</li> <li>An Onshape account if you don't already have one.</li> <li>Onshape API keys (access key and secret key)</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>You can install <code>onshape-robotics-toolkit</code> using <code>pip</code>, which is the easiest way to install it and is the recommended method for most users.</p> <pre><code>pip install onshape-robotics-toolkit\n</code></pre> <p>If you want to install from source, you'll need to install <code>uv</code> and <code>git</code> first. Then, you can clone the repository and install the package.</p> <pre><code>git clone https://github.com/neurobionics/onshape-robotics-toolkit.git\ncd onshape-robotics-toolkit\nuv sync\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>If you're interested in contributing to the project, please read the contributing guidelines to get started. All contributions are welcome!</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the Apache 2.0 License. For more information, please refer to the license file.</p>"},{"location":"#references","title":"References","text":"<ul> <li>Onshape API Documentation</li> <li>Onshape API Glassworks Explorer</li> <li>Onshape to Robot URDF Exporter</li> </ul>"},{"location":"contributing/","title":"Contributing to <code>onshape-robotics-toolkit</code>","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps :)</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs here</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement a fix for it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p><code>onshape-robotics-toolkit</code> could always use more documentation, whether as part of the official docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue here.</p> <p>If you are proposing a new feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up <code>onshape-robotics-toolkit</code> for local development. Please note this documentation assumes you already have <code>uv</code> and <code>Git</code> installed and ready to go.</p> <p>Fork the <code>onshape-robotics-toolkit</code> repo on GitHub.</p> <p>Clone your fork locally:</p> <pre><code>cd &lt;directory_in_which_repo_should_be_created&gt;\ngit clone git@github.com:YOUR_NAME/onshape-robotics-toolkit.git\n</code></pre> <p>Now we need to install the environment. Navigate into the directory</p> <pre><code>cd onshape-robotics-toolkit\n</code></pre> <p>Then, install and activate the environment with:</p> <pre><code>uv sync --dev --extra docs\n</code></pre> <p>Please ensure that uv is installed on your system. If not, you can install it by following the instructions here.</p> <p>Install pre-commit to run linters/formatters at commit time:</p> <pre><code>uv run pre-commit install\n</code></pre> <p>Create a branch for local development:</p> <pre><code>git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> <p>Don't forget to add test cases for your added functionality to the tests directory.</p> <p>When you're done making changes, check that your changes pass the formatting tests.</p> <pre><code>make check\n</code></pre> <p>Now, validate that all unit tests are passing:</p> <pre><code>make test\n</code></pre> <p>Before raising a pull request you should also run tox. This will run the tests across different versions of Python:</p> <pre><code>tox\n</code></pre> <p>This requires you to have multiple versions of python installed. This step is also triggered in the CI/CD pipeline, so you could also choose to skip this step locally.</p> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>git add .\ngit commit -m \"Your detailed description of your changes.\"\ngit push origin name-of-your-bugfix-or-feature\n</code></pre> <p>Submit a pull request through the GitHub website.</p>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li> <p>The pull request should include tests.</p> </li> <li> <p>If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.md.</p> </li> </ol>"},{"location":"developing/","title":"Developer Handbook","text":"<p>This library turns an Onshape assembly into a robotic model that can be exported as URDF or MuJoCo MJCF. The goal of the toolkit is to make every stage of that conversion explicit and easy to extend. This document explains the current code structure and highlights the extension points you will touch when contributing.</p>"},{"location":"developing/#architecture-overview","title":"Architecture Overview","text":"<ul> <li>parse (<code>onshape_robotics_toolkit/parse.py</code>): Flattens Onshape's assembly JSON into <code>PathKey</code> indexed registries on the <code>CAD</code> object. Handles rigid vs. flexible subassemblies, mate data, and pattern expansion.</li> <li>graph (<code>onshape_robotics_toolkit/graph.py</code>): Converts the <code>CAD</code> registries into a directed <code>KinematicGraph</code> where nodes are parts and edges are mates. Deals with rigid-assembly remapping, root selection, and graph cleanup.</li> <li>robot (<code>onshape_robotics_toolkit/robot.py</code>): Walks the <code>KinematicGraph</code> to build a <code>Robot</code> (an <code>nx.DiGraph</code>) populated with URDF/MJCF link and joint objects plus STL assets.</li> </ul> <p>The pipeline is intentionally linear:</p> <pre><code>Assembly JSON \u2192 CAD (parse) \u2192 KinematicGraph (graph) \u2192 Robot (robot) \u2192 URDF/MJCF + assets\n</code></pre>"},{"location":"developing/#end-to-end-pipeline","title":"End-to-End Pipeline","text":"<ol> <li>Use <code>Client</code> to fetch assembly data.</li> <li>Call <code>CAD.from_assembly(assembly, max_depth, client)</code> to flatten the JSON.</li> <li>Build a kinematic graph with <code>KinematicGraph.from_cad(cad, use_user_defined_root=True)</code>.</li> <li>Generate the exportable robot via <code>Robot.from_graph(graph, client, name, robot_type)</code>.</li> </ol> <pre><code>from onshape_robotics_toolkit.connect import Client\nfrom onshape_robotics_toolkit.parse import CAD\nfrom onshape_robotics_toolkit.graph import KinematicGraph\nfrom onshape_robotics_toolkit.robot import Robot\n\nclient = Client()\nassembly = client.get_assembly(url)\n\ncad = CAD.from_assembly(assembly, max_depth=1, client=client)\ngraph = KinematicGraph.from_cad(cad, use_user_defined_root=True)\nrobot = Robot.from_graph(graph, client=client, name=\"demo_bot\")\nrobot.save(\"demo_bot.urdf\", download_assets=True)\n</code></pre> <p>Passing a <code>Client</code> into <code>CAD.from_assembly</code> is optional in general, but required when <code>max_depth</code> forces subassemblies to become rigid\u2014rigid assemblies need extra API calls to recover their internal transforms and mass properties.</p>"},{"location":"developing/#parsepy-flattening-onshape-data","title":"<code>parse.py</code> \u2014 Flattening Onshape Data","text":""},{"location":"developing/#pathkey-fundamentals","title":"PathKey fundamentals","text":"<ul> <li><code>PathKey</code> is a frozen dataclass that records both the raw instance ID path (<code>_path</code>) and a sanitized name path (<code>_name_path</code>).</li> <li>It preserves hierarchy (depth starts at 0 for root-level instances) and provides helpers like <code>.parent</code>, <code>.root</code>, <code>.name</code>, and ordering comparisons for consistent sorting.</li> <li>Every registry (<code>instances</code>, <code>occurrences</code>, <code>parts</code>, etc.) in <code>CAD</code> is keyed by <code>PathKey</code>.</li> </ul>"},{"location":"developing/#cad-registries","title":"CAD registries","text":"<p>The <code>CAD</code> class stores a denormalized, dictionary-based view of an assembly:</p> <ul> <li><code>keys_by_id</code> / <code>keys_by_name</code>: canonical lookups from ID or name tuples to <code>PathKey</code>.</li> <li><code>instances</code>: every <code>PartInstance</code> and <code>AssemblyInstance</code> reachable from the root assembly, including nested occurrences.</li> <li><code>occurrences</code>: absolute transforms for each instance, taken from the root assembly <code>occurrences</code> list.</li> <li><code>subassemblies</code>: every <code>SubAssembly</code> definition copied to each placement (keyed by <code>PathKey</code>) with rigidity flags applied.</li> <li><code>mates</code>: dictionary keyed by <code>(assembly_key, parent_key, child_key)</code> storing <code>MateFeatureData</code>. <code>assembly_key</code> is <code>None</code> for root-level mates and a <code>PathKey</code> for the owning subassembly.</li> <li><code>patterns</code>: <code>Pattern</code> objects keyed by pattern id with seed/instance paths rewritten to absolute coordinates.</li> <li><code>parts</code>: <code>Part</code> definitions (including synthetic parts for rigid assemblies) keyed by <code>PathKey</code>. Mass properties are fetched lazily.</li> </ul>"},{"location":"developing/#cadfrom_assembly-ingestion-order","title":"<code>CAD.from_assembly</code> ingestion order","text":"<p><code>CAD.from_assembly</code> orchestrates several private populators. Order matters because later steps depend on data from earlier ones.</p> <ol> <li>Instance naming (<code>_build_id_to_name_map</code>): Builds a UID\u2192name map from root and subassemblies before any <code>PathKey</code> creation.</li> <li>PathKey creation (<code>_build_path_keys_from_occurrences</code>): Iterates over root <code>occurrences</code> once to create all <code>PathKey</code> instances and seed the lookup dictionaries.</li> <li>Instances (<code>_populate_instances</code>): Recursively walks root <code>instances</code> and nested <code>SubAssembly.instances</code>, cloning each into the flat <code>instances</code> dict.</li> <li>Occurrences (<code>_populate_occurrences</code>): Stores transforms for every absolute occurrence in the root assembly list.</li> <li>Subassemblies (<code>_populate_subassemblies</code>): Copies each <code>SubAssembly</code> definition to every placement. If a placement depth is \u2265 <code>max_depth</code>, the subassembly (and its corresponding <code>AssemblyInstance</code>) is marked rigid.</li> <li>Parts (<code>_populate_parts</code>):</li> <li>Matches <code>PartInstance.uid</code> values back to part definitions and writes entries into <code>parts</code>.</li> <li>Sets <code>worldToPartTF</code> from the current occurrence transform.</li> <li>For parts buried inside rigid assemblies, records <code>rigidAssemblyKey</code>, <code>rigidAssemblyWorkspaceId</code>, and, if available, <code>rigidAssemblyToPartTF</code>. When the transform is missing, <code>fetch_occurrences_for_subassemblies</code> is invoked to retrieve <code>RootOccurrences</code> via the API.</li> <li>Creates synthetic <code>Part</code> objects for every rigid assembly placement so graph/robot stages can treat rigid assemblies like single parts.</li> <li>Mates (<code>_populate_mates</code>):</li> <li>Walks root <code>features</code> plus every flexible subassembly\u2019s <code>features</code>.</li> <li>Writes mates using absolute <code>PathKey</code> pairs while preserving assembly provenance (the first tuple slot).</li> <li>Normalizes <code>MateFeatureData.matedEntities</code> so index <code>0</code> is always the graph parent and index <code>1</code> the child.</li> <li>Patterns (<code>_populate_patterns</code>):</li> <li>Rewrites <code>seedToPatternInstances</code> paths to absolute coordinates.</li> <li>Calls <code>_flatten_patterns</code> to clone mates for every pattern instance. Cloned mates get transformed <code>MatedCS</code> values so pattern copies behave like unique joints.</li> </ol> <p>Populating mates after parts guarantees that pattern expansion and rigid-assembly remapping have the data they need. Patterns run last because they depend on both mates and occurrences.</p>"},{"location":"developing/#rigid-assemblies-and-max_depth","title":"Rigid assemblies and <code>max_depth</code>","text":"<ul> <li><code>max_depth</code> is applied during <code>_populate_subassemblies</code>: placements at or deeper than the limit are marked rigid. Their mates are excluded from flexible processing, and their internal parts are remapped later.</li> <li><code>get_rigid_assembly_root</code> walks up a <code>PathKey</code> hierarchy to find the top-most rigid assembly. The result is stored on <code>Part.rigidAssemblyKey</code>.</li> <li><code>rigidAssemblyToPartTF</code> holds the transform from the rigid assembly origin to the buried part. When it is unavailable, <code>fetch_occurrences_for_subassemblies</code> uses <code>Client.get_root_assembly</code> to retrieve the subassembly\u2019s own occurrences and fill in the missing data.</li> <li>Mass properties for rigid assemblies are fetched with <code>Client.get_assembly_mass_properties</code>, while regular parts use <code>Client.get_mass_property</code>.</li> </ul>"},{"location":"developing/#asynchronous-helpers","title":"Asynchronous helpers","text":"<ul> <li><code>fetch_mass_properties_for_parts(client)</code> runs after graph creation (see <code>Robot.from_graph</code>) and only fetches data for parts whose <code>MassProperty</code> is still <code>None</code> and that are not remapped rigid subassembly members.</li> <li><code>fetch_occurrences_for_subassemblies(client)</code> populates <code>SubAssembly.RootOccurrences</code> for rigid placements so remapping and mass properties stay correct.</li> </ul>"},{"location":"developing/#lookup-utilities","title":"Lookup utilities","text":"<p><code>CAD</code> provides several helpers for downstream consumers:</p> <ul> <li><code>get_path_key(path)</code>: Convert an ID or path list/tuple into the canonical <code>PathKey</code>.</li> <li><code>get_transform(path_key, wrt=None)</code>: Retrieve occurrence transforms with optional relative frame conversion.</li> <li><code>get_mates_from_root</code>, <code>get_mates_from_subassembly</code>, <code>get_all_mates_flattened</code>, <code>get_mate_data</code>, <code>get_mate_assembly</code>: Query mates with or without provenance.</li> </ul> <p>Use these helpers instead of touching the internal dictionaries\u2014doing so keeps remapping and provenance logic centralized.</p>"},{"location":"developing/#graphpy-building-the-kinematic-graph","title":"<code>graph.py</code> \u2014 Building the kinematic graph","text":"<p><code>KinematicGraph</code> extends <code>nx.DiGraph</code> and holds a directed representation of the robot\u2019s mating structure. Construction is done via <code>KinematicGraph.from_cad(cad, use_user_defined_root=True)</code>.</p>"},{"location":"developing/#build-pipeline","title":"Build pipeline","text":"<ol> <li>Mate remapping (<code>_remap_mates</code>): Before any graph logic, mates are rewritten so parts inside rigid assemblies are replaced with the rigid assembly\u2019s synthetic part. The method updates both <code>MateFeatureData</code> and <code>matedEntities[*].matedOccurrence</code> and adjusts <code>MatedCS</code> values using <code>rigidAssemblyToPartTF</code>.</li> <li>Determine involved parts (<code>_get_parts_involved_in_mates</code>): Collects every part that appears in a mate. This is the node set for the undirected graph.</li> <li>Initial graph (<code>create_graph</code>): Builds an undirected <code>networkx.Graph</code> so connected-component and root detection work with symmetric edges. Every node stores only the <code>PathKey</code>; node attributes are added later.</li> <li>Graph processing (<code>_process_graph</code>):</li> <li><code>remove_disconnected_subgraphs</code> trims the graph down to the largest connected component and prints a tree summary in the logs.</li> <li><code>_find_root_node</code> respects Onshape \u201cfixed\u201d occurrences if <code>use_user_defined_root</code> is <code>True</code>; otherwise it falls back to closeness centrality.</li> <li>A BFS tree from the root is used to orient the graph. Nodes are added with their full <code>Part</code> objects (<code>data=part</code>) so downstream stages have access to metadata.</li> <li>Edges inherit <code>MateFeatureData</code>. If the BFS orientation disagrees with the parent/child order captured earlier, <code>_process_graph</code> reverses <code>matedEntities</code> so downstream code always sees parent\u2192child ordering.</li> <li>Loops or extra edges not in the BFS tree are reattached using their stored orientation.</li> </ol>"},{"location":"developing/#node-and-edge-payloads","title":"Node and edge payloads","text":"<ul> <li>Nodes: keyed by <code>PathKey</code>, with attributes <code>data=&lt;Part&gt;</code>.</li> <li>Edges: parent\u2192child pairs with attribute <code>data=&lt;MateFeatureData&gt;</code>.</li> <li>The <code>KinematicGraph.root</code> attribute stores the root <code>PathKey</code>. <code>topological_order</code> is currently implicit (iterate over <code>nx.bfs_tree(graph, graph.root)</code> to reproduce the robot build order).</li> </ul>"},{"location":"developing/#utilities","title":"Utilities","text":"<ul> <li><code>convert_to_digraph</code>, <code>remove_disconnected_subgraphs</code>, <code>create_graph</code>, and <code>show()</code> are exposed for experimentation/debugging.</li> <li><code>show()</code> plots the graph with sanitized names. Use it when debugging connectivity issues.</li> <li>Because the graph mutates copies of mate data, upstream registries in <code>CAD</code> remain untouched.</li> </ul>"},{"location":"developing/#robotpy-generating-robot-models","title":"<code>robot.py</code> \u2014 Generating robot models","text":"<p><code>Robot</code> subclasses <code>nx.DiGraph</code> and ultimately holds the URDF/MJCF-ready structure.</p>"},{"location":"developing/#creation-robotfrom_graph","title":"Creation (<code>Robot.from_graph</code>)","text":"<ol> <li>Optionally fetch mass properties by calling <code>asyncio.run(kinematic_graph.cad.fetch_mass_properties_for_parts(client))</code>.</li> <li>Instantiate <code>Robot</code>, preserving the original <code>KinematicGraph</code> reference for later inspection.</li> <li>Add the root link using the root node\u2019s <code>Part</code> data.</li> <li>Traverse every edge in the graph:</li> <li>Retrieve <code>MateFeatureData</code> from the edge.</li> <li>Call <code>get_robot_joint</code> to convert the mate into URDF joints (fastened \u2192 <code>FixedJoint</code>, revolute \u2192 <code>RevoluteJoint</code>, slider/cylindrical \u2192 <code>PrismaticJoint</code>, ball \u2192 three chained revolute joints with dummy links).</li> <li>Call <code>get_robot_link</code> to create the child <code>Link</code>, compute its transform, and prepare an <code>Asset</code> descriptor.</li> <li>Add the child link (and any dummy links) as nodes and register the joint(s) as edges on the robot.</li> </ol> <p>Nodes carry three pieces of data:</p> <ul> <li><code>data</code>: the URDF/MJCF <code>Link</code>.</li> <li><code>asset</code>: an <code>Asset</code> descriptor, or <code>None</code> for dummy links.</li> <li><code>world_to_link_tf</code>: cached homogeneous transform for later reuse.</li> </ul> <p>Edges carry <code>data=&lt;BaseJoint&gt;</code> instances.</p>"},{"location":"developing/#link-generation-get_robot_link","title":"Link generation (<code>get_robot_link</code>)","text":"<ul> <li>Starts with the child mate coordinate system when available, falling back to <code>Part.worldToPartTF</code>.</li> <li>Computes mass, inertia, and center of mass if <code>MassProperty</code> exists; otherwise defaults are logged.</li> <li>Determines how to fetch STL assets:</li> <li>Regular parts use <code>WorkspaceType.M</code> (microversion) and <code>part.documentMicroversion</code>.</li> <li>Rigid assemblies use <code>WorkspaceType.W</code> with <code>rigidAssemblyWorkspaceId</code>.</li> <li>Versioned parts use <code>WorkspaceType.V</code> and <code>documentVersion</code>.</li> <li>Produces a <code>Link</code> with matching <code>VisualLink</code> and <code>CollisionLink</code>. Materials are randomly assigned for visualization.</li> </ul>"},{"location":"developing/#joint-generation-get_robot_joint","title":"Joint generation (<code>get_robot_joint</code>)","text":"<ul> <li>Respect the normalized parent/child order established in the graph.</li> <li>Creates <code>Origin</code> from the parent part frame to mate frame transform.</li> <li>Maintains a <code>used_joint_names</code> set to ensure URDF-safe unique joint names.</li> <li>Handles mimic joints, dummy links for ball mates, and keeps placeholders for future dynamics/limits enhancements.</li> </ul>"},{"location":"developing/#export-and-utilities","title":"Export and utilities","text":"<ul> <li><code>save(path, download_assets=True)</code> writes URDF/MJCF XML and optionally downloads STL assets through the <code>Asset</code> objects.</li> <li><code>to_urdf</code> and <code>to_mjcf</code> generate XML trees.</li> <li><code>show_tree</code> and <code>show_graph</code> visualize the resulting robot structure for debugging.</li> </ul>"},{"location":"developing/#working-with-the-onshape-api","title":"Working With the Onshape API","text":"<ul> <li><code>Client</code> centralizes all API calls: authentication, assembly fetch, mass properties, and STL downloads.</li> <li>All network work happens via <code>asyncio.to_thread</code> to avoid blocking the main thread. If you add new API interactions, mirror this approach so we stay thread-safe without rewriting the pipeline as fully async.</li> <li>Keep <code>WorkspaceType</code> selection accurate\u2014using a microversion when a workspace is required will trigger 404/409 responses from Onshape.</li> </ul>"},{"location":"developing/#debugging-tips","title":"Debugging Tips","text":"<ul> <li>Inspect <code>CAD</code> state quickly with <code>repr(cad)</code>; it prints counts for every registry.</li> <li>Use <code>cad.mates.items()</code> to confirm mate orientation and provenance before the graph stage.</li> <li>Call <code>graph.show()</code> or <code>robot.show_graph()</code> when debugging connectivity issues.</li> <li>When rigid assemblies behave oddly, confirm <code>rigidAssemblyToPartTF</code> is set. If not, ensure <code>CAD.from_assembly</code> received a <code>Client</code> so it can fetch <code>RootOccurrences</code>.</li> </ul>"},{"location":"developing/#testing","title":"Testing","text":"<p>The test suite validates critical functionality across the entire pipeline with 52 tests providing 48% coverage of core logic. Tests are designed to run quickly (&lt;1 second) without requiring Onshape API access.</p>"},{"location":"developing/#test-structure","title":"Test Structure","text":"<p>Tests are organized by functionality in the <code>tests/</code> directory:</p> <ul> <li><code>test_urdf_generation.py</code> (5 tests): End-to-end URDF generation with golden file comparison</li> <li><code>test_transforms.py</code> (16 tests): Coordinate frame transformations (MatedCS, Origin, joint/link positioning)</li> <li><code>test_robot.py</code> (6 tests): Robot generation, mate type coverage, joint limits, naming</li> <li><code>test_kinematic_graph.py</code> (9 tests): Graph construction, validation, rigid remapping</li> <li><code>test_cad.py</code> (11 tests): CAD parsing, rigid subassembly handling, name sanitization</li> <li><code>test_pathkey.py</code> (5 tests): PathKey behavior, sorting, validation</li> </ul>"},{"location":"developing/#running-tests","title":"Running Tests","text":"<pre><code># Run all tests\npytest tests/ -v\n\n# Run specific test module\npytest tests/test_transforms.py -v\n\n# Run with coverage report\npytest --cov --cov-report=term-missing\n\n# Run single test\npytest tests/test_transforms.py::TestMatedCSTransformations::test_identity_transform -v\n</code></pre>"},{"location":"developing/#testing-approach","title":"Testing Approach","text":"<p>1. Golden File Testing (<code>test_urdf_generation.py</code>)</p> <p>Tests compare generated URDF output against known-good reference files:</p> <pre><code># tests/data/assembly_expected.urdf is the golden file\nurdf_output = robot.to_urdf()\nis_equal, differences = compare_urdf_files(\n    generated_urdf, expected_urdf,\n    tolerance=1e-6, ignore_colors=True\n)\nassert is_equal, f\"URDF differs: {differences}\"\n</code></pre> <p>This catches regressions in URDF structure, transforms, or joint/link generation.</p> <p>2. Transform Validation (<code>test_transforms.py</code>)</p> <p>Tests validate coordinate frame transformations at multiple levels:</p> <ul> <li>MatedCS transformations: Identity, translation, rotation, composition</li> <li>Origin calculations: Matrix \u2192 Euler angle extraction</li> <li>Joint origins: Parent frame composition with <code>world_to_parent_tf</code></li> <li>Ball joints: 3-DOF decomposition into revolute joints + dummy links</li> </ul> <p>All comparisons use <code>np.allclose()</code> with tolerance for floating-point stability.</p> <p>3. Mate Type Coverage (<code>test_robot.py</code>)</p> <p>Every supported mate type is tested:</p> <pre><code># REVOLUTE \u2192 RevoluteJoint with axis\n# FASTENED \u2192 FixedJoint\n# SLIDER/CYLINDRICAL \u2192 PrismaticJoint\n# BALL \u2192 3 RevoluteJoints + 2 dummy links\n# PLANAR \u2192 DummyJoint (unsupported)\n</code></pre> <p>Tests verify correct joint type, axis direction, and limit values.</p> <p>4. Rigid Subassembly Testing (<code>test_cad.py</code>, <code>test_kinematic_graph.py</code>)</p> <p>Tests validate the complex rigid subassembly remapping logic:</p> <ul> <li><code>rigidAssemblyKey</code> assignment for parts within rigid assemblies</li> <li><code>rigidAssemblyToPartTF</code> transform propagation</li> <li>Mate filtering (internal mates removed, external mates preserved)</li> <li>Graph node depth limits when <code>max_depth</code> is applied</li> </ul> <p>5. Mocking External Dependencies</p> <p>Tests use mock clients to avoid network calls:</p> <pre><code>@dataclass\nclass DummyClient:\n    def download_part_stl(self, *_, **__):\n        raise RuntimeError(\"No network calls in unit tests\")\n</code></pre> <p>This keeps tests fast and deterministic.</p>"},{"location":"developing/#test-fixtures","title":"Test Fixtures","text":"<p>Shared fixtures provide consistent test data:</p> <ul> <li><code>assembly_json_path</code>: Path to <code>tests/data/assembly.json</code></li> <li><code>assembly</code>: Loaded Assembly object</li> <li><code>cad_doc</code>: CAD with <code>max_depth=2</code> (all flexible)</li> <li><code>cad_doc_depth_1</code>: CAD with <code>max_depth=1</code> (nested assemblies rigid)</li> <li><code>cad_doc_depth_0</code>: CAD with <code>max_depth=0</code> (all assemblies rigid)</li> </ul> <p>These fixtures test the same assembly at different rigidity levels.</p>"},{"location":"developing/#adding-new-tests","title":"Adding New Tests","text":"<p>When contributing new features:</p> <ol> <li> <p>Add tests in the appropriate module:</p> </li> <li> <p>Transform logic \u2192 <code>test_transforms.py</code></p> </li> <li>New mate type \u2192 <code>test_robot.py</code></li> <li>Parsing changes \u2192 <code>test_cad.py</code></li> <li> <p>Graph modifications \u2192 <code>test_kinematic_graph.py</code></p> </li> <li> <p>Use parametrized tests for multiple configurations:</p> </li> </ol> <pre><code>@pytest.mark.parametrize(\"mate_type,expected_joint\", [\n    (MateType.REVOLUTE, RevoluteJoint),\n    (MateType.SLIDER, PrismaticJoint),\n])\ndef test_mate_conversion(mate_type, expected_joint):\n    ...\n</code></pre> <ol> <li>Update golden files when URDF output changes intentionally:</li> </ol> <pre><code># Regenerate expected output\npython -c \"from tests.conftest import ...; generate_expected_urdf()\"\n</code></pre> <ol> <li>Test edge cases: Gimbal lock, name conflicts, disconnected graphs, etc.</li> </ol>"},{"location":"developing/#coverage-goals","title":"Coverage Goals","text":"<p>Current coverage focuses on core logic:</p> <ul> <li>models/assembly.py: 89% (mate handling, transforms)</li> <li>parse.py: 63% (CAD construction, rigid remapping)</li> <li>graph.py: 61% (graph building, validation)</li> <li>models/link.py: 40% (link generation)</li> <li>models/joint.py: 40% (joint types)</li> </ul> <p>Areas needing more coverage:</p> <ul> <li>connect.py: 22% (API client - mostly needs integration tests)</li> <li>robot.py: 35% (MJCF export, asset download)</li> <li>utilities/helpers.py: 37% (utility functions)</li> </ul>"},{"location":"developing/#contribution-checklist","title":"Contribution Checklist","text":"<ul> <li>Understand which stage you are modifying:</li> <li>parse for ingesting or transforming Onshape data.</li> <li>graph for reasoning about connectivity or kinematics.</li> <li>robot for export formats, joint/link behavior, or asset management.</li> <li>Preserve invariants:</li> <li><code>CAD.mates</code> must always store parent\u2192child ordering.</li> <li>Graph nodes/edges should only contain deep copies of data (no in-place mutations of <code>CAD</code> registries).</li> <li>Robot node keys remain <code>PathKey</code> objects so we can trace back to CAD data.</li> <li>Add tests alongside new features. Focus on:</li> <li>PathKey handling (depth/order) when touching the parser.</li> <li>Graph connectivity/root selection when altering graph logic.</li> <li>Joint/link outputs when introducing new mate types.</li> <li>Transform correctness using <code>np.allclose()</code> comparisons.</li> <li>Golden file updates for URDF/MJCF changes.</li> <li>Run the full test suite before committing:   <pre><code>pytest tests/ -v\nmake check  # Runs linting, type checking, and tests\n</code></pre></li> <li>Document new behavior here and keep inline comments concise. If you introduce a new pipeline stage or helper, summarize it in this handbook so future contributors know where to look.</li> </ul> <p>Keeping this document aligned with the code makes onboarding new contributors faster and protects the assumptions baked into each stage of the pipeline. Update it anytime you change the parse/graph/robot trio or introduce new developer-facing workflows.</p>"},{"location":"getting-started/","title":"Getting Started with <code>onshape-robotics-toolkit</code>","text":"<p>Welcome to the <code>onshape-robotics-toolkit</code> library! This guide will help you set up and start using the library to interact with Onshape's powerful REST API.</p> <p>The Onshape API allows developers to access, manipulate, and extend Onshape's CAD platform programmatically. The API communicates via HTTP requests, returning data in JSON format.</p>"},{"location":"getting-started/#how-onshape-api-works","title":"How Onshape API Works","text":"<p>The Onshape API supports the following HTTP methods:</p> <ul> <li>GET: Retrieve information (e.g., document details, element properties).</li> <li>POST: Create or update resources (e.g., add features, update parts).</li> <li>DELETE: Remove resources (e.g., delete configurations).</li> </ul> <p>Each API request typically consists of:</p> <ol> <li>Method: Defines the action (e.g., GET, POST, DELETE).</li> <li>URL: Specifies the endpoint and target resource.</li> <li>Query Parameters: Optional key-value pairs to refine the request.</li> <li>Headers: Metadata such as content type and authorization tokens.</li> <li>Payload Body: Data sent with POST requests.</li> </ol>"},{"location":"getting-started/#understanding-api-urls","title":"Understanding API URLs","text":"<p>An Onshape API URL is structured to identify specific documents, workspaces, and elements:</p> <p>Example URL:</p> <pre><code>https://cad.onshape.com/api/documents/e60c4803eaf2ac8be492c18e/w/d2558da712764516cc9fec62/e/6bed6b43463f6a46a37b4a22\n</code></pre> <p>Breakdown:</p> <ul> <li>Base URL: <code>https://cad.onshape.com/api</code> \u2013 The entry point for API requests.</li> <li>Document ID: <code>e60c4803eaf2ac8be492c18e</code> \u2013 The unique identifier for the document.</li> <li>Workspace ID: <code>d2558da712764516cc9fec62</code> \u2013 The active workspace within the document.</li> <li>Element ID: <code>6bed6b43463f6a46a37b4a22</code> \u2013 A specific element in the workspace (e.g., a part studio or assembly).</li> </ul>"},{"location":"getting-started/#authentication-secure-your-api-calls","title":"Authentication: Secure Your API Calls","text":"<p>Access to the Onshape API requires authentication using API keys. Follow these steps to set up authentication for your project:</p>"},{"location":"getting-started/#obtain-api-keys","title":"Obtain API Keys","text":"<ol> <li>Log in to your Onshape account and navigate to the Developer Portal.</li> <li>Generate your Access Key and Secret Key.</li> </ol>"},{"location":"getting-started/#configure-the-library","title":"Configure the Library","text":"<p>Create a <code>.env</code> file in the root directory of your project to securely store your API keys:</p> <pre><code>ONSHAPE_ACCESS_KEY = &lt;your_access_key&gt;\nONSHAPE_SECRET_KEY = &lt;your_secret_key&gt;\n</code></pre> <p>The <code>onshape-robotics-toolkit</code> library will automatically read these keys to authenticate your requests.</p>"},{"location":"getting-started/#install-the-library","title":"Install the Library","text":"<p>Install the <code>onshape-robotics-toolkit</code> library via pip:</p> <pre><code>pip install onshape-robotics-toolkit\n</code></pre>"},{"location":"getting-started/#first-api-call-example-usage","title":"First API Call: Example Usage","text":"<p>Here's an example of making a simple GET request to list documents using the <code>onshape-robotics-toolkit</code> library:</p> <pre><code>from onshape_robotics_toolkit.connect import Client\nfrom onshape_robotics_toolkit.models.document import Document\n\n# Initialize the client\nclient = osa.Client(\n    env=\"./.env\"\n)\n\n# Create a Document object from a URL\ndoc = Document.from_url(\n    url=\"https://cad.onshape.com/documents/a1c1addf75444f54b504f25c/w/0d17b8ebb2a4c76be9fff3c7/e/a86aaf34d2f4353288df8812\"\n)\n\n# Retrieve the assembly and its JSON representation\nassembly = client.get_assembly(\n    did=doc.did,\n    wtype=doc.wtype,\n    wid=doc.wid,\n    eid=doc.eid\n)\n\n# Print the assembly details\nprint(assembly)\n</code></pre>"},{"location":"getting-started/#whats-next","title":"What's Next?","text":"<ul> <li>Check out more examples and tutorials in the <code>onshape-robotics-toolkit</code> GitHub repository.</li> <li>Explore the Onshape API Documentation for detailed API reference.</li> </ul>"},{"location":"api/assembly/","title":"Assembly","text":"<p>This module defines data models for Assembly entities retrieved from Onshape REST API responses.</p> <p>The data models are implemented as Pydantic BaseModel classes, which are used to</p> <pre><code>1. Parse JSON responses from the API into Python objects.\n2. Validate the structure and types of the JSON responses.\n3. Provide type hints for better code clarity and autocompletion.\n</code></pre> <p>These models ensure that the data received from the API adheres to the expected format and types, facilitating easier and safer manipulation of the data within the application.</p> Models <ul> <li>Occurrence: Represents an occurrence of a part or sub-assembly within an assembly.</li> <li>Part: Represents a part within an assembly, including its properties and configuration.</li> <li>PartInstance: Represents an instance of a part within an assembly.</li> <li>AssemblyInstance: Represents an instance of an assembly within another assembly.</li> <li>AssemblyFeature: Represents a feature within an assembly, such as a mate or pattern.</li> <li>Pattern: Represents a pattern feature within an assembly, defining repeated instances of   parts or sub-assemblies.</li> <li>SubAssembly: Represents a sub-assembly within a larger assembly.</li> <li>RootAssembly: Represents the root assembly, which is the top-level assembly containing all parts   and sub-assemblies.</li> <li>Assembly: Represents the overall assembly, including all parts, sub-assemblies, and features.</li> </ul> Supplementary models <ul> <li>IDBase: Base model providing common attributes for Part, SubAssembly, and AssemblyInstance models.</li> <li>MatedCS: Represents a coordinate system used for mating parts within an assembly.</li> <li>MatedEntity: Represents an entity that is mated within an assembly, including its coordinate system.</li> <li>MateRelationMate: Represents a mate relation within an assembly, defining how parts or sub-assemblies   are connected.</li> <li>MateGroupFeatureOccurrence: Represents an occurrence of a mate group feature within an assembly.</li> <li>MateGroupFeatureData: Represents data for a mate group feature within an assembly.</li> <li>MateConnectorFeatureData: Represents data for a mate connector feature within an assembly.</li> <li>MateRelationFeatureData: Represents data for a mate relation feature within an assembly.</li> <li>MateFeatureData: Represents data for a mate feature within an assembly.</li> </ul> Enum <ul> <li>InstanceType: Enumerates the types of instances in an assembly, e.g. PART, ASSEMBLY.</li> <li>MateType: Enumerates the type of mate between two parts or assemblies, e.g. SLIDER,   CYLINDRICAL, REVOLUTE, etc.</li> <li>RelationType: Enumerates the type of mate relation between two parts or assemblies, e.g. LINEAR,   GEAR, SCREW, etc.</li> <li>AssemblyFeatureType: Enumerates the type of assembly feature, e.g. mate, mateRelation,   mateGroup, mateConnector</li> </ul>"},{"location":"api/assembly/#onshape_robotics_toolkit.models.assembly.Assembly","title":"<code>Assembly</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents the overall assembly, including all parts, sub-assemblies, and features.</p> JSON <pre><code>    {\n        \"rootAssembly\": {\n            \"instances\": [],\n            \"patterns\": [],\n            \"features\": [],\n            \"occurrences\": [],\n            \"fullConfiguration\": \"default\",\n            \"configuration\": \"default\",\n            \"documentId\": \"a1c1addf75444f54b504f25c\",\n            \"elementId\": \"0b0c209535554345432581fe\",\n            \"documentMicroversion\": \"349f6413cafefe8fb4ab3b07\"\n        },\n        \"subAssemblies\": [],\n        \"parts\": [],\n        \"partStudioFeatures\": []\n    }\n</code></pre> <p>Attributes:</p> Name Type Description <code>rootAssembly</code> <code>RootAssembly</code> <p>The root assembly in the document.</p> <code>subAssemblies</code> <code>list[SubAssembly]</code> <p>A list of sub-assemblies in the document.</p> <code>parts</code> <code>list[Part]</code> <p>A list of parts in the document.</p> <code>partStudioFeatures</code> <code>list[dict]</code> <p>A list of part studio features in the document.</p> Custom Attributes <p>document (Union[Document, None]): The document object associated with the assembly. Defaults to None. name (Union[str, None]): The name of the assembly. Defaults to None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Assembly(\n...     rootAssembly=RootAssembly(\n...         instances=[...],\n...         patterns=[...],\n...         features=[...],\n...         occurrences=[...],\n...         fullConfiguration=\"default\",\n...         configuration=\"default\",\n...         documentId=\"a1c1addf75444f54b504f25c\",\n...         elementId=\"0b0c209535554345432581fe\",\n...         documentMicroversion=\"349f6413cafefe8fb4ab3b07\",\n...     ),\n...     subAssemblies=[...],\n...     parts=[...],\n...     partStudioFeatures=[...],\n... )\nAssembly(\n    rootAssembly=RootAssembly(\n        instances=[...],\n        patterns=[...],\n        features=[...],\n        occurrences=[...],\n        fullConfiguration=\"default\",\n        configuration=\"default\",\n        documentId=\"a1c1addf75444f54b504f25c\",\n        elementId=\"0b0c209535554345432581fe\",\n        documentMicroversion=\"349f6413cafefe8fb4ab3b07\",\n    ),\n    subAssemblies=[...],\n    parts=[...],\n    partStudioFeatures=[...],\n)\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/assembly.py</code> <pre><code>class Assembly(BaseModel):\n    \"\"\"\n    Represents the overall assembly, including all parts, sub-assemblies, and features.\n\n    JSON:\n        ```json\n            {\n                \"rootAssembly\": {\n                    \"instances\": [],\n                    \"patterns\": [],\n                    \"features\": [],\n                    \"occurrences\": [],\n                    \"fullConfiguration\": \"default\",\n                    \"configuration\": \"default\",\n                    \"documentId\": \"a1c1addf75444f54b504f25c\",\n                    \"elementId\": \"0b0c209535554345432581fe\",\n                    \"documentMicroversion\": \"349f6413cafefe8fb4ab3b07\"\n                },\n                \"subAssemblies\": [],\n                \"parts\": [],\n                \"partStudioFeatures\": []\n            }\n        ```\n\n    Attributes:\n        rootAssembly (RootAssembly): The root assembly in the document.\n        subAssemblies (list[SubAssembly]): A list of sub-assemblies in the document.\n        parts (list[Part]): A list of parts in the document.\n        partStudioFeatures (list[dict]): A list of part studio features in the document.\n\n    Custom Attributes:\n        document (Union[Document, None]): The document object associated with the assembly. Defaults to None.\n        name (Union[str, None]): The name of the assembly. Defaults to None.\n\n\n    Examples:\n        &gt;&gt;&gt; Assembly(\n        ...     rootAssembly=RootAssembly(\n        ...         instances=[...],\n        ...         patterns=[...],\n        ...         features=[...],\n        ...         occurrences=[...],\n        ...         fullConfiguration=\"default\",\n        ...         configuration=\"default\",\n        ...         documentId=\"a1c1addf75444f54b504f25c\",\n        ...         elementId=\"0b0c209535554345432581fe\",\n        ...         documentMicroversion=\"349f6413cafefe8fb4ab3b07\",\n        ...     ),\n        ...     subAssemblies=[...],\n        ...     parts=[...],\n        ...     partStudioFeatures=[...],\n        ... )\n        Assembly(\n            rootAssembly=RootAssembly(\n                instances=[...],\n                patterns=[...],\n                features=[...],\n                occurrences=[...],\n                fullConfiguration=\"default\",\n                configuration=\"default\",\n                documentId=\"a1c1addf75444f54b504f25c\",\n                elementId=\"0b0c209535554345432581fe\",\n                documentMicroversion=\"349f6413cafefe8fb4ab3b07\",\n            ),\n            subAssemblies=[...],\n            parts=[...],\n            partStudioFeatures=[...],\n        )\n    \"\"\"\n\n    rootAssembly: RootAssembly = Field(..., description=\"The root assembly in the document.\")\n    subAssemblies: list[SubAssembly] = Field(..., description=\"A list of sub-assemblies in the document.\")\n    parts: list[Part] = Field(..., description=\"A list of parts in the document.\")\n    partStudioFeatures: list[dict] = Field(..., description=\"A list of part studio features in the document.\")\n\n    document: Union[Document, None] = Field(None, description=\"The document associated with the assembly.\")\n    name: Union[str, None] = Field(None, description=\"The name of the assembly.\")\n</code></pre>"},{"location":"api/assembly/#onshape_robotics_toolkit.models.assembly.AssemblyFeature","title":"<code>AssemblyFeature</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a feature within an assembly, such as a mate or pattern.</p> JSON <pre><code>    {\n    \"id\": \"Mw+URe/Uaxx5gIdlu\",\n    \"suppressed\": false,\n    \"featureType\": \"mate\",\n    \"featureData\": {\n        \"matedEntities\" :\n        [\n            {\n                \"matedOccurrence\" : [ \"MDUJyqGNo7JJll+/h\" ],\n                \"matedCS\" :\n                {\n                    \"xAxis\" : [ 1.0, 0.0, 0.0 ],\n                    \"yAxis\" : [ 0.0, 0.0, -1.0 ],\n                    \"zAxis\" : [ 0.0, 1.0, 0.0 ],\n                    \"origin\" : [ 0.0, -0.0505, 0.0 ]\n                }\n            }, {\n                \"matedOccurrence\" : [ \"MwoBIsds8rn1/0QXA\" ],\n                \"matedCS\" :\n                {\n                    \"xAxis\" : [ 0.8660254037844387, 0.0, -0.49999999999999994 ],\n                    \"yAxis\" : [ -0.49999999999999994, 0.0, -0.8660254037844387 ],\n                    \"zAxis\" : [ 0.0, 1.0, 0.0 ],\n                    \"origin\" : [ 0.0, -0.0505, 0.0 ]\n                }\n            }\n        ],\n        \"mateType\" : \"FASTENED\",\n        \"name\" : \"Fastened 1\"\n        }\n    }\n</code></pre> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>The unique identifier of the feature.</p> <code>suppressed</code> <code>bool</code> <p>Indicates if the feature is suppressed.</p> <code>featureType</code> <code>AssemblyFeatureType</code> <p>The type of the feature.</p> <code>featureData</code> <code>Union[MateGroupFeatureData, MateConnectorFeatureData, MateRelationFeatureData, MateFeatureData]</code> <p>Data associated with the assembly feature.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; AssemblyFeature(\n...     id=\"Mw+URe/Uaxx5gIdlu\",\n...     suppressed=False,\n...     featureType=AssemblyFeatureType.MATE,\n...     featureData=MateFeatureData(\n...         matedEntities=[...],\n...         mateType=MateType.FASTENED,\n...         name=\"Fastened 1\",\n...     ),\n... )\nAssemblyFeature(\n    id=\"Mw+URe/Uaxx5gIdlu\",\n    suppressed=False,\n    featureType=AssemblyFeatureType.MATE,\n    featureData=MateFeatureData(\n        matedEntities=[...],\n        mateType=MateType.FASTENED,\n        name=\"Fastened 1\"\n    )\n)\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/assembly.py</code> <pre><code>class AssemblyFeature(BaseModel):\n    \"\"\"\n    Represents a feature within an assembly, such as a mate or pattern.\n\n    JSON:\n        ```json\n            {\n            \"id\": \"Mw+URe/Uaxx5gIdlu\",\n            \"suppressed\": false,\n            \"featureType\": \"mate\",\n            \"featureData\": {\n                \"matedEntities\" :\n                [\n                    {\n                        \"matedOccurrence\" : [ \"MDUJyqGNo7JJll+/h\" ],\n                        \"matedCS\" :\n                        {\n                            \"xAxis\" : [ 1.0, 0.0, 0.0 ],\n                            \"yAxis\" : [ 0.0, 0.0, -1.0 ],\n                            \"zAxis\" : [ 0.0, 1.0, 0.0 ],\n                            \"origin\" : [ 0.0, -0.0505, 0.0 ]\n                        }\n                    }, {\n                        \"matedOccurrence\" : [ \"MwoBIsds8rn1/0QXA\" ],\n                        \"matedCS\" :\n                        {\n                            \"xAxis\" : [ 0.8660254037844387, 0.0, -0.49999999999999994 ],\n                            \"yAxis\" : [ -0.49999999999999994, 0.0, -0.8660254037844387 ],\n                            \"zAxis\" : [ 0.0, 1.0, 0.0 ],\n                            \"origin\" : [ 0.0, -0.0505, 0.0 ]\n                        }\n                    }\n                ],\n                \"mateType\" : \"FASTENED\",\n                \"name\" : \"Fastened 1\"\n                }\n            }\n        ```\n\n    Attributes:\n        id (str): The unique identifier of the feature.\n        suppressed (bool): Indicates if the feature is suppressed.\n        featureType (AssemblyFeatureType): The type of the feature.\n        featureData (Union[MateGroupFeatureData, MateConnectorFeatureData, MateRelationFeatureData, MateFeatureData]):\n            Data associated with the assembly feature.\n\n    Examples:\n        &gt;&gt;&gt; AssemblyFeature(\n        ...     id=\"Mw+URe/Uaxx5gIdlu\",\n        ...     suppressed=False,\n        ...     featureType=AssemblyFeatureType.MATE,\n        ...     featureData=MateFeatureData(\n        ...         matedEntities=[...],\n        ...         mateType=MateType.FASTENED,\n        ...         name=\"Fastened 1\",\n        ...     ),\n        ... )\n        AssemblyFeature(\n            id=\"Mw+URe/Uaxx5gIdlu\",\n            suppressed=False,\n            featureType=AssemblyFeatureType.MATE,\n            featureData=MateFeatureData(\n                matedEntities=[...],\n                mateType=MateType.FASTENED,\n                name=\"Fastened 1\"\n            )\n        )\n    \"\"\"\n\n    id: str = Field(..., description=\"The unique identifier of the feature.\")\n    suppressed: bool = Field(..., description=\"Indicates if the feature is suppressed.\")\n    featureType: AssemblyFeatureType = Field(..., description=\"The type of the feature.\")\n    featureData: Union[MateGroupFeatureData, MateConnectorFeatureData, MateRelationFeatureData, MateFeatureData] = (\n        Field(..., description=\"Data associated with the assembly feature.\")\n    )\n\n    @model_validator(mode=\"before\")\n    def validate_feature_data(cls, values: Any) -&gt; Any:\n        \"\"\"Custom validator to properly parse featureData based on featureType.\"\"\"\n        if isinstance(values, dict):\n            feature_type = values.get(\"featureType\")\n            feature_data = values.get(\"featureData\")\n\n            if feature_data and isinstance(feature_data, dict):\n                # Add the required 'id' field to featureData from the parent feature\n                feature_data[\"id\"] = values.get(\"id\", \"\")\n\n                # Parse based on feature type\n                if feature_type == AssemblyFeatureType.MATE:\n                    values[\"featureData\"] = MateFeatureData(**feature_data)\n                elif feature_type == AssemblyFeatureType.MATEGROUP:\n                    values[\"featureData\"] = MateGroupFeatureData(**feature_data)\n                elif feature_type == AssemblyFeatureType.MATECONNECTOR:\n                    values[\"featureData\"] = MateConnectorFeatureData(**feature_data)\n                elif feature_type == AssemblyFeatureType.MATERELATION:\n                    values[\"featureData\"] = MateRelationFeatureData(**feature_data)\n\n        return values\n</code></pre>"},{"location":"api/assembly/#onshape_robotics_toolkit.models.assembly.AssemblyFeature.validate_feature_data","title":"<code>validate_feature_data(values)</code>","text":"<p>Custom validator to properly parse featureData based on featureType.</p> Source code in <code>onshape_robotics_toolkit/models/assembly.py</code> <pre><code>@model_validator(mode=\"before\")\ndef validate_feature_data(cls, values: Any) -&gt; Any:\n    \"\"\"Custom validator to properly parse featureData based on featureType.\"\"\"\n    if isinstance(values, dict):\n        feature_type = values.get(\"featureType\")\n        feature_data = values.get(\"featureData\")\n\n        if feature_data and isinstance(feature_data, dict):\n            # Add the required 'id' field to featureData from the parent feature\n            feature_data[\"id\"] = values.get(\"id\", \"\")\n\n            # Parse based on feature type\n            if feature_type == AssemblyFeatureType.MATE:\n                values[\"featureData\"] = MateFeatureData(**feature_data)\n            elif feature_type == AssemblyFeatureType.MATEGROUP:\n                values[\"featureData\"] = MateGroupFeatureData(**feature_data)\n            elif feature_type == AssemblyFeatureType.MATECONNECTOR:\n                values[\"featureData\"] = MateConnectorFeatureData(**feature_data)\n            elif feature_type == AssemblyFeatureType.MATERELATION:\n                values[\"featureData\"] = MateRelationFeatureData(**feature_data)\n\n    return values\n</code></pre>"},{"location":"api/assembly/#onshape_robotics_toolkit.models.assembly.AssemblyFeatureType","title":"<code>AssemblyFeatureType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enumerates the type of assembly feature, e.g. mate, mateRelation, mateGroup, mateConnector</p> <p>Attributes:</p> Name Type Description <code>MATE</code> <code>str</code> <p>Represents a mate feature.</p> <code>MATERELATION</code> <code>str</code> <p>Represents a mate relation feature.</p> <code>MATEGROUP</code> <code>str</code> <p>Represents a mate group feature.</p> <code>MATECONNECTOR</code> <code>str</code> <p>Represents a mate connector feature.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; AssemblyFeatureType.MATE\n'mate'\n&gt;&gt;&gt; AssemblyFeatureType.MATERELATION\n'mateRelation'\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/assembly.py</code> <pre><code>class AssemblyFeatureType(str, Enum):\n    \"\"\"\n    Enumerates the type of assembly feature, e.g. mate, mateRelation, mateGroup, mateConnector\n\n    Attributes:\n        MATE (str): Represents a mate feature.\n        MATERELATION (str): Represents a mate relation feature.\n        MATEGROUP (str): Represents a mate group feature.\n        MATECONNECTOR (str): Represents a mate connector feature.\n\n    Examples:\n        &gt;&gt;&gt; AssemblyFeatureType.MATE\n        'mate'\n        &gt;&gt;&gt; AssemblyFeatureType.MATERELATION\n        'mateRelation'\n    \"\"\"\n\n    MATE = \"mate\"\n    MATERELATION = \"mateRelation\"\n    MATEGROUP = \"mateGroup\"\n    MATECONNECTOR = \"mateConnector\"\n</code></pre>"},{"location":"api/assembly/#onshape_robotics_toolkit.models.assembly.AssemblyInstance","title":"<code>AssemblyInstance</code>","text":"<p>               Bases: <code>IDBase</code></p> <p>Represents an instance of an assembly within another assembly.</p> JSON <pre><code>    {\n        \"id\": \"Mon18P7LPP8A9STk+\",\n        \"type\": \"Assembly\",\n        \"name\": \"subAssembly\",\n        \"suppressed\": false,\n        \"fullConfiguration\": \"default\",\n        \"configuration\": \"default\",\n        \"documentId\": \"a1c1addf75444f54b504f25c\",\n        \"elementId\": \"f0b3a4afab120f778a4037df\",\n        \"documentMicroversion\": \"349f6413cafefe8fb4ab3b07\"\n    }\n</code></pre> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>The unique identifier for the assembly instance.</p> <code>type</code> <code>InstanceType</code> <p>The type of the instance, must be 'Assembly'.</p> <code>name</code> <code>str</code> <p>The name of the assembly instance.</p> <code>suppressed</code> <code>bool</code> <p>Indicates if the assembly instance is suppressed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; AssemblyInstance(\n...     id=\"Mon18P7LPP8A9STk+\",\n...     type=InstanceType.ASSEMBLY,\n...     name=\"subAssembly\",\n...     suppressed=False,\n... )\nAssemblyInstance(\n    id=\"Mon18P7LPP8A9STk+\",\n    type=InstanceType.ASSEMBLY,\n    name=\"subAssembly\",\n    suppressed=False,\n)\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/assembly.py</code> <pre><code>class AssemblyInstance(IDBase):\n    \"\"\"\n    Represents an instance of an assembly within another assembly.\n\n    JSON:\n        ```json\n            {\n                \"id\": \"Mon18P7LPP8A9STk+\",\n                \"type\": \"Assembly\",\n                \"name\": \"subAssembly\",\n                \"suppressed\": false,\n                \"fullConfiguration\": \"default\",\n                \"configuration\": \"default\",\n                \"documentId\": \"a1c1addf75444f54b504f25c\",\n                \"elementId\": \"f0b3a4afab120f778a4037df\",\n                \"documentMicroversion\": \"349f6413cafefe8fb4ab3b07\"\n            }\n        ```\n\n    Attributes:\n        id (str): The unique identifier for the assembly instance.\n        type (InstanceType): The type of the instance, must be 'Assembly'.\n        name (str): The name of the assembly instance.\n        suppressed (bool): Indicates if the assembly instance is suppressed.\n\n    Examples:\n        &gt;&gt;&gt; AssemblyInstance(\n        ...     id=\"Mon18P7LPP8A9STk+\",\n        ...     type=InstanceType.ASSEMBLY,\n        ...     name=\"subAssembly\",\n        ...     suppressed=False,\n        ... )\n        AssemblyInstance(\n            id=\"Mon18P7LPP8A9STk+\",\n            type=InstanceType.ASSEMBLY,\n            name=\"subAssembly\",\n            suppressed=False,\n        )\n    \"\"\"\n\n    id: str = Field(..., description=\"The unique identifier for the assembly instance.\")\n    type: InstanceType = Field(..., description=\"The type of the instance, must be 'Assembly'.\")\n    name: str = Field(..., description=\"The name of the assembly instance.\")\n    suppressed: bool = Field(..., description=\"Indicates if the assembly instance is suppressed.\")\n    documentVersion: Union[str, None] = Field(None, description=\"The version of the document.\")\n\n    isRigid: bool = Field(\n        False,\n        description=\"Indicates if the assembly instance is a rigid assembly, i.e., \\\n        a sub-assembly with no degrees of freedom.\",\n    )\n\n    @field_validator(\"type\")\n    def check_type(cls, v: InstanceType) -&gt; InstanceType:\n        \"\"\"\n        Validates that the type is 'Assembly'.\n\n        Args:\n            v (InstanceType): The type to validate.\n\n        Returns:\n            InstanceType: The validated type.\n        \"\"\"\n        if v != InstanceType.ASSEMBLY:\n            raise ValueError(\"Type must be Assembly\")\n\n        return v\n</code></pre>"},{"location":"api/assembly/#onshape_robotics_toolkit.models.assembly.AssemblyInstance.check_type","title":"<code>check_type(v)</code>","text":"<p>Validates that the type is 'Assembly'.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>InstanceType</code> <p>The type to validate.</p> required <p>Returns:</p> Name Type Description <code>InstanceType</code> <code>InstanceType</code> <p>The validated type.</p> Source code in <code>onshape_robotics_toolkit/models/assembly.py</code> <pre><code>@field_validator(\"type\")\ndef check_type(cls, v: InstanceType) -&gt; InstanceType:\n    \"\"\"\n    Validates that the type is 'Assembly'.\n\n    Args:\n        v (InstanceType): The type to validate.\n\n    Returns:\n        InstanceType: The validated type.\n    \"\"\"\n    if v != InstanceType.ASSEMBLY:\n        raise ValueError(\"Type must be Assembly\")\n\n    return v\n</code></pre>"},{"location":"api/assembly/#onshape_robotics_toolkit.models.assembly.Features","title":"<code>Features</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents list of features within an assembly, such as a mate or relation. These are fetched separately from the main assembly call.</p> Source code in <code>onshape_robotics_toolkit/models/assembly.py</code> <pre><code>class Features(BaseModel):\n    \"\"\"\n    Represents list of features within an assembly, such as a mate or relation. These are\n    fetched separately from the main assembly call.\n    \"\"\"\n\n    features: list[Feature] = Field(..., description=\"A list of features in the assembly.\")\n    featureStates: list[FeatureState] = Field(..., description=\"A list of feature states in the assembly.\")\n    isComplete: bool = Field(..., description=\"Indicates if the feature list is complete.\")\n    serializationVersion: str = Field(..., description=\"The serialization version of the feature list.\")\n    sourceMicroversion: str = Field(..., description=\"The source microversion of the feature list.\")\n    rejectMicroversionSkew: bool = Field(..., description=\"Indicates if microversion skew is rejected.\")\n    microversionSkew: bool = Field(..., description=\"Indicates if microversion skew is allowed.\")\n    libraryVersion: int = Field(..., description=\"The library version of the feature list.\")\n</code></pre>"},{"location":"api/assembly/#onshape_robotics_toolkit.models.assembly.IDBase","title":"<code>IDBase</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base model providing common attributes for Part, SubAssembly, and AssemblyInstance models.</p> JSON <pre><code>    {\n        \"fullConfiguration\" : \"default\",\n        \"configuration\" : \"default\",\n        \"documentId\" : \"a1c1addf75444f54b504f25c\",\n        \"elementId\" : \"0b0c209535554345432581fe\",\n        \"documentMicroversion\" : \"12fabf866bef5a9114d8c4d2\"\n    }\n</code></pre> <p>Attributes:</p> Name Type Description <code>fullConfiguration</code> <code>str</code> <p>The full configuration of the entity.</p> <code>configuration</code> <code>str</code> <p>The configuration of the entity.</p> <code>documentId</code> <code>str</code> <p>The unique identifier of the entity.</p> <code>elementId</code> <code>str</code> <p>The unique identifier of the entity.</p> <code>documentMicroversion</code> <code>str</code> <p>The microversion of the document.</p> Source code in <code>onshape_robotics_toolkit/models/assembly.py</code> <pre><code>class IDBase(BaseModel):\n    \"\"\"\n    Base model providing common attributes for Part, SubAssembly, and AssemblyInstance models.\n\n    JSON:\n        ```json\n            {\n                \"fullConfiguration\" : \"default\",\n                \"configuration\" : \"default\",\n                \"documentId\" : \"a1c1addf75444f54b504f25c\",\n                \"elementId\" : \"0b0c209535554345432581fe\",\n                \"documentMicroversion\" : \"12fabf866bef5a9114d8c4d2\"\n            }\n        ```\n\n    Attributes:\n        fullConfiguration (str): The full configuration of the entity.\n        configuration (str): The configuration of the entity.\n        documentId (str): The unique identifier of the entity.\n        elementId (str): The unique identifier of the entity.\n        documentMicroversion (str): The microversion of the document.\n    \"\"\"\n\n    fullConfiguration: str = Field(..., description=\"The full configuration of the entity.\")\n    configuration: str = Field(..., description=\"The configuration of the entity.\")\n    documentId: str = Field(..., description=\"The unique identifier of the entity.\")\n    elementId: str = Field(..., description=\"The unique identifier of the entity.\")\n    documentMicroversion: str = Field(..., description=\"The microversion of the document.\")\n\n    @field_validator(\"documentId\", \"elementId\", \"documentMicroversion\")\n    def check_ids(cls, v: str) -&gt; str:\n        \"\"\"\n        Validates that the ID fields have exactly 24 characters.\n\n        Args:\n            v (str): The ID field to validate.\n\n        Returns:\n            str: The validated ID field.\n\n        Raises:\n            ValueError: If the ID field does not contain exactly 24 characters.\n        \"\"\"\n        if len(v) != 24:\n            raise ValueError(\"DocumentId must have 24 characters\")\n\n        return v\n\n    @property\n    def uid(self) -&gt; str:\n        \"\"\"\n        Generates a unique identifier for the part.\n\n        Returns:\n            str: The unique identifier generated from documentId, documentMicroversion,\n                elementId, and fullConfiguration.\n        \"\"\"\n        return generate_uid([self.documentId, self.documentMicroversion, self.elementId, self.fullConfiguration])\n</code></pre>"},{"location":"api/assembly/#onshape_robotics_toolkit.models.assembly.IDBase.uid","title":"<code>uid</code>  <code>property</code>","text":"<p>Generates a unique identifier for the part.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The unique identifier generated from documentId, documentMicroversion, elementId, and fullConfiguration.</p>"},{"location":"api/assembly/#onshape_robotics_toolkit.models.assembly.IDBase.check_ids","title":"<code>check_ids(v)</code>","text":"<p>Validates that the ID fields have exactly 24 characters.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>str</code> <p>The ID field to validate.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The validated ID field.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the ID field does not contain exactly 24 characters.</p> Source code in <code>onshape_robotics_toolkit/models/assembly.py</code> <pre><code>@field_validator(\"documentId\", \"elementId\", \"documentMicroversion\")\ndef check_ids(cls, v: str) -&gt; str:\n    \"\"\"\n    Validates that the ID fields have exactly 24 characters.\n\n    Args:\n        v (str): The ID field to validate.\n\n    Returns:\n        str: The validated ID field.\n\n    Raises:\n        ValueError: If the ID field does not contain exactly 24 characters.\n    \"\"\"\n    if len(v) != 24:\n        raise ValueError(\"DocumentId must have 24 characters\")\n\n    return v\n</code></pre>"},{"location":"api/assembly/#onshape_robotics_toolkit.models.assembly.InstanceType","title":"<code>InstanceType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enumerates the types of instances in an assembly, e.g. PART, ASSEMBLY.</p> <p>Attributes:</p> Name Type Description <code>PART</code> <code>str</code> <p>Represents a part instance.</p> <code>ASSEMBLY</code> <code>str</code> <p>Represents an assembly instance.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; InstanceType.PART\n'Part'\n&gt;&gt;&gt; InstanceType.ASSEMBLY\n'Assembly'\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/assembly.py</code> <pre><code>class InstanceType(str, Enum):\n    \"\"\"\n    Enumerates the types of instances in an assembly, e.g. PART, ASSEMBLY.\n\n    Attributes:\n        PART (str): Represents a part instance.\n        ASSEMBLY (str): Represents an assembly instance.\n\n    Examples:\n        &gt;&gt;&gt; InstanceType.PART\n        'Part'\n        &gt;&gt;&gt; InstanceType.ASSEMBLY\n        'Assembly'\n    \"\"\"\n\n    PART = \"Part\"\n    ASSEMBLY = \"Assembly\"\n</code></pre>"},{"location":"api/assembly/#onshape_robotics_toolkit.models.assembly.MateConnectorFeatureData","title":"<code>MateConnectorFeatureData</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents data for a mate connector feature within an assembly.</p> JSON <pre><code>    {\n        \"mateConnectorCS\": {\n            \"xAxis\": [1.0, 0.0, 0.0],\n            \"yAxis\": [0.0, 0.0, -1.0],\n            \"zAxis\": [0.0, 1.0, 0.0],\n            \"origin\": [0.0, -0.0505, 0.0]\n        },\n        \"occurrence\": [\n            \"MplKLzV/4d+nqmD18\"\n        ],\n        \"name\": \"Mate connector 1\"\n    }\n</code></pre> <p>Attributes:</p> Name Type Description <code>mateConnectorCS</code> <code>MatedCS</code> <p>The coordinate system used for the mate connector.</p> <code>occurrence</code> <code>list[str]</code> <p>A list of identifiers for the occurrences involved in the mate connector.</p> <code>name</code> <code>str</code> <p>The name of the mate connector feature.</p> Custom Attributes <p>id (str): The unique identifier of the feature.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; MateConnectorFeatureData(\n...     mateConnectorCS=MatedCS(\n...         xAxis=[1.0, 0.0, 0.0],\n...         yAxis=[0.0, 0.0, -1.0],\n...         zAxis=[0.0, 1.0, 0.0],\n...         origin=[0.0, -0.0505, 0.0],\n...     ),\n...     occurrence=[\"MplKLzV/4d+nqmD18\"],\n...     name=\"Mate connector 1\",\n... )\nMateConnectorFeatureData(\n    mateConnectorCS=MatedCS(\n        xAxis=[1.0, 0.0, 0.0],\n        yAxis=[0.0, 0.0, -1.0],\n        zAxis=[0.0, 1.0, 0.0],\n        origin=[0.0, -0.0505, 0.0]\n    ),\n    occurrence=[\"MplKLzV/4d+nqmD18\"],\n    name=\"Mate connector 1\"\n)\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/assembly.py</code> <pre><code>class MateConnectorFeatureData(BaseModel):\n    \"\"\"\n    Represents data for a mate connector feature within an assembly.\n\n    JSON:\n        ```json\n            {\n                \"mateConnectorCS\": {\n                    \"xAxis\": [1.0, 0.0, 0.0],\n                    \"yAxis\": [0.0, 0.0, -1.0],\n                    \"zAxis\": [0.0, 1.0, 0.0],\n                    \"origin\": [0.0, -0.0505, 0.0]\n                },\n                \"occurrence\": [\n                    \"MplKLzV/4d+nqmD18\"\n                ],\n                \"name\": \"Mate connector 1\"\n            }\n        ```\n\n    Attributes:\n        mateConnectorCS (MatedCS): The coordinate system used for the mate connector.\n        occurrence (list[str]): A list of identifiers for the occurrences involved in the mate connector.\n        name (str): The name of the mate connector feature.\n\n    Custom Attributes:\n        id (str): The unique identifier of the feature.\n\n    Examples:\n        &gt;&gt;&gt; MateConnectorFeatureData(\n        ...     mateConnectorCS=MatedCS(\n        ...         xAxis=[1.0, 0.0, 0.0],\n        ...         yAxis=[0.0, 0.0, -1.0],\n        ...         zAxis=[0.0, 1.0, 0.0],\n        ...         origin=[0.0, -0.0505, 0.0],\n        ...     ),\n        ...     occurrence=[\"MplKLzV/4d+nqmD18\"],\n        ...     name=\"Mate connector 1\",\n        ... )\n        MateConnectorFeatureData(\n            mateConnectorCS=MatedCS(\n                xAxis=[1.0, 0.0, 0.0],\n                yAxis=[0.0, 0.0, -1.0],\n                zAxis=[0.0, 1.0, 0.0],\n                origin=[0.0, -0.0505, 0.0]\n            ),\n            occurrence=[\"MplKLzV/4d+nqmD18\"],\n            name=\"Mate connector 1\"\n        )\n    \"\"\"\n\n    mateConnectorCS: MatedCS = Field(..., description=\"The coordinate system used for the mate connector.\")\n    occurrence: list[str] = Field(\n        ..., description=\"A list of identifiers for the occurrences involved in the mate connector.\"\n    )\n    name: str = Field(..., description=\"The name of the mate connector feature.\")\n\n    id: str = Field(..., description=\"The unique identifier of the feature.\")\n</code></pre>"},{"location":"api/assembly/#onshape_robotics_toolkit.models.assembly.MateFeatureData","title":"<code>MateFeatureData</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents data for a mate feature within an assembly.</p> JSON <pre><code>    {\n        \"matedEntities\" :\n        [\n            {\n                \"matedOccurrence\" : [ \"MDUJyqGNo7JJll+/h\" ],\n                \"matedCS\" :\n                {\n                    \"xAxis\" : [ 1.0, 0.0, 0.0 ],\n                    \"yAxis\" : [ 0.0, 0.0, -1.0 ],\n                    \"zAxis\" : [ 0.0, 1.0, 0.0 ],\n                    \"origin\" : [ 0.0, -0.0505, 0.0 ]\n                }\n            }, {\n                \"matedOccurrence\" : [ \"MwoBIsds8rn1/0QXA\" ],\n                \"matedCS\" :\n                {\n                    \"xAxis\" : [ 0.8660254037844387, 0.0, -0.49999999999999994 ],\n                    \"yAxis\" : [ -0.49999999999999994, 0.0, -0.8660254037844387 ],\n                    \"zAxis\" : [ 0.0, 1.0, 0.0 ],\n                    \"origin\" : [ 0.0, -0.0505, 0.0 ]\n                }\n            }\n        ],\n        \"mateType\" : \"FASTENED\",\n        \"name\" : \"Fastened 1\"\n    }\n</code></pre> <p>Attributes:</p> Name Type Description <code>matedEntities</code> <code>list[MatedEntity]</code> <p>A list of mated entities.</p> <code>mateType</code> <code>MateType</code> <p>The type of mate.</p> <code>name</code> <code>str</code> <p>The name of the mate feature.</p> Custom Attributes <p>id (str): The unique identifier of the feature. limits (dict[str, float] | None): Joint limits for the mate {'min': lower_limit, 'max': upper_limit}.     Fetched from Onshape features API if available.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; MateFeatureData(\n...     matedEntities=[...],\n...     mateType=MateType.FASTENED,\n...     name=\"Fastened 1\",\n... )\nMateFeatureData(\n    matedEntities=[...],\n    mateType=MateType.FASTENED,\n    name=\"Fastened 1\"\n)\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/assembly.py</code> <pre><code>class MateFeatureData(BaseModel):\n    \"\"\"\n    Represents data for a mate feature within an assembly.\n\n    JSON:\n        ```json\n            {\n                \"matedEntities\" :\n                [\n                    {\n                        \"matedOccurrence\" : [ \"MDUJyqGNo7JJll+/h\" ],\n                        \"matedCS\" :\n                        {\n                            \"xAxis\" : [ 1.0, 0.0, 0.0 ],\n                            \"yAxis\" : [ 0.0, 0.0, -1.0 ],\n                            \"zAxis\" : [ 0.0, 1.0, 0.0 ],\n                            \"origin\" : [ 0.0, -0.0505, 0.0 ]\n                        }\n                    }, {\n                        \"matedOccurrence\" : [ \"MwoBIsds8rn1/0QXA\" ],\n                        \"matedCS\" :\n                        {\n                            \"xAxis\" : [ 0.8660254037844387, 0.0, -0.49999999999999994 ],\n                            \"yAxis\" : [ -0.49999999999999994, 0.0, -0.8660254037844387 ],\n                            \"zAxis\" : [ 0.0, 1.0, 0.0 ],\n                            \"origin\" : [ 0.0, -0.0505, 0.0 ]\n                        }\n                    }\n                ],\n                \"mateType\" : \"FASTENED\",\n                \"name\" : \"Fastened 1\"\n            }\n        ```\n\n    Attributes:\n        matedEntities (list[MatedEntity]): A list of mated entities.\n        mateType (MateType): The type of mate.\n        name (str): The name of the mate feature.\n\n    Custom Attributes:\n        id (str): The unique identifier of the feature.\n        limits (dict[str, float] | None): Joint limits for the mate {'min': lower_limit, 'max': upper_limit}.\n            Fetched from Onshape features API if available.\n\n    Examples:\n        &gt;&gt;&gt; MateFeatureData(\n        ...     matedEntities=[...],\n        ...     mateType=MateType.FASTENED,\n        ...     name=\"Fastened 1\",\n        ... )\n        MateFeatureData(\n            matedEntities=[...],\n            mateType=MateType.FASTENED,\n            name=\"Fastened 1\"\n        )\n\n    \"\"\"\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n    matedEntities: list[MatedEntity] = Field(..., description=\"A list of mated entities.\")\n    mateType: MateType = Field(..., description=\"The type of mate.\")\n    name: str = Field(..., description=\"The name of the mate feature.\")\n\n    id: str = Field(..., description=\"The unique identifier of the feature.\")\n    limits: Union[dict[str, float], None] = Field(\n        None, description=\"Joint limits for the mate {'min': lower_limit, 'max': upper_limit}.\"\n    )\n</code></pre>"},{"location":"api/assembly/#onshape_robotics_toolkit.models.assembly.MateGroupFeatureData","title":"<code>MateGroupFeatureData</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents data for a mate group feature within an assembly.</p> <p>Mate groups are organizational features in Onshape that group multiple parts together without defining kinematic relationships between them. They are used by designers to organize complex assemblies and indicate that grouped parts should move as a single rigid body.</p> <ul> <li>Assemblies containing ONLY mate groups (no regular mates) are treated as rigid bodies</li> <li>Mate groups do not create kinematic joints or edges in the robot graph</li> <li>Parts in mate-group-only assemblies are merged into a single rigid assembly part</li> <li>Mixed assemblies (mate groups + regular mates) remain flexible, with mate groups   serving as organizational markers only</li> </ul> JSON <pre><code>    {\n        \"occurrences\": [\n            {\n                \"occurrence\": [\"MplKLzV/4d+nqmD18\"]\n            }\n        ],\n        \"name\": \"Mate group 1\"\n    }\n</code></pre> <p>Attributes:</p> Name Type Description <code>occurrences</code> <code>list[MateGroupFeatureOccurrence]</code> <p>A list of occurrences in the mate group feature.</p> <code>name</code> <code>str</code> <p>The name of the mate group feature.</p> Custom Attributes <p>id (str): The unique identifier of the feature.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; MateGroupFeatureData(\n...     occurrences=[\n...         MateGroupFeatureOccurrence(\n...             occurrence=[\"MplKLzV/4d+nqmD18\"],\n...         )\n...     ],\n...     name=\"Mate group 1\",\n... )\nMateGroupFeatureData(\n    occurrences=[\n        MateGroupFeatureOccurrence(\n            occurrence=[\"MplKLzV/4d+nqmD18\"]\n        )\n    ],\n    name=\"Mate group 1\"\n)\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/assembly.py</code> <pre><code>class MateGroupFeatureData(BaseModel):\n    \"\"\"\n    Represents data for a mate group feature within an assembly.\n\n    Mate groups are organizational features in Onshape that group multiple parts together\n    without defining kinematic relationships between them. They are used by designers to\n    organize complex assemblies and indicate that grouped parts should move as a single\n    rigid body.\n\n    - Assemblies containing ONLY mate groups (no regular mates) are treated as rigid bodies\n    - Mate groups do not create kinematic joints or edges in the robot graph\n    - Parts in mate-group-only assemblies are merged into a single rigid assembly part\n    - Mixed assemblies (mate groups + regular mates) remain flexible, with mate groups\n      serving as organizational markers only\n\n    JSON:\n        ```json\n            {\n                \"occurrences\": [\n                    {\n                        \"occurrence\": [\"MplKLzV/4d+nqmD18\"]\n                    }\n                ],\n                \"name\": \"Mate group 1\"\n            }\n        ```\n\n    Attributes:\n        occurrences (list[MateGroupFeatureOccurrence]): A list of occurrences in the mate group feature.\n        name (str): The name of the mate group feature.\n\n    Custom Attributes:\n        id (str): The unique identifier of the feature.\n\n    Examples:\n        &gt;&gt;&gt; MateGroupFeatureData(\n        ...     occurrences=[\n        ...         MateGroupFeatureOccurrence(\n        ...             occurrence=[\"MplKLzV/4d+nqmD18\"],\n        ...         )\n        ...     ],\n        ...     name=\"Mate group 1\",\n        ... )\n        MateGroupFeatureData(\n            occurrences=[\n                MateGroupFeatureOccurrence(\n                    occurrence=[\"MplKLzV/4d+nqmD18\"]\n                )\n            ],\n            name=\"Mate group 1\"\n        )\n    \"\"\"\n\n    occurrences: list[MateGroupFeatureOccurrence] = Field(\n        ..., description=\"A list of occurrences in the mate group feature.\"\n    )\n    name: str = Field(..., description=\"The name of the mate group feature.\")\n    id: str = Field(..., description=\"The unique identifier of the feature.\")\n</code></pre>"},{"location":"api/assembly/#onshape_robotics_toolkit.models.assembly.MateGroupFeatureOccurrence","title":"<code>MateGroupFeatureOccurrence</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents an occurrence of a mate group feature within an assembly.</p> JSON <pre><code>    {\n        \"occurrence\": [\"MplKLzV/4d+nqmD18\"]\n    }\n</code></pre> <p>Attributes:</p> Name Type Description <code>occurrence</code> <code>list[str]</code> <p>A list of identifiers for the occurrences in the mate group feature.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; MateGroupFeatureOccurrence(\n...     occurrence=[\"MplKLzV/4d+nqmD18\"],\n... )\nMateGroupFeatureOccurrence(\n    occurrence=[\"MplKLzV/4d+nqmD18\"]\n)\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/assembly.py</code> <pre><code>class MateGroupFeatureOccurrence(BaseModel):\n    \"\"\"\n    Represents an occurrence of a mate group feature within an assembly.\n\n    JSON:\n        ```json\n            {\n                \"occurrence\": [\"MplKLzV/4d+nqmD18\"]\n            }\n        ```\n\n    Attributes:\n        occurrence (list[str]): A list of identifiers for the occurrences in the mate group feature.\n\n    Examples:\n        &gt;&gt;&gt; MateGroupFeatureOccurrence(\n        ...     occurrence=[\"MplKLzV/4d+nqmD18\"],\n        ... )\n        MateGroupFeatureOccurrence(\n            occurrence=[\"MplKLzV/4d+nqmD18\"]\n        )\n    \"\"\"\n\n    occurrence: list[str] = Field(\n        ..., description=\"A list of identifiers for the occurrences in the mate group feature.\"\n    )\n</code></pre>"},{"location":"api/assembly/#onshape_robotics_toolkit.models.assembly.MateRelationFeatureData","title":"<code>MateRelationFeatureData</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents data for a mate relation feature within an assembly.</p> JSON <pre><code>    {\n        \"relationType\": \"GEAR\",\n        \"mates\": [\n            {\n            \"featureId\": \"S4/TgCRmQt1nIHHp\",\n            \"occurrence\": []\n            },\n            {\n            \"featureId\": \"QwaoOeXYPifsN7CP\",\n            \"occurrence\": []\n            }\n        ],\n        \"reverseDirection\": false,\n        \"relationRatio\": 1,\n        \"name\": \"Gear 1\"\n    }\n</code></pre> <p>Attributes:</p> Name Type Description <code>relationType</code> <code>RelationType</code> <p>The type of mate relation.</p> <code>mates</code> <code>list[MateRelationMate]</code> <p>A list of mate relations.</p> <code>reverseDirection</code> <code>bool</code> <p>Indicates if the direction of the mate relation is reversed.</p> <code>relationRatio</code> <code>Union[float, None]</code> <p>The ratio of the GEAR mate relation. Defaults to None.</p> <code>relationLength</code> <code>Union[float, None]</code> <p>The length of the RACK_AND_PINION mate relation. Defaults to None.</p> <code>name</code> <code>str</code> <p>The name of the mate relation feature.</p> Custom Attributes <p>id (str): The unique identifier of the feature.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; MateRelationFeatureData(\n...     relationType=RelationType.GEAR,\n...     mates=[...],\n...     reverseDirection=False,\n...     relationRatio=1,\n...     name=\"Gear 1\",\n... )\nMateRelationFeatureData(\n    relationType=RelationType.GEAR,\n    mates=[...],\n    reverseDirection=False,\n    relationRatio=1,\n    name=\"Gear 1\"\n)\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/assembly.py</code> <pre><code>class MateRelationFeatureData(BaseModel):\n    \"\"\"\n    Represents data for a mate relation feature within an assembly.\n\n    JSON:\n        ```json\n            {\n                \"relationType\": \"GEAR\",\n                \"mates\": [\n                    {\n                    \"featureId\": \"S4/TgCRmQt1nIHHp\",\n                    \"occurrence\": []\n                    },\n                    {\n                    \"featureId\": \"QwaoOeXYPifsN7CP\",\n                    \"occurrence\": []\n                    }\n                ],\n                \"reverseDirection\": false,\n                \"relationRatio\": 1,\n                \"name\": \"Gear 1\"\n            }\n        ```\n\n    Attributes:\n        relationType (RelationType): The type of mate relation.\n        mates (list[MateRelationMate]): A list of mate relations.\n        reverseDirection (bool): Indicates if the direction of the mate relation is reversed.\n        relationRatio (Union[float, None]): The ratio of the GEAR mate relation. Defaults to None.\n        relationLength (Union[float, None]): The length of the RACK_AND_PINION mate relation. Defaults to None.\n        name (str): The name of the mate relation feature.\n\n    Custom Attributes:\n        id (str): The unique identifier of the feature.\n\n    Examples:\n        &gt;&gt;&gt; MateRelationFeatureData(\n        ...     relationType=RelationType.GEAR,\n        ...     mates=[...],\n        ...     reverseDirection=False,\n        ...     relationRatio=1,\n        ...     name=\"Gear 1\",\n        ... )\n        MateRelationFeatureData(\n            relationType=RelationType.GEAR,\n            mates=[...],\n            reverseDirection=False,\n            relationRatio=1,\n            name=\"Gear 1\"\n        )\n    \"\"\"\n\n    relationType: RelationType = Field(..., description=\"The type of mate relation.\")\n    mates: list[MateRelationMate] = Field(..., description=\"A list of mate relations.\")\n    reverseDirection: bool = Field(..., description=\"Indicates if the direction of the mate relation is reversed.\")\n    relationRatio: Union[float, None] = Field(\n        None, description=\"The ratio of the GEAR mate relation. Defaults to None.\"\n    )\n    relationLength: Union[float, None] = Field(\n        None, description=\"The length of the RACK_AND_PINION mate relation. Defaults to None.\"\n    )\n    name: str = Field(..., description=\"The name of the mate relation feature.\")\n\n    id: str = Field(..., description=\"The unique identifier of the feature.\")\n</code></pre>"},{"location":"api/assembly/#onshape_robotics_toolkit.models.assembly.MateRelationMate","title":"<code>MateRelationMate</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a mate relation within an assembly, defining how parts or sub-assemblies are connected.</p> JSON <pre><code>    {\n        \"featureId\": \"S4/TgCRmQt1nIHHp\",\n        \"occurrence\": []\n    }\n</code></pre> <p>Attributes:</p> Name Type Description <code>featureId</code> <code>str</code> <p>The unique identifier of the mate feature.</p> <code>occurrence</code> <code>list[str]</code> <p>A list of identifiers for the occurrences involved in the mate relation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; MateRelationMate(\n...     featureId=\"S4/TgCRmQt1nIHHp\",\n...     occurrence=[],\n... )\nMateRelationMate(\n    featureId=\"S4/TgCRmQt1nIHHp\",\n    occurrence=[],\n)\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/assembly.py</code> <pre><code>class MateRelationMate(BaseModel):\n    \"\"\"\n    Represents a mate relation within an assembly, defining how parts or sub-assemblies are connected.\n\n    JSON:\n        ```json\n            {\n                \"featureId\": \"S4/TgCRmQt1nIHHp\",\n                \"occurrence\": []\n            }\n        ```\n\n    Attributes:\n        featureId (str): The unique identifier of the mate feature.\n        occurrence (list[str]): A list of identifiers for the occurrences involved in the mate relation.\n\n    Examples:\n        &gt;&gt;&gt; MateRelationMate(\n        ...     featureId=\"S4/TgCRmQt1nIHHp\",\n        ...     occurrence=[],\n        ... )\n        MateRelationMate(\n            featureId=\"S4/TgCRmQt1nIHHp\",\n            occurrence=[],\n        )\n    \"\"\"\n\n    featureId: str = Field(..., description=\"The unique identifier of the mate feature.\")\n    occurrence: list[str] = Field(\n        ..., description=\"A list of identifiers for the occurrences involved in the mate relation.\"\n    )\n</code></pre>"},{"location":"api/assembly/#onshape_robotics_toolkit.models.assembly.MateType","title":"<code>MateType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enumerates the type of mate between two parts or assemblies, e.g. SLIDER, CYLINDRICAL, REVOLUTE, etc.</p> <p>Attributes:</p> Name Type Description <code>SLIDER</code> <code>str</code> <p>Represents a slider mate.</p> <code>CYLINDRICAL</code> <code>str</code> <p>Represents a cylindrical mate.</p> <code>REVOLUTE</code> <code>str</code> <p>Represents a revolute mate.</p> <code>PIN_SLOT</code> <code>str</code> <p>Represents a pin-slot mate.</p> <code>PLANAR</code> <code>str</code> <p>Represents a planar mate.</p> <code>BALL</code> <code>str</code> <p>Represents a ball mate.</p> <code>FASTENED</code> <code>str</code> <p>Represents a fastened mate.</p> <code>PARALLEL</code> <code>str</code> <p>Represents a parallel mate.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; MateType.SLIDER\n'SLIDER'\n&gt;&gt;&gt; MateType.CYLINDRICAL\n'CYLINDRICAL'\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/assembly.py</code> <pre><code>class MateType(str, Enum):\n    \"\"\"\n    Enumerates the type of mate between two parts or assemblies, e.g. SLIDER, CYLINDRICAL, REVOLUTE, etc.\n\n    Attributes:\n        SLIDER (str): Represents a slider mate.\n        CYLINDRICAL (str): Represents a cylindrical mate.\n        REVOLUTE (str): Represents a revolute mate.\n        PIN_SLOT (str): Represents a pin-slot mate.\n        PLANAR (str): Represents a planar mate.\n        BALL (str): Represents a ball mate.\n        FASTENED (str): Represents a fastened mate.\n        PARALLEL (str): Represents a parallel mate.\n\n    Examples:\n        &gt;&gt;&gt; MateType.SLIDER\n        'SLIDER'\n        &gt;&gt;&gt; MateType.CYLINDRICAL\n        'CYLINDRICAL'\n    \"\"\"\n\n    SLIDER = \"SLIDER\"\n    CYLINDRICAL = \"CYLINDRICAL\"\n    REVOLUTE = \"REVOLUTE\"\n    PIN_SLOT = \"PIN_SLOT\"\n    PLANAR = \"PLANAR\"\n    BALL = \"BALL\"\n    FASTENED = \"FASTENED\"\n    PARALLEL = \"PARALLEL\"\n</code></pre>"},{"location":"api/assembly/#onshape_robotics_toolkit.models.assembly.MatedCS","title":"<code>MatedCS</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a coordinate system used for mating parts within an assembly.</p> JSON <pre><code>    {\n        \"xAxis\" : [ 1.0, 0.0, 0.0 ],\n        \"yAxis\" : [ 0.0, 0.0, -1.0 ],\n        \"zAxis\" : [ 0.0, 1.0, 0.0 ],\n        \"origin\" : [ 0.0, -0.0505, 0.0 ]\n    }\n</code></pre> <p>Attributes:</p> Name Type Description <code>xAxis</code> <code>list[float]</code> <p>The x-axis vector of the coordinate system.</p> <code>yAxis</code> <code>list[float]</code> <p>The y-axis vector of the coordinate system.</p> <code>zAxis</code> <code>list[float]</code> <p>The z-axis vector of the coordinate system.</p> <code>origin</code> <code>list[float]</code> <p>The origin point of the coordinate system.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; MatedCS(\n...     xAxis=[1.0, 0.0, 0.0],\n...     yAxis=[0.0, 0.0, -1.0],\n...     zAxis=[0.0, 1.0, 0.0],\n...     origin=[0.0, -0.0505, 0.0],\n... )\nMatedCS(\n    xAxis=[1.0, 0.0, 0.0],\n    yAxis=[0.0, 0.0, -1.0],\n    zAxis=[0.0, 1.0, 0.0],\n    origin=[0.0, -0.0505, 0.0]\n)\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/assembly.py</code> <pre><code>class MatedCS(BaseModel):\n    \"\"\"\n    Represents a coordinate system used for mating parts within an assembly.\n\n    JSON:\n        ```json\n            {\n                \"xAxis\" : [ 1.0, 0.0, 0.0 ],\n                \"yAxis\" : [ 0.0, 0.0, -1.0 ],\n                \"zAxis\" : [ 0.0, 1.0, 0.0 ],\n                \"origin\" : [ 0.0, -0.0505, 0.0 ]\n            }\n        ```\n\n    Attributes:\n        xAxis (list[float]): The x-axis vector of the coordinate system.\n        yAxis (list[float]): The y-axis vector of the coordinate system.\n        zAxis (list[float]): The z-axis vector of the coordinate system.\n        origin (list[float]): The origin point of the coordinate system.\n\n    Examples:\n        &gt;&gt;&gt; MatedCS(\n        ...     xAxis=[1.0, 0.0, 0.0],\n        ...     yAxis=[0.0, 0.0, -1.0],\n        ...     zAxis=[0.0, 1.0, 0.0],\n        ...     origin=[0.0, -0.0505, 0.0],\n        ... )\n        MatedCS(\n            xAxis=[1.0, 0.0, 0.0],\n            yAxis=[0.0, 0.0, -1.0],\n            zAxis=[0.0, 1.0, 0.0],\n            origin=[0.0, -0.0505, 0.0]\n        )\n    \"\"\"\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n    xAxis: list[float] = Field(..., description=\"The x-axis vector of the coordinate system.\")\n    yAxis: list[float] = Field(..., description=\"The y-axis vector of the coordinate system.\")\n    zAxis: list[float] = Field(..., description=\"The z-axis vector of the coordinate system.\")\n    origin: list[float] = Field(..., description=\"The origin point of the coordinate system.\")\n\n    tf: Union[np.ndarray, None] = Field(\n        None, description=\"The 4x4 transformation matrix from the part coordinate system to the mate coordinate system.\"\n    )\n\n    @field_validator(\"xAxis\", \"yAxis\", \"zAxis\", \"origin\")\n    def check_vectors(cls, v: list[float]) -&gt; list[float]:\n        \"\"\"\n        Validates that the vectors have exactly 3 values.\n\n        Args:\n            v (list[float]): The vector to validate.\n\n        Returns:\n            list[float]: The validated vector.\n\n        Raises:\n            ValueError: If the vector does not have exactly 3 values.\n        \"\"\"\n        if len(v) != 3:\n            raise ValueError(\"Vectors must have 3 values\")\n\n        return v\n\n    @property\n    def to_tf(self) -&gt; np.ndarray:\n        \"\"\"\n        Generates a transformation matrix from the part coordinate system to the mate coordinate system.\n\n        Returns:\n            np.ndarray: The 4x4 transformation matrix.\n        \"\"\"\n        if self.tf is not None:\n            return self.tf\n\n        rotation_matrix = np.array([self.xAxis, self.yAxis, self.zAxis]).T\n        translation_vector = np.array(self.origin)\n        part_to_mate_tf = np.eye(4)\n        part_to_mate_tf[:3, :3] = rotation_matrix\n        part_to_mate_tf[:3, 3] = translation_vector\n        return part_to_mate_tf\n\n    @classmethod\n    def from_tf(cls, tf: np.ndarray) -&gt; \"MatedCS\":\n        \"\"\"\n        Creates a MatedCS object from a 4x4 transformation matrix.\n\n        Args:\n            tf (np.ndarray): The 4x4 transformation matrix.\n\n        Returns:\n            MatedCS: The MatedCS object created from the transformation matrix.\n        \"\"\"\n        # Ensure tf is a regular ndarray\n        tf_array = np.asarray(tf)\n        return MatedCS(\n            xAxis=tf_array[:3, 0].flatten().tolist(),\n            yAxis=tf_array[:3, 1].flatten().tolist(),\n            zAxis=tf_array[:3, 2].flatten().tolist(),\n            origin=tf_array[:3, 3].flatten().tolist(),\n            tf=tf_array,\n        )\n</code></pre>"},{"location":"api/assembly/#onshape_robotics_toolkit.models.assembly.MatedCS.to_tf","title":"<code>to_tf</code>  <code>property</code>","text":"<p>Generates a transformation matrix from the part coordinate system to the mate coordinate system.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The 4x4 transformation matrix.</p>"},{"location":"api/assembly/#onshape_robotics_toolkit.models.assembly.MatedCS.check_vectors","title":"<code>check_vectors(v)</code>","text":"<p>Validates that the vectors have exactly 3 values.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>list[float]</code> <p>The vector to validate.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: The validated vector.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the vector does not have exactly 3 values.</p> Source code in <code>onshape_robotics_toolkit/models/assembly.py</code> <pre><code>@field_validator(\"xAxis\", \"yAxis\", \"zAxis\", \"origin\")\ndef check_vectors(cls, v: list[float]) -&gt; list[float]:\n    \"\"\"\n    Validates that the vectors have exactly 3 values.\n\n    Args:\n        v (list[float]): The vector to validate.\n\n    Returns:\n        list[float]: The validated vector.\n\n    Raises:\n        ValueError: If the vector does not have exactly 3 values.\n    \"\"\"\n    if len(v) != 3:\n        raise ValueError(\"Vectors must have 3 values\")\n\n    return v\n</code></pre>"},{"location":"api/assembly/#onshape_robotics_toolkit.models.assembly.MatedCS.from_tf","title":"<code>from_tf(tf)</code>  <code>classmethod</code>","text":"<p>Creates a MatedCS object from a 4x4 transformation matrix.</p> <p>Parameters:</p> Name Type Description Default <code>tf</code> <code>ndarray</code> <p>The 4x4 transformation matrix.</p> required <p>Returns:</p> Name Type Description <code>MatedCS</code> <code>MatedCS</code> <p>The MatedCS object created from the transformation matrix.</p> Source code in <code>onshape_robotics_toolkit/models/assembly.py</code> <pre><code>@classmethod\ndef from_tf(cls, tf: np.ndarray) -&gt; \"MatedCS\":\n    \"\"\"\n    Creates a MatedCS object from a 4x4 transformation matrix.\n\n    Args:\n        tf (np.ndarray): The 4x4 transformation matrix.\n\n    Returns:\n        MatedCS: The MatedCS object created from the transformation matrix.\n    \"\"\"\n    # Ensure tf is a regular ndarray\n    tf_array = np.asarray(tf)\n    return MatedCS(\n        xAxis=tf_array[:3, 0].flatten().tolist(),\n        yAxis=tf_array[:3, 1].flatten().tolist(),\n        zAxis=tf_array[:3, 2].flatten().tolist(),\n        origin=tf_array[:3, 3].flatten().tolist(),\n        tf=tf_array,\n    )\n</code></pre>"},{"location":"api/assembly/#onshape_robotics_toolkit.models.assembly.MatedEntity","title":"<code>MatedEntity</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents an entity that is mated within an assembly, including its coordinate system.</p> JSON <pre><code>    {\n        \"matedOccurrence\": [\"MDUJyqGNo7JJll+/h\"],\n        \"matedCS\": {\n            \"xAxis\": [1.0, 0.0, 0.0],\n            \"yAxis\": [0.0, 0.0, -1.0],\n            \"zAxis\": [0.0, 1.0, 0.0],\n            \"origin\": [0.0, -0.0505, 0.0]\n        }\n    }\n</code></pre> <p>Attributes:</p> Name Type Description <code>matedOccurrence</code> <code>list[str]</code> <p>A list of identifiers for the occurrences that are mated.</p> <code>matedCS</code> <code>MatedCS</code> <p>The coordinate system used for mating the parts.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; MatedEntity(\n...     matedOccurrence=[\"MDUJyqGNo7JJll+/h\"],\n...     matedCS=MatedCS(\n...         xAxis=[1.0, 0.0, 0.0],\n...         yAxis=[0.0, 0.0, -1.0],\n...         zAxis=[0.0, 1.0, 0.0],\n...         origin=[0.0, -0.0505, 0.0],\n...     ),\n... )\nMatedEntity(\n    matedOccurrence=[\"MDUJyqGNo7JJll+/h\"],\n    matedCS=MatedCS(\n        xAxis=[1.0, 0.0, 0.0],\n        yAxis=[0.0, 0.0, -1.0],\n        zAxis=[0.0, 1.0, 0.0],\n        origin=[0.0, -0.0505, 0.0]\n    )\n)\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/assembly.py</code> <pre><code>class MatedEntity(BaseModel):\n    \"\"\"\n    Represents an entity that is mated within an assembly, including its coordinate system.\n\n    JSON:\n        ```json\n            {\n                \"matedOccurrence\": [\"MDUJyqGNo7JJll+/h\"],\n                \"matedCS\": {\n                    \"xAxis\": [1.0, 0.0, 0.0],\n                    \"yAxis\": [0.0, 0.0, -1.0],\n                    \"zAxis\": [0.0, 1.0, 0.0],\n                    \"origin\": [0.0, -0.0505, 0.0]\n                }\n            }\n        ```\n\n    Attributes:\n        matedOccurrence (list[str]): A list of identifiers for the occurrences that are mated.\n        matedCS (MatedCS): The coordinate system used for mating the parts.\n\n    Examples:\n        &gt;&gt;&gt; MatedEntity(\n        ...     matedOccurrence=[\"MDUJyqGNo7JJll+/h\"],\n        ...     matedCS=MatedCS(\n        ...         xAxis=[1.0, 0.0, 0.0],\n        ...         yAxis=[0.0, 0.0, -1.0],\n        ...         zAxis=[0.0, 1.0, 0.0],\n        ...         origin=[0.0, -0.0505, 0.0],\n        ...     ),\n        ... )\n        MatedEntity(\n            matedOccurrence=[\"MDUJyqGNo7JJll+/h\"],\n            matedCS=MatedCS(\n                xAxis=[1.0, 0.0, 0.0],\n                yAxis=[0.0, 0.0, -1.0],\n                zAxis=[0.0, 1.0, 0.0],\n                origin=[0.0, -0.0505, 0.0]\n            )\n        )\n    \"\"\"\n\n    matedOccurrence: list[str] = Field(..., description=\"A list of identifiers for the occurrences that are mated.\")\n    matedCS: MatedCS = Field(..., description=\"The coordinate system used for mating the parts.\")\n</code></pre>"},{"location":"api/assembly/#onshape_robotics_toolkit.models.assembly.Occurrence","title":"<code>Occurrence</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents an occurrence of a part or sub-assembly within an assembly.</p> JSON <pre><code>    {\n        \"fixed\": false,\n        \"transform\": [\n            0.8660254037844396, 0.0, 0.5000000000000004, 0.09583333333333346,\n            0.0, 1.0, 0.0, -1.53080849893419E-19,\n            -0.5000000000000004, 0.0, 0.8660254037844396, 0.16598820239201767,\n            0.0, 0.0, 0.0, 1.0\n        ],\n        \"hidden\": false,\n        \"path\": [\"M0Cyvy+yIq8Rd7En0\"]\n    }\n</code></pre> <p>Attributes:</p> Name Type Description <code>fixed</code> <code>bool</code> <p>Indicates if the occurrence is fixed in space.</p> <code>transform</code> <code>list[float]</code> <p>A 4x4 transformation matrix represented as a list of 16 floats.</p> <code>hidden</code> <code>bool</code> <p>Indicates if the occurrence is hidden.</p> <code>path</code> <code>list[str]</code> <p>A list of strings representing the path to the instance.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Occurrence(\n...     fixed=False,\n...     transform=[\n...         0.8660254037844396, 0.0, 0.5000000000000004, 0.09583333333333346,\n...         0.0, 1.0, 0.0, -1.53080849893419E-19,\n...         -0.5000000000000004, 0.0, 0.8660254037844396, 0.16598820239201767,\n...         0.0, 0.0, 0.0, 1.0)\n...     ],\n...     hidden=False,\n...     path=[\"M0Cyvy+yIq8Rd7En0\"]\n... )\nOccurrence(\n    fixed=False,\n    transform=[...],\n    hidden=False,\n    path=[\"M0Cyvy+yIq8Rd7En0\"]\n)\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/assembly.py</code> <pre><code>class Occurrence(BaseModel):\n    \"\"\"\n    Represents an occurrence of a part or sub-assembly within an assembly.\n\n    JSON:\n        ```json\n            {\n                \"fixed\": false,\n                \"transform\": [\n                    0.8660254037844396, 0.0, 0.5000000000000004, 0.09583333333333346,\n                    0.0, 1.0, 0.0, -1.53080849893419E-19,\n                    -0.5000000000000004, 0.0, 0.8660254037844396, 0.16598820239201767,\n                    0.0, 0.0, 0.0, 1.0\n                ],\n                \"hidden\": false,\n                \"path\": [\"M0Cyvy+yIq8Rd7En0\"]\n            }\n        ```\n\n    Attributes:\n        fixed (bool): Indicates if the occurrence is fixed in space.\n        transform (list[float]): A 4x4 transformation matrix represented as a list of 16 floats.\n        hidden (bool): Indicates if the occurrence is hidden.\n        path (list[str]): A list of strings representing the path to the instance.\n\n    Examples:\n        &gt;&gt;&gt; Occurrence(\n        ...     fixed=False,\n        ...     transform=[\n        ...         0.8660254037844396, 0.0, 0.5000000000000004, 0.09583333333333346,\n        ...         0.0, 1.0, 0.0, -1.53080849893419E-19,\n        ...         -0.5000000000000004, 0.0, 0.8660254037844396, 0.16598820239201767,\n        ...         0.0, 0.0, 0.0, 1.0)\n        ...     ],\n        ...     hidden=False,\n        ...     path=[\"M0Cyvy+yIq8Rd7En0\"]\n        ... )\n        Occurrence(\n            fixed=False,\n            transform=[...],\n            hidden=False,\n            path=[\"M0Cyvy+yIq8Rd7En0\"]\n        )\n    \"\"\"\n\n    fixed: bool = Field(..., description=\"Indicates if the occurrence is fixed in space.\")\n    transform: list[float] = Field(..., description=\"A 4x4 transformation matrix represented as a list of 16 floats.\")\n    hidden: bool = Field(..., description=\"Indicates if the occurrence is hidden.\")\n    path: list[str] = Field(..., description=\"A list of strings representing the path to the instance.\")\n\n    @field_validator(\"transform\")\n    def check_transform(cls, v: list[float]) -&gt; list[float]:\n        \"\"\"\n        Validates that the transform list has exactly 16 values.\n\n        Args:\n            v (list[float]): The transform list to validate.\n\n        Returns:\n            list[float]: The validated transform list.\n\n        Raises:\n            ValueError: If the transform list does not contain exactly 16 values.\n        \"\"\"\n        if len(v) != 16:\n            raise ValueError(\"Transform must have 16 values\")\n\n        return v\n\n    @property\n    def tf(self) -&gt; npt.NDArray[np.floating[Any]]:\n        \"\"\"\n        Converts the flat list representation of the transformation matrix into a 4x4 numpy array.\n\n        Returns:\n            np.ndarray: A 4x4 numpy array representing the transformation matrix.\n        \"\"\"\n        return np.array(self.transform).reshape(4, 4)\n\n    def tf_wrt(self, ref_tf: np.ndarray) -&gt; npt.NDArray[np.floating[Any]]:\n        \"\"\"\n        Computes the transformation matrix of this occurrence with respect to a reference transformation matrix.\n\n        Args:\n            ref_tf (np.ndarray): The reference 4x4 transformation matrix.\n\n        Returns:\n            np.ndarray: The 4x4 transformation matrix of this occurrence with respect to the reference.\n        \"\"\"\n        result: npt.NDArray[np.floating[Any]] = np.linalg.inv(ref_tf) @ self.tf\n        return result\n</code></pre>"},{"location":"api/assembly/#onshape_robotics_toolkit.models.assembly.Occurrence.tf","title":"<code>tf</code>  <code>property</code>","text":"<p>Converts the flat list representation of the transformation matrix into a 4x4 numpy array.</p> <p>Returns:</p> Type Description <code>NDArray[floating[Any]]</code> <p>np.ndarray: A 4x4 numpy array representing the transformation matrix.</p>"},{"location":"api/assembly/#onshape_robotics_toolkit.models.assembly.Occurrence.check_transform","title":"<code>check_transform(v)</code>","text":"<p>Validates that the transform list has exactly 16 values.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>list[float]</code> <p>The transform list to validate.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: The validated transform list.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the transform list does not contain exactly 16 values.</p> Source code in <code>onshape_robotics_toolkit/models/assembly.py</code> <pre><code>@field_validator(\"transform\")\ndef check_transform(cls, v: list[float]) -&gt; list[float]:\n    \"\"\"\n    Validates that the transform list has exactly 16 values.\n\n    Args:\n        v (list[float]): The transform list to validate.\n\n    Returns:\n        list[float]: The validated transform list.\n\n    Raises:\n        ValueError: If the transform list does not contain exactly 16 values.\n    \"\"\"\n    if len(v) != 16:\n        raise ValueError(\"Transform must have 16 values\")\n\n    return v\n</code></pre>"},{"location":"api/assembly/#onshape_robotics_toolkit.models.assembly.Occurrence.tf_wrt","title":"<code>tf_wrt(ref_tf)</code>","text":"<p>Computes the transformation matrix of this occurrence with respect to a reference transformation matrix.</p> <p>Parameters:</p> Name Type Description Default <code>ref_tf</code> <code>ndarray</code> <p>The reference 4x4 transformation matrix.</p> required <p>Returns:</p> Type Description <code>NDArray[floating[Any]]</code> <p>np.ndarray: The 4x4 transformation matrix of this occurrence with respect to the reference.</p> Source code in <code>onshape_robotics_toolkit/models/assembly.py</code> <pre><code>def tf_wrt(self, ref_tf: np.ndarray) -&gt; npt.NDArray[np.floating[Any]]:\n    \"\"\"\n    Computes the transformation matrix of this occurrence with respect to a reference transformation matrix.\n\n    Args:\n        ref_tf (np.ndarray): The reference 4x4 transformation matrix.\n\n    Returns:\n        np.ndarray: The 4x4 transformation matrix of this occurrence with respect to the reference.\n    \"\"\"\n    result: npt.NDArray[np.floating[Any]] = np.linalg.inv(ref_tf) @ self.tf\n    return result\n</code></pre>"},{"location":"api/assembly/#onshape_robotics_toolkit.models.assembly.Part","title":"<code>Part</code>","text":"<p>               Bases: <code>IDBase</code></p> <p>Represents a part within an assembly, including its properties and configuration.</p> JSON <pre><code>    {\n        \"isStandardContent\": false,\n        \"partId\": \"RDBD\",\n        \"bodyType\": \"solid\",\n        \"fullConfiguration\": \"default\",\n        \"configuration\": \"default\",\n        \"documentId\": \"a1c1addf75444f54b504f25c\",\n        \"elementId\": \"0b0c209535554345432581fe\",\n        \"documentMicroversion\": \"349f6413cafefe8fb4ab3b07\"\n    }\n</code></pre> <p>Attributes:</p> Name Type Description <code>isStandardContent</code> <code>bool</code> <p>Indicates if the part is standard content.</p> <code>partId</code> <code>str</code> <p>The unique identifier of the part.</p> <code>bodyType</code> <code>str</code> <p>The type of the body (e.g., solid, surface).</p> Custom Attributes <p>MassProperty (Union[MassProperties, None]): The mass properties of the part, if available.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Part(\n...     isStandardContent=False,\n...     partId=\"RDBD\",\n...     bodyType=\"solid\",\n... )\nPart(\n    isStandardContent=False,\n    partId=\"RDBD\",\n    bodyType=\"solid\",\n    MassProperty=None\n)\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/assembly.py</code> <pre><code>class Part(IDBase):\n    \"\"\"\n    Represents a part within an assembly, including its properties and configuration.\n\n    JSON:\n        ```json\n            {\n                \"isStandardContent\": false,\n                \"partId\": \"RDBD\",\n                \"bodyType\": \"solid\",\n                \"fullConfiguration\": \"default\",\n                \"configuration\": \"default\",\n                \"documentId\": \"a1c1addf75444f54b504f25c\",\n                \"elementId\": \"0b0c209535554345432581fe\",\n                \"documentMicroversion\": \"349f6413cafefe8fb4ab3b07\"\n            }\n        ```\n\n    Attributes:\n        isStandardContent (bool): Indicates if the part is standard content.\n        partId (str): The unique identifier of the part.\n        bodyType (str): The type of the body (e.g., solid, surface).\n\n    Custom Attributes:\n        MassProperty (Union[MassProperties, None]): The mass properties of the part, if available.\n\n    Examples:\n        &gt;&gt;&gt; Part(\n        ...     isStandardContent=False,\n        ...     partId=\"RDBD\",\n        ...     bodyType=\"solid\",\n        ... )\n        Part(\n            isStandardContent=False,\n            partId=\"RDBD\",\n            bodyType=\"solid\",\n            MassProperty=None\n        )\n\n    \"\"\"\n\n    isStandardContent: bool = Field(..., description=\"Indicates if the part is standard content.\")\n    partId: str = Field(..., description=\"The unique identifier of the part.\")\n    bodyType: str = Field(..., description=\"The type of the body (e.g., solid, surface).\")\n    mateConnectors: list[Union[PartMateConnector, None]] = Field(\n        default_factory=list,\n        description=\"The mate connectors that belong to the part.\",\n    )\n    documentVersion: Union[str, None] = Field(None, description=\"The version of the document.\")\n    MassProperty: Union[MassProperties, None] = Field(\n        None, description=\"The mass properties of the part, this is a retrieved via a separate API call.\"\n    )\n\n    isRigidAssembly: bool = Field(\n        False, description=\"Indicates if the part is a rigid assembly, i.e., a sub-assembly with no degrees of freedom.\"\n    )\n    rigidAssemblyKey: Union[Any, None] = Field(\n        None, description=\"The unique key of the rigid assembly, if it is a sub-assembly.\"\n    )\n    rigidAssemblyToPartTF: Union[\"MatedCS\", None] = Field(\n        None, description=\"The transformation matrix from the rigid assembly to the part coordinate system.\"\n    )\n    rigidAssemblyWorkspaceId: Union[str, None] = Field(\n        None, description=\"The workspace ID of the rigid assembly, if it is a sub-assembly.\"\n    )\n    worldToPartTF: Union[\"MatedCS\", None] = Field(\n        None, description=\"The transformation matrix representing the part wrt world coordinates\"\n    )\n\n    @property\n    def uid(self) -&gt; str:\n        \"\"\"\n        Generates a unique identifier for the part.\n\n        Returns:\n            str: The unique identifier generated from documentId, documentMicroversion,\n                elementId, partId, and fullConfiguration.\n        \"\"\"\n        return generate_uid([\n            self.documentId,\n            self.documentMicroversion,\n            self.elementId,\n            self.partId,\n            self.fullConfiguration,\n        ])\n</code></pre>"},{"location":"api/assembly/#onshape_robotics_toolkit.models.assembly.Part.uid","title":"<code>uid</code>  <code>property</code>","text":"<p>Generates a unique identifier for the part.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The unique identifier generated from documentId, documentMicroversion, elementId, partId, and fullConfiguration.</p>"},{"location":"api/assembly/#onshape_robotics_toolkit.models.assembly.PartInstance","title":"<code>PartInstance</code>","text":"<p>               Bases: <code>IDBase</code></p> <p>Represents an instance of a part within an assembly.</p> JSON <pre><code>    {\n        \"isStandardContent\": false,\n        \"type\": \"Part\",\n        \"id\": \"M0Cyvy+yIq8Rd7En0\",\n        \"name\": \"Part 1 &lt;2&gt;\",\n        \"suppressed\": false,\n        \"partId\": \"JHD\",\n        \"fullConfiguration\": \"default\",\n        \"configuration\": \"default\",\n        \"documentId\": \"a1c1addf75444f54b504f25c\",\n        \"elementId\": \"0b0c209535554345432581fe\",\n        \"documentMicroversion\": \"349f6413cafefe8fb4ab3b07\"\n    }\n</code></pre> <p>Attributes:</p> Name Type Description <code>isStandardContent</code> <code>bool</code> <p>Indicates if the part is standard content.</p> <code>type</code> <code>InstanceType</code> <p>The type of the instance, must be 'Part'.</p> <code>id</code> <code>str</code> <p>The unique identifier for the part instance.</p> <code>name</code> <code>str</code> <p>The name of the part instance.</p> <code>suppressed</code> <code>bool</code> <p>Indicates if the part instance is suppressed.</p> <code>partId</code> <code>str</code> <p>The identifier for the part.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; PartInstance(\n...     isStandardContent=False,\n...     type=InstanceType.PART,\n...     id=\"M0Cyvy+yIq8Rd7En0\",\n...     name=\"Part 1 &lt;2&gt;\",\n...     suppressed=False,\n...     partId=\"JHD\",\n... )\nPartInstance(\n    isStandardContent=False,\n    type=InstanceType.PART,\n    id=\"M0Cyvy+yIq8Rd7En0\",\n    name=\"Part 1 &lt;2&gt;\",\n    suppressed=False,\n    partId=\"JHD\",\n)\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/assembly.py</code> <pre><code>class PartInstance(IDBase):\n    \"\"\"\n    Represents an instance of a part within an assembly.\n\n    JSON:\n        ```json\n            {\n                \"isStandardContent\": false,\n                \"type\": \"Part\",\n                \"id\": \"M0Cyvy+yIq8Rd7En0\",\n                \"name\": \"Part 1 &lt;2&gt;\",\n                \"suppressed\": false,\n                \"partId\": \"JHD\",\n                \"fullConfiguration\": \"default\",\n                \"configuration\": \"default\",\n                \"documentId\": \"a1c1addf75444f54b504f25c\",\n                \"elementId\": \"0b0c209535554345432581fe\",\n                \"documentMicroversion\": \"349f6413cafefe8fb4ab3b07\"\n            }\n        ```\n\n    Attributes:\n        isStandardContent (bool): Indicates if the part is standard content.\n        type (InstanceType): The type of the instance, must be 'Part'.\n        id (str): The unique identifier for the part instance.\n        name (str): The name of the part instance.\n        suppressed (bool): Indicates if the part instance is suppressed.\n        partId (str): The identifier for the part.\n\n    Examples:\n        &gt;&gt;&gt; PartInstance(\n        ...     isStandardContent=False,\n        ...     type=InstanceType.PART,\n        ...     id=\"M0Cyvy+yIq8Rd7En0\",\n        ...     name=\"Part 1 &lt;2&gt;\",\n        ...     suppressed=False,\n        ...     partId=\"JHD\",\n        ... )\n        PartInstance(\n            isStandardContent=False,\n            type=InstanceType.PART,\n            id=\"M0Cyvy+yIq8Rd7En0\",\n            name=\"Part 1 &lt;2&gt;\",\n            suppressed=False,\n            partId=\"JHD\",\n        )\n    \"\"\"\n\n    isStandardContent: bool = Field(..., description=\"Indicates if the part is standard content.\")\n    type: InstanceType = Field(..., description=\"The type of the instance, must be 'Part'.\")\n    documentVersion: Union[str, None] = Field(None, description=\"The version of the document.\")\n    id: str = Field(..., description=\"The unique identifier for the part instance.\")\n    name: str = Field(..., description=\"The name of the part instance.\")\n    suppressed: bool = Field(..., description=\"Indicates if the part instance is suppressed.\")\n    partId: str = Field(..., description=\"The identifier for the part.\")\n\n    @field_validator(\"type\")\n    def check_type(cls, v: InstanceType) -&gt; InstanceType:\n        \"\"\"\n        Validates that the type is 'Part'.\n\n        Args:\n            v (InstanceType): The type to validate.\n\n        Returns:\n            InstanceType: The validated type.\n        \"\"\"\n        if v != InstanceType.PART:\n            raise ValueError(\"Type must be Part\")\n\n        return v\n\n    @property\n    def uid(self) -&gt; str:\n        \"\"\"\n        Generates a unique identifier for the part instance based on its attributes.\n\n        Returns:\n            str: The unique identifier for the part instance.\n        \"\"\"\n        return generate_uid([\n            self.documentId,\n            self.documentMicroversion,\n            self.elementId,\n            self.partId,\n            self.fullConfiguration,\n        ])\n</code></pre>"},{"location":"api/assembly/#onshape_robotics_toolkit.models.assembly.PartInstance.uid","title":"<code>uid</code>  <code>property</code>","text":"<p>Generates a unique identifier for the part instance based on its attributes.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The unique identifier for the part instance.</p>"},{"location":"api/assembly/#onshape_robotics_toolkit.models.assembly.PartInstance.check_type","title":"<code>check_type(v)</code>","text":"<p>Validates that the type is 'Part'.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>InstanceType</code> <p>The type to validate.</p> required <p>Returns:</p> Name Type Description <code>InstanceType</code> <code>InstanceType</code> <p>The validated type.</p> Source code in <code>onshape_robotics_toolkit/models/assembly.py</code> <pre><code>@field_validator(\"type\")\ndef check_type(cls, v: InstanceType) -&gt; InstanceType:\n    \"\"\"\n    Validates that the type is 'Part'.\n\n    Args:\n        v (InstanceType): The type to validate.\n\n    Returns:\n        InstanceType: The validated type.\n    \"\"\"\n    if v != InstanceType.PART:\n        raise ValueError(\"Type must be Part\")\n\n    return v\n</code></pre>"},{"location":"api/assembly/#onshape_robotics_toolkit.models.assembly.PartMateConnector","title":"<code>PartMateConnector</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a mate connector within a part.</p> JSON <pre><code>    {\n    \"mateConnectorCS\" : {\n        \"xAxis\" : [ 1.0, 0.0, 0.0 ],\n        \"yAxis\" : [ 0.0, 1.0, 0.0 ],\n        \"zAxis\" : [ 0.0, 0.0, 1.0 ],\n        \"origin\" : [ 0.0, 0.0, 0.024999999999999984 ]\n    },\n    \"featureId\" : \"FuB5m1oLMD3WyJ1_1\"\n    }\n</code></pre> <p>Attributes:</p> Name Type Description <code>mateConnectorCS</code> <code>MatedCS</code> <p>The coordinate system used for the mate connector.</p> <code>featureId</code> <code>str</code> <p>The unique identifier of the mate connector feature.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; PartMateConnector(\n...     mateConnectorCS=MatedCS(\n...         xAxis=[1.0, 0.0, 0.0],\n...         yAxis=[0.0, 1.0, 0.0],\n...         zAxis=[0.0, 0.0, 1.0],\n...         origin=[0.0, 0.0, 0.024999999999999984],\n...     ),\n...     featureId=\"FuB5m1oLMD3WyJ1_1\",\n... )\nPartMateConnector(\n    mateConnectorCS=MatedCS(\n        xAxis=[1.0, 0.0, 0.0],\n        yAxis=[0.0, 1.0, 0.0],\n        zAxis=[0.0, 0.0, 1.0],\n        origin=[0.0, 0.0, 0.024999999999999984]\n    ),\n    featureId=\"FuB5m1oLMD3WyJ1_1\"\n)\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/assembly.py</code> <pre><code>class PartMateConnector(BaseModel):\n    \"\"\"\n    Represents a mate connector within a part.\n\n    JSON:\n        ```json\n            {\n            \"mateConnectorCS\" : {\n                \"xAxis\" : [ 1.0, 0.0, 0.0 ],\n                \"yAxis\" : [ 0.0, 1.0, 0.0 ],\n                \"zAxis\" : [ 0.0, 0.0, 1.0 ],\n                \"origin\" : [ 0.0, 0.0, 0.024999999999999984 ]\n            },\n            \"featureId\" : \"FuB5m1oLMD3WyJ1_1\"\n            }\n        ```\n\n    Attributes:\n        mateConnectorCS (MatedCS): The coordinate system used for the mate connector.\n        featureId (str): The unique identifier of the mate connector feature.\n\n    Examples:\n        &gt;&gt;&gt; PartMateConnector(\n        ...     mateConnectorCS=MatedCS(\n        ...         xAxis=[1.0, 0.0, 0.0],\n        ...         yAxis=[0.0, 1.0, 0.0],\n        ...         zAxis=[0.0, 0.0, 1.0],\n        ...         origin=[0.0, 0.0, 0.024999999999999984],\n        ...     ),\n        ...     featureId=\"FuB5m1oLMD3WyJ1_1\",\n        ... )\n        PartMateConnector(\n            mateConnectorCS=MatedCS(\n                xAxis=[1.0, 0.0, 0.0],\n                yAxis=[0.0, 1.0, 0.0],\n                zAxis=[0.0, 0.0, 1.0],\n                origin=[0.0, 0.0, 0.024999999999999984]\n            ),\n            featureId=\"FuB5m1oLMD3WyJ1_1\"\n        )\n    \"\"\"\n\n    mateConnectorCS: \"MatedCS\" = Field(..., description=\"The coordinate system used for the mate connector.\")\n    featureId: str = Field(..., description=\"The unique identifier of the mate connector feature.\")\n</code></pre>"},{"location":"api/assembly/#onshape_robotics_toolkit.models.assembly.Pattern","title":"<code>Pattern</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a pattern feature within an assembly, defining repeated instances of parts or sub-assemblies.</p> JSON <pre><code>    {\n        \"seedToPatternInstances\" : {\n            \"MZAZxYCFuiiBSyUyF\" : [ \"Iska+TckyjXBC+1xA\", \"I1QmePT4s7IvbpMFC\" ]\n        },\n        \"name\" : \"Circular pattern 1\",\n        \"suppressed\" : false,\n        \"id\" : \"MVJMTPg/7tNhLqnTy\",\n        \"type\" : \"CIRCULAR\"\n    }\n</code></pre> <p>Attributes:     seedToPatternInstances (dict[str, list[str]]): A mapping of seed instance IDs to their         corresponding pattern instance IDs.     name (str): The name of the pattern feature.     suppressed (bool): Indicates if the pattern feature is suppressed.     id (str): The unique identifier of the pattern feature.     type (PatternType): The type of the pattern (e.g., CIRCULAR, LINEAR).</p> Source code in <code>onshape_robotics_toolkit/models/assembly.py</code> <pre><code>class Pattern(BaseModel):\n    \"\"\"\n    Represents a pattern feature within an assembly, defining repeated instances of parts or sub-assemblies.\n\n    JSON:\n        ```json\n            {\n                \"seedToPatternInstances\" : {\n                    \"MZAZxYCFuiiBSyUyF\" : [ \"Iska+TckyjXBC+1xA\", \"I1QmePT4s7IvbpMFC\" ]\n                },\n                \"name\" : \"Circular pattern 1\",\n                \"suppressed\" : false,\n                \"id\" : \"MVJMTPg/7tNhLqnTy\",\n                \"type\" : \"CIRCULAR\"\n            }\n        ```\n    Attributes:\n        seedToPatternInstances (dict[str, list[str]]): A mapping of seed instance IDs to their\n            corresponding pattern instance IDs.\n        name (str): The name of the pattern feature.\n        suppressed (bool): Indicates if the pattern feature is suppressed.\n        id (str): The unique identifier of the pattern feature.\n        type (PatternType): The type of the pattern (e.g., CIRCULAR, LINEAR).\n    \"\"\"\n\n    seedToPatternInstances: dict[Union[tuple[str, ...], str], Union[list[list[str]], list[str]]] = Field(\n        ..., description=\"A mapping of seed instance IDs to their corresponding pattern instance IDs.\"\n    )\n    name: str = Field(..., description=\"The name of the pattern feature.\")\n    suppressed: bool = Field(..., description=\"Indicates if the pattern feature is suppressed.\")\n    id: str = Field(..., description=\"The unique identifier of the pattern feature.\")\n    type: PatternType = Field(..., description=\"The type of the pattern (e.g., CIRCULAR, LINEAR).\")\n</code></pre>"},{"location":"api/assembly/#onshape_robotics_toolkit.models.assembly.RelationType","title":"<code>RelationType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enumerates the type of mate relation between two parts or assemblies, e.g. LINEAR, GEAR, SCREW, etc.</p> <p>Attributes:</p> Name Type Description <code>LINEAR</code> <code>str</code> <p>Represents a linear relation.</p> <code>GEAR</code> <code>str</code> <p>Represents a gear relation.</p> <code>SCREW</code> <code>str</code> <p>Represents a screw relation.</p> <code>RACK_AND_PINION</code> <code>str</code> <p>Represents a rack and pinion relation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; RelationType.LINEAR\n'LINEAR'\n&gt;&gt;&gt; RelationType.GEAR\n'GEAR'\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/assembly.py</code> <pre><code>class RelationType(str, Enum):\n    \"\"\"\n    Enumerates the type of mate relation between two parts or assemblies, e.g. LINEAR, GEAR, SCREW, etc.\n\n    Attributes:\n        LINEAR (str): Represents a linear relation.\n        GEAR (str): Represents a gear relation.\n        SCREW (str): Represents a screw relation.\n        RACK_AND_PINION (str): Represents a rack and pinion relation.\n\n    Examples:\n        &gt;&gt;&gt; RelationType.LINEAR\n        'LINEAR'\n        &gt;&gt;&gt; RelationType.GEAR\n        'GEAR'\n    \"\"\"\n\n    LINEAR = \"LINEAR\"\n    GEAR = \"GEAR\"\n    SCREW = \"SCREW\"\n    RACK_AND_PINION = \"RACK_AND_PINION\"\n</code></pre>"},{"location":"api/assembly/#onshape_robotics_toolkit.models.assembly.RootAssembly","title":"<code>RootAssembly</code>","text":"<p>               Bases: <code>SubAssembly</code></p> <p>Represents the root assembly, which is the top-level assembly containing all parts and sub-assemblies.</p> JSON <pre><code>    {\n        \"instances\": [],\n        \"patterns\": [],\n        \"features\": [],\n        \"occurrences\": [],\n        \"fullConfiguration\": \"default\",\n        \"configuration\": \"default\",\n        \"documentId\": \"a1c1addf75444f54b504f25c\",\n        \"elementId\": \"0b0c209535554345432581fe\",\n        \"documentMicroversion\": \"349f6413cafefe8fb4ab3b07\"\n    }\n</code></pre> <p>Attributes:</p> Name Type Description <code>instances</code> <code>list[Union[PartInstance, AssemblyInstance]]</code> <p>A list of part and assembly instances in the root assembly.</p> <code>patterns</code> <code>list[Pattern]</code> <p>A list of patterns in the root assembly.</p> <code>features</code> <code>list[AssemblyFeature]</code> <p>A list of features in the root assembly.</p> <code>occurrences</code> <code>list[Occurrence]</code> <p>A list of occurrences in the root assembly.</p> <code>fullConfiguration</code> <code>str</code> <p>The full configuration of the root assembly.</p> <code>configuration</code> <code>str</code> <p>The configuration of the root assembly.</p> <code>documentId</code> <code>str</code> <p>The unique identifier of the document containing the root assembly.</p> <code>elementId</code> <code>str</code> <p>The unique identifier of the element containing the root assembly.</p> <code>documentMicroversion</code> <code>str</code> <p>The microversion of the document containing the root assembly.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; RootAssembly(\n...     instances=[...],\n...     patterns=[...],\n...     features=[...],\n...     occurrences=[...],\n...     fullConfiguration=\"default\",\n...     configuration=\"default\",\n...     documentId=\"a1c1addf75444f54b504f25c\",\n...     elementId=\"0b0c209535554345432581fe\",\n...     documentMicroversion=\"349f6413cafefe8fb4ab3b07\",\n... )\nRootAssembly(\n    instances=[...],\n    patterns=[...],\n    features=[...],\n    occurrences=[...],\n    fullConfiguration=\"default\",\n    configuration=\"default\",\n    documentId=\"a1c1addf75444f54b504f25c\",\n    elementId=\"0b0c209535554345432581fe\",\n    documentMicroversion=\"349f6413cafefe8fb4ab3b07\"\n)\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/assembly.py</code> <pre><code>class RootAssembly(SubAssembly):\n    \"\"\"\n    Represents the root assembly, which is the top-level assembly containing all parts and sub-assemblies.\n\n    JSON:\n        ```json\n            {\n                \"instances\": [],\n                \"patterns\": [],\n                \"features\": [],\n                \"occurrences\": [],\n                \"fullConfiguration\": \"default\",\n                \"configuration\": \"default\",\n                \"documentId\": \"a1c1addf75444f54b504f25c\",\n                \"elementId\": \"0b0c209535554345432581fe\",\n                \"documentMicroversion\": \"349f6413cafefe8fb4ab3b07\"\n            }\n        ```\n\n    Attributes:\n        instances (list[Union[PartInstance, AssemblyInstance]]):\n            A list of part and assembly instances in the root assembly.\n        patterns (list[Pattern]): A list of patterns in the root assembly.\n        features (list[AssemblyFeature]): A list of features in the root assembly.\n        occurrences (list[Occurrence]): A list of occurrences in the root assembly.\n        fullConfiguration (str): The full configuration of the root assembly.\n        configuration (str): The configuration of the root assembly.\n        documentId (str): The unique identifier of the document containing the root assembly.\n        elementId (str): The unique identifier of the element containing the root assembly.\n        documentMicroversion (str): The microversion of the document containing the root assembly.\n\n    Examples:\n        &gt;&gt;&gt; RootAssembly(\n        ...     instances=[...],\n        ...     patterns=[...],\n        ...     features=[...],\n        ...     occurrences=[...],\n        ...     fullConfiguration=\"default\",\n        ...     configuration=\"default\",\n        ...     documentId=\"a1c1addf75444f54b504f25c\",\n        ...     elementId=\"0b0c209535554345432581fe\",\n        ...     documentMicroversion=\"349f6413cafefe8fb4ab3b07\",\n        ... )\n        RootAssembly(\n            instances=[...],\n            patterns=[...],\n            features=[...],\n            occurrences=[...],\n            fullConfiguration=\"default\",\n            configuration=\"default\",\n            documentId=\"a1c1addf75444f54b504f25c\",\n            elementId=\"0b0c209535554345432581fe\",\n            documentMicroversion=\"349f6413cafefe8fb4ab3b07\"\n        )\n    \"\"\"\n\n    occurrences: list[Occurrence] = Field(..., description=\"A list of occurrences in the root assembly.\")\n\n    documentMetaData: Union[DocumentMetaData, None] = Field(\n        None, description=\"The document associated with the assembly.\"\n    )\n</code></pre>"},{"location":"api/assembly/#onshape_robotics_toolkit.models.assembly.SubAssembly","title":"<code>SubAssembly</code>","text":"<p>               Bases: <code>IDBase</code></p> <p>Represents a sub-assembly within a root assembly.</p> JSON <pre><code>    {\n        \"instances\": [],\n        \"patterns\": [],\n        \"features\": [],\n        \"fullConfiguration\": \"default\",\n        \"configuration\": \"default\",\n        \"documentId\": \"a1c1addf75444f54b504f25c\",\n        \"elementId\": \"0b0c209535554345432581fe\",\n        \"documentMicroversion\": \"349f6413cafefe8fb4ab3b07\"\n    }\n</code></pre> <p>Attributes:</p> Name Type Description <code>instances</code> <code>list[Union[PartInstance, AssemblyInstance]]</code> <p>A list of part and assembly instances in the sub-assembly.</p> <code>patterns</code> <code>list[Pattern]</code> <p>A list of patterns in the sub-assembly.</p> <code>features</code> <code>list[AssemblyFeature]</code> <p>A list of features in the sub-assembly</p> <code>fullConfiguration</code> <code>str</code> <p>The full configuration of the sub-assembly.</p> <code>configuration</code> <code>str</code> <p>The configuration of the sub-assembly.</p> <code>documentId</code> <code>str</code> <p>The unique identifier of the document containing the sub-assembly.</p> <code>elementId</code> <code>str</code> <p>The unique identifier of the element containing the sub-assembly.</p> <code>documentMicroversion</code> <code>str</code> <p>The microversion of the document containing the sub-assembly.</p> Properties <p>uid (str): A unique identifier for the sub-assembly based on documentId, documentMicroversion, elementId, and     fullConfiguration.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; SubAssembly(\n...     instances=[...],\n...     patterns=[...],\n...     features=[...],\n...     fullConfiguration=\"default\",\n...     configuration=\"default\",\n...     documentId=\"a1c1addf75444f54b504f25c\",\n...     elementId=\"0b0c209535554345432581fe\",\n...     documentMicroversion=\"349f6413cafefe8fb4ab3b07\",\n... )\nSubAssembly(\n    instances=[...],\n    patterns=[...],\n    features=[...],\n    fullConfiguration=\"default\",\n    configuration=\"default\",\n    documentId=\"a1c1addf75444f54b504f25c\",\n    elementId=\"0b0c209535554345432581fe\",\n    documentMicroversion=\"349f6413cafefe8fb4ab3b07\"\n)\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/assembly.py</code> <pre><code>class SubAssembly(IDBase):\n    \"\"\"\n    Represents a sub-assembly within a root assembly.\n\n    JSON:\n        ```json\n            {\n                \"instances\": [],\n                \"patterns\": [],\n                \"features\": [],\n                \"fullConfiguration\": \"default\",\n                \"configuration\": \"default\",\n                \"documentId\": \"a1c1addf75444f54b504f25c\",\n                \"elementId\": \"0b0c209535554345432581fe\",\n                \"documentMicroversion\": \"349f6413cafefe8fb4ab3b07\"\n            }\n        ```\n\n    Attributes:\n        instances (list[Union[PartInstance, AssemblyInstance]]):\n            A list of part and assembly instances in the sub-assembly.\n        patterns (list[Pattern]): A list of patterns in the sub-assembly.\n        features (list[AssemblyFeature]): A list of features in the sub-assembly\n        fullConfiguration (str): The full configuration of the sub-assembly.\n        configuration (str): The configuration of the sub-assembly.\n        documentId (str): The unique identifier of the document containing the sub-assembly.\n        elementId (str): The unique identifier of the element containing the sub-assembly.\n        documentMicroversion (str): The microversion of the document containing the sub-assembly.\n\n    Properties:\n        uid (str): A unique identifier for the sub-assembly based on documentId, documentMicroversion, elementId, and\n            fullConfiguration.\n\n    Examples:\n        &gt;&gt;&gt; SubAssembly(\n        ...     instances=[...],\n        ...     patterns=[...],\n        ...     features=[...],\n        ...     fullConfiguration=\"default\",\n        ...     configuration=\"default\",\n        ...     documentId=\"a1c1addf75444f54b504f25c\",\n        ...     elementId=\"0b0c209535554345432581fe\",\n        ...     documentMicroversion=\"349f6413cafefe8fb4ab3b07\",\n        ... )\n        SubAssembly(\n            instances=[...],\n            patterns=[...],\n            features=[...],\n            fullConfiguration=\"default\",\n            configuration=\"default\",\n            documentId=\"a1c1addf75444f54b504f25c\",\n            elementId=\"0b0c209535554345432581fe\",\n            documentMicroversion=\"349f6413cafefe8fb4ab3b07\"\n        )\n\n    \"\"\"\n\n    instances: list[Union[PartInstance, AssemblyInstance]] = Field(\n        ..., description=\"A list of part and assembly instances in the sub-assembly.\"\n    )\n    patterns: list[Pattern] = Field(..., description=\"A list of patterns in the sub-assembly.\")\n    features: list[AssemblyFeature] = Field(..., description=\"A list of features in the sub-assembly\")\n\n    MassProperty: Union[MassProperties, None] = Field(\n        None, description=\"The mass properties of the sub-assembly, this is retrieved via a separate API call.\"\n    )\n\n    isRigid: bool = Field(False, description=\"Indicates if the sub-assembly is a rigid assembly\")\n\n    RootOccurrences: Union[dict[Any, Occurrence], None] = Field(\n        None, description=\"A list of occurrences from the subassembly frame, this is retrieved via a separate API call\"\n    )\n\n    @property\n    def uid(self) -&gt; str:\n        \"\"\"\n        Generates a unique identifier for the sub-assembly with documentId, documentMicroversion, elementId, and\n        fullConfiguration.\n\n        Returns:\n            str: The unique identifier for the sub-assembly.\n        \"\"\"\n        return generate_uid([self.documentId, self.documentMicroversion, self.elementId, self.fullConfiguration])\n</code></pre>"},{"location":"api/assembly/#onshape_robotics_toolkit.models.assembly.SubAssembly.uid","title":"<code>uid</code>  <code>property</code>","text":"<p>Generates a unique identifier for the sub-assembly with documentId, documentMicroversion, elementId, and fullConfiguration.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The unique identifier for the sub-assembly.</p>"},{"location":"api/connect/","title":"Connect","text":"<p>This module provides a client class and other utilities to interact with the Onshape API.</p> Class <ul> <li>Client: Provides access to the Onshape REST API.</li> <li>Part: Represents a part within an assembly, including its properties and configuration.</li> <li>PartInstance: Represents an instance of a part within an assembly.</li> </ul> Enum <ul> <li>HTTP: Enumerates the possible HTTP methods (GET, POST, DELETE).</li> </ul>"},{"location":"api/connect/#onshape_robotics_toolkit.connect.Asset","title":"<code>Asset</code>","text":"<p>Represents a set of parameters required to download a link from Onshape.</p> Source code in <code>onshape_robotics_toolkit/connect.py</code> <pre><code>class Asset:\n    \"\"\"\n    Represents a set of parameters required to download a link from Onshape.\n    \"\"\"\n\n    def __init__(\n        self,\n        file_name: str,\n        did: str = \"\",\n        wtype: str = \"\",\n        wid: str = \"\",\n        eid: str = \"\",\n        client: Optional[Client] = None,\n        transform: Optional[np.ndarray] = None,\n        is_rigid_assembly: bool = False,\n        partID: Optional[str] = None,\n        is_from_file: bool = False,\n        mesh_dir: Optional[str] = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the Asset object.\n\n        Args:\n            did: The unique identifier of the document.\n            wtype: The type of workspace.\n            wid: The unique identifier of the workspace.\n            eid: The unique identifier of the element.\n            client: Onshape API client object.\n            transform: Transformation matrix to apply to the mesh.\n            file_name: Name of the mesh file.\n            is_rigid_assembly: Whether the element is a rigid assembly.\n            partID: The unique identifier of the part.\n            is_from_file: Whether the asset is from a file.\n            mesh_dir: Optional custom directory for mesh files. If None, uses CURRENT_DIR/MESHES_DIR.\n        \"\"\"\n        self.did = did\n        self.wtype = wtype\n        self.wid = wid\n        self.eid = eid\n        self.client = client\n        self.transform = transform\n        self.file_name = file_name\n        self.is_rigid_assembly = is_rigid_assembly\n        self.partID = partID\n        self.is_from_file = is_from_file\n        self.mesh_dir = mesh_dir\n        self.robot_file_dir: Optional[str] = None  # Directory where robot file is saved, for relative path calculation\n\n        self._file_path: Optional[str] = None\n\n    @property\n    def absolute_path(self) -&gt; str:\n        \"\"\"\n        Returns the file path of the mesh file.\n\n        Returns:\n            The file path of the mesh file.\n        \"\"\"\n        if self.is_from_file:\n            if self._file_path is None:\n                raise ValueError(\"File path is not set for file-based asset\")\n            return self._file_path\n\n        # Determine the mesh directory to use (custom or default for backwards compatibility)\n        mesh_directory = self.mesh_dir if self.mesh_dir is not None else os.path.join(CURRENT_DIR, MESHES_DIR)\n\n        # Create the directory if it doesn't exist\n        if not os.path.exists(mesh_directory):\n            os.makedirs(mesh_directory)\n\n        return os.path.join(mesh_directory, self.file_name)\n\n    @property\n    def relative_path(self) -&gt; str:\n        \"\"\"\n        Returns the relative path of the mesh file.\n\n        Returns:\n            The relative path of the mesh file with forward slashes (cross-platform compatible).\n        \"\"\"\n        # Calculate relative path from robot file directory if specified, otherwise from CURRENT_DIR\n        base_dir = self.robot_file_dir if self.robot_file_dir is not None else CURRENT_DIR\n\n        # Use forward slashes for cross-platform compatibility in URDF/MJCF files\n        rel_path = os.path.relpath(self.absolute_path, base_dir)\n        return rel_path.replace(os.sep, \"/\")\n\n    async def download(self) -&gt; None:\n        \"\"\"\n        Asynchronously download the mesh file from Onshape, transform it, and save it to a file.\n\n        Examples:\n            &gt;&gt;&gt; asset = Asset(\n            ...     did=\"a1c1addf75444f54b504f25c\",\n            ...     wtype=\"w\",\n            ...     wid=\"0d17b8ebb2a4c76be9fff3c7\",\n            ...     eid=\"a86aaf34d2f4353288df8812\",\n            ...     client=client,\n            ...     transform=np.eye(4),\n            ...     file_name=\"mesh.stl\",\n            ...     is_rigid_assembly=True\n            ... )\n            &gt;&gt;&gt; await asset.download()\n        \"\"\"\n        logger.info(f\"Downloading {self.file_name}\")\n        if self.client is None:\n            raise ValueError(\"Client is required for downloading meshes\")\n        try:\n            with io.BytesIO() as buffer:\n                if not self.is_rigid_assembly:\n                    if self.partID is None:\n                        raise ValueError(\"Part ID is required for downloading part STL\")  # noqa: TRY301\n                    await asyncio.to_thread(\n                        self.client.download_part_stl,\n                        did=self.did,\n                        wtype=self.wtype,\n                        wid=self.wid,\n                        eid=self.eid,\n                        partID=self.partID,\n                        buffer=buffer,\n                    )\n                else:\n                    await asyncio.to_thread(\n                        self.client.download_assembly_stl,\n                        did=self.did,\n                        wtype=self.wtype,\n                        wid=self.wid,\n                        eid=self.eid,\n                        buffer=buffer,\n                    )\n\n                buffer.seek(0)\n\n                raw_mesh = stl.mesh.Mesh.from_file(None, fh=buffer)\n                transformed_mesh = transform_mesh(raw_mesh, self.transform) if self.transform is not None else raw_mesh\n                transformed_mesh.save(self.absolute_path)\n\n                logger.debug(f\"Mesh file saved: {self.absolute_path}\")\n        except Exception as e:\n            logger.error(f\"Failed to download {self.file_name}: {e}\")\n\n    def to_mjcf(self, root: Any) -&gt; None:\n        \"\"\"\n        Returns the XML representation of the asset, which is a mesh file.\n\n        Args:\n            root: The root element of the XML tree.\n\n        Examples:\n            &gt;&gt;&gt; asset = Asset(\n            ...     did=\"a1c1addf75444f54b504f25c\",\n            ...     wtype=\"w\",\n            ...     wid=\"0d17b8ebb2a4c76be9fff3c7\",\n            ...     eid=\"a86aaf34d2f4353288df8812\",\n            ...     client=client,\n            ...     transform=np.eye(4),\n            ...     file_name=\"mesh.stl\",\n            ...     is_rigid_assembly=True\n            ... )\n            &gt;&gt;&gt; asset.to_mjcf()\n            &lt;mesh name=\"Part-1-1\" file=\"Part-1-1.stl\" /&gt;\n        \"\"\"\n        asset = ET.Element(\"mesh\") if root is None else ET.SubElement(root, \"mesh\")\n        asset.set(\"name\", self.file_name.split(\".\")[0])\n        asset.set(\"file\", self.relative_path)\n\n    @classmethod\n    def from_file(cls, file_path: str) -&gt; \"Asset\":\n        \"\"\"\n        Create an Asset object from a mesh file.\n\n        Args:\n            file_path: Path to the mesh file.\n\n        Returns:\n            Asset: Asset object representing the mesh file.\n\n        Examples:\n            &gt;&gt;&gt; asset = Asset.from_file(\"mesh.stl\", client)\n        \"\"\"\n        file_name = os.path.basename(file_path)\n        asset = cls(\n            file_name=file_name.split(\".\")[0],\n            is_from_file=True,\n        )\n\n        asset._file_path = file_path\n        return asset\n</code></pre>"},{"location":"api/connect/#onshape_robotics_toolkit.connect.Asset.absolute_path","title":"<code>absolute_path</code>  <code>property</code>","text":"<p>Returns the file path of the mesh file.</p> <p>Returns:</p> Type Description <code>str</code> <p>The file path of the mesh file.</p>"},{"location":"api/connect/#onshape_robotics_toolkit.connect.Asset.relative_path","title":"<code>relative_path</code>  <code>property</code>","text":"<p>Returns the relative path of the mesh file.</p> <p>Returns:</p> Type Description <code>str</code> <p>The relative path of the mesh file with forward slashes (cross-platform compatible).</p>"},{"location":"api/connect/#onshape_robotics_toolkit.connect.Asset.__init__","title":"<code>__init__(file_name, did='', wtype='', wid='', eid='', client=None, transform=None, is_rigid_assembly=False, partID=None, is_from_file=False, mesh_dir=None)</code>","text":"<p>Initialize the Asset object.</p> <p>Parameters:</p> Name Type Description Default <code>did</code> <code>str</code> <p>The unique identifier of the document.</p> <code>''</code> <code>wtype</code> <code>str</code> <p>The type of workspace.</p> <code>''</code> <code>wid</code> <code>str</code> <p>The unique identifier of the workspace.</p> <code>''</code> <code>eid</code> <code>str</code> <p>The unique identifier of the element.</p> <code>''</code> <code>client</code> <code>Optional[Client]</code> <p>Onshape API client object.</p> <code>None</code> <code>transform</code> <code>Optional[ndarray]</code> <p>Transformation matrix to apply to the mesh.</p> <code>None</code> <code>file_name</code> <code>str</code> <p>Name of the mesh file.</p> required <code>is_rigid_assembly</code> <code>bool</code> <p>Whether the element is a rigid assembly.</p> <code>False</code> <code>partID</code> <code>Optional[str]</code> <p>The unique identifier of the part.</p> <code>None</code> <code>is_from_file</code> <code>bool</code> <p>Whether the asset is from a file.</p> <code>False</code> <code>mesh_dir</code> <code>Optional[str]</code> <p>Optional custom directory for mesh files. If None, uses CURRENT_DIR/MESHES_DIR.</p> <code>None</code> Source code in <code>onshape_robotics_toolkit/connect.py</code> <pre><code>def __init__(\n    self,\n    file_name: str,\n    did: str = \"\",\n    wtype: str = \"\",\n    wid: str = \"\",\n    eid: str = \"\",\n    client: Optional[Client] = None,\n    transform: Optional[np.ndarray] = None,\n    is_rigid_assembly: bool = False,\n    partID: Optional[str] = None,\n    is_from_file: bool = False,\n    mesh_dir: Optional[str] = None,\n) -&gt; None:\n    \"\"\"\n    Initialize the Asset object.\n\n    Args:\n        did: The unique identifier of the document.\n        wtype: The type of workspace.\n        wid: The unique identifier of the workspace.\n        eid: The unique identifier of the element.\n        client: Onshape API client object.\n        transform: Transformation matrix to apply to the mesh.\n        file_name: Name of the mesh file.\n        is_rigid_assembly: Whether the element is a rigid assembly.\n        partID: The unique identifier of the part.\n        is_from_file: Whether the asset is from a file.\n        mesh_dir: Optional custom directory for mesh files. If None, uses CURRENT_DIR/MESHES_DIR.\n    \"\"\"\n    self.did = did\n    self.wtype = wtype\n    self.wid = wid\n    self.eid = eid\n    self.client = client\n    self.transform = transform\n    self.file_name = file_name\n    self.is_rigid_assembly = is_rigid_assembly\n    self.partID = partID\n    self.is_from_file = is_from_file\n    self.mesh_dir = mesh_dir\n    self.robot_file_dir: Optional[str] = None  # Directory where robot file is saved, for relative path calculation\n\n    self._file_path: Optional[str] = None\n</code></pre>"},{"location":"api/connect/#onshape_robotics_toolkit.connect.Asset.download","title":"<code>download()</code>  <code>async</code>","text":"<p>Asynchronously download the mesh file from Onshape, transform it, and save it to a file.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; asset = Asset(\n...     did=\"a1c1addf75444f54b504f25c\",\n...     wtype=\"w\",\n...     wid=\"0d17b8ebb2a4c76be9fff3c7\",\n...     eid=\"a86aaf34d2f4353288df8812\",\n...     client=client,\n...     transform=np.eye(4),\n...     file_name=\"mesh.stl\",\n...     is_rigid_assembly=True\n... )\n&gt;&gt;&gt; await asset.download()\n</code></pre> Source code in <code>onshape_robotics_toolkit/connect.py</code> <pre><code>async def download(self) -&gt; None:\n    \"\"\"\n    Asynchronously download the mesh file from Onshape, transform it, and save it to a file.\n\n    Examples:\n        &gt;&gt;&gt; asset = Asset(\n        ...     did=\"a1c1addf75444f54b504f25c\",\n        ...     wtype=\"w\",\n        ...     wid=\"0d17b8ebb2a4c76be9fff3c7\",\n        ...     eid=\"a86aaf34d2f4353288df8812\",\n        ...     client=client,\n        ...     transform=np.eye(4),\n        ...     file_name=\"mesh.stl\",\n        ...     is_rigid_assembly=True\n        ... )\n        &gt;&gt;&gt; await asset.download()\n    \"\"\"\n    logger.info(f\"Downloading {self.file_name}\")\n    if self.client is None:\n        raise ValueError(\"Client is required for downloading meshes\")\n    try:\n        with io.BytesIO() as buffer:\n            if not self.is_rigid_assembly:\n                if self.partID is None:\n                    raise ValueError(\"Part ID is required for downloading part STL\")  # noqa: TRY301\n                await asyncio.to_thread(\n                    self.client.download_part_stl,\n                    did=self.did,\n                    wtype=self.wtype,\n                    wid=self.wid,\n                    eid=self.eid,\n                    partID=self.partID,\n                    buffer=buffer,\n                )\n            else:\n                await asyncio.to_thread(\n                    self.client.download_assembly_stl,\n                    did=self.did,\n                    wtype=self.wtype,\n                    wid=self.wid,\n                    eid=self.eid,\n                    buffer=buffer,\n                )\n\n            buffer.seek(0)\n\n            raw_mesh = stl.mesh.Mesh.from_file(None, fh=buffer)\n            transformed_mesh = transform_mesh(raw_mesh, self.transform) if self.transform is not None else raw_mesh\n            transformed_mesh.save(self.absolute_path)\n\n            logger.debug(f\"Mesh file saved: {self.absolute_path}\")\n    except Exception as e:\n        logger.error(f\"Failed to download {self.file_name}: {e}\")\n</code></pre>"},{"location":"api/connect/#onshape_robotics_toolkit.connect.Asset.from_file","title":"<code>from_file(file_path)</code>  <code>classmethod</code>","text":"<p>Create an Asset object from a mesh file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to the mesh file.</p> required <p>Returns:</p> Name Type Description <code>Asset</code> <code>Asset</code> <p>Asset object representing the mesh file.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; asset = Asset.from_file(\"mesh.stl\", client)\n</code></pre> Source code in <code>onshape_robotics_toolkit/connect.py</code> <pre><code>@classmethod\ndef from_file(cls, file_path: str) -&gt; \"Asset\":\n    \"\"\"\n    Create an Asset object from a mesh file.\n\n    Args:\n        file_path: Path to the mesh file.\n\n    Returns:\n        Asset: Asset object representing the mesh file.\n\n    Examples:\n        &gt;&gt;&gt; asset = Asset.from_file(\"mesh.stl\", client)\n    \"\"\"\n    file_name = os.path.basename(file_path)\n    asset = cls(\n        file_name=file_name.split(\".\")[0],\n        is_from_file=True,\n    )\n\n    asset._file_path = file_path\n    return asset\n</code></pre>"},{"location":"api/connect/#onshape_robotics_toolkit.connect.Asset.to_mjcf","title":"<code>to_mjcf(root)</code>","text":"<p>Returns the XML representation of the asset, which is a mesh file.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>Any</code> <p>The root element of the XML tree.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; asset = Asset(\n...     did=\"a1c1addf75444f54b504f25c\",\n...     wtype=\"w\",\n...     wid=\"0d17b8ebb2a4c76be9fff3c7\",\n...     eid=\"a86aaf34d2f4353288df8812\",\n...     client=client,\n...     transform=np.eye(4),\n...     file_name=\"mesh.stl\",\n...     is_rigid_assembly=True\n... )\n&gt;&gt;&gt; asset.to_mjcf()\n&lt;mesh name=\"Part-1-1\" file=\"Part-1-1.stl\" /&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/connect.py</code> <pre><code>def to_mjcf(self, root: Any) -&gt; None:\n    \"\"\"\n    Returns the XML representation of the asset, which is a mesh file.\n\n    Args:\n        root: The root element of the XML tree.\n\n    Examples:\n        &gt;&gt;&gt; asset = Asset(\n        ...     did=\"a1c1addf75444f54b504f25c\",\n        ...     wtype=\"w\",\n        ...     wid=\"0d17b8ebb2a4c76be9fff3c7\",\n        ...     eid=\"a86aaf34d2f4353288df8812\",\n        ...     client=client,\n        ...     transform=np.eye(4),\n        ...     file_name=\"mesh.stl\",\n        ...     is_rigid_assembly=True\n        ... )\n        &gt;&gt;&gt; asset.to_mjcf()\n        &lt;mesh name=\"Part-1-1\" file=\"Part-1-1.stl\" /&gt;\n    \"\"\"\n    asset = ET.Element(\"mesh\") if root is None else ET.SubElement(root, \"mesh\")\n    asset.set(\"name\", self.file_name.split(\".\")[0])\n    asset.set(\"file\", self.relative_path)\n</code></pre>"},{"location":"api/connect/#onshape_robotics_toolkit.connect.Client","title":"<code>Client</code>","text":"<p>Represents a client for the Onshape REST API with methods to interact with the API.</p> <p>Parameters:</p> Name Type Description Default <code>env</code> <code>str, default='./.env'</code> <p>Path to the environment file containing the access and secret keys</p> <code>None</code> <code>base_url</code> <code>str, default='https</code> <p>//cad.onshape.com'): Base URL for the Onshape API</p> <code>BASE_URL</code> <p>Attributes:</p> Name Type Description <code>api_call_count</code> <code>int</code> <p>Number of successful API calls made (read-only property)</p> <p>Methods:</p> Name Description <code>get_document_metadata</code> <p>Get details for a specified document.</p> <code>get_elements</code> <p>Get list of elements in a document.</p> <code>get_variables</code> <p>Get list of variables in a variable studio.</p> <code>set_variables</code> <p>Set variables in a variable studio.</p> <code>get_assembly</code> <p>Get assembly data for a specified document / workspace / assembly.</p> <code>download_part_stl</code> <p>Download an STL file from a part studio.</p> <code>get_mass_property</code> <p>Get mass properties for a part in a part studio.</p> <code>request</code> <p>Issue a request to the Onshape API.</p> <code>reset_api_call_count</code> <p>Reset the API call counter to zero.</p> Note <p>The client automatically tracks API calls and logs a summary when the program exits (using atexit). This works reliably even when scripts crash or encounter network errors.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; client = Client(\n...     env=\".env\",\n... )\n&gt;&gt;&gt; document_meta_data = client.get_document_metadata(\"document_id\")\n&gt;&gt;&gt; print(f\"API calls made: {client.api_call_count}\")\nAPI calls made: 1\n</code></pre> Source code in <code>onshape_robotics_toolkit/connect.py</code> <pre><code>class Client:\n    \"\"\"\n    Represents a client for the Onshape REST API with methods to interact with the API.\n\n    Args:\n        env (str, default='./.env'): Path to the environment file containing the access and secret keys\n        base_url (str, default='https://cad.onshape.com'): Base URL for the Onshape API\n\n    Attributes:\n        api_call_count (int): Number of successful API calls made (read-only property)\n\n    Methods:\n        get_document_metadata: Get details for a specified document.\n        get_elements: Get list of elements in a document.\n        get_variables: Get list of variables in a variable studio.\n        set_variables: Set variables in a variable studio.\n        get_assembly: Get assembly data for a specified document / workspace / assembly.\n        download_part_stl: Download an STL file from a part studio.\n        get_mass_property: Get mass properties for a part in a part studio.\n        request: Issue a request to the Onshape API.\n        reset_api_call_count: Reset the API call counter to zero.\n\n    Note:\n        The client automatically tracks API calls and logs a summary when the program\n        exits (using atexit). This works reliably even when scripts crash or encounter\n        network errors.\n\n    Examples:\n        &gt;&gt;&gt; client = Client(\n        ...     env=\".env\",\n        ... )\n        &gt;&gt;&gt; document_meta_data = client.get_document_metadata(\"document_id\")\n        &gt;&gt;&gt; print(f\"API calls made: {client.api_call_count}\")\n        API calls made: 1\n    \"\"\"\n\n    def __init__(self, env: Union[str, None] = None, base_url: str = BASE_URL):\n        \"\"\"\n        Initialize the Onshape API client.\n\n        Args:\n            env: Path to the environment file containing the access and secret keys\n            base_url: Base URL for the Onshape API\n\n        Examples:\n            &gt;&gt;&gt; client = Client(\n            ...     env=\".env\",\n            ... )\n        \"\"\"\n\n        self._url = base_url\n        self._access_key, self._secret_key = load_env_variables(env)\n        self._api_call_count = 0\n        logger.info(f\"Onshape API initialized with env file: {env}\")\n        record_client_config(env=env, base_url=base_url)\n\n        # Register cleanup function to log API usage on exit\n        atexit.register(self._log_final_api_count)\n\n    def _log_final_api_count(self) -&gt; None:\n        \"\"\"\n        Log the final API call count when the program exits.\n\n        This method is registered with atexit and will be called on normal program\n        termination. It provides visibility into API usage even when scripts error\n        out or network issues cause early termination.\n        \"\"\"\n        if self._api_call_count &gt; 0:\n            logger.info(f\"Client session ended \u2192 Total API calls made: {self._api_call_count}\")\n\n    def set_base_url(self, base_url: str) -&gt; None:\n        \"\"\"\n        Set the base URL for the Onshape API.\n\n        Args:\n            base_url: Base URL for the Onshape API\n\n        Examples:\n            &gt;&gt;&gt; client.set_base_url(\"https://cad.onshape.com\")\n        \"\"\"\n        self._url = base_url\n\n    @property\n    def api_call_count(self) -&gt; int:\n        \"\"\"\n        Get the current API call count.\n\n        Returns:\n            The number of successful API calls made by this client\n\n        Examples:\n            &gt;&gt;&gt; client.api_call_count\n            42\n        \"\"\"\n        return self._api_call_count\n\n    def reset_api_call_count(self) -&gt; None:\n        \"\"\"\n        Reset the API call counter to zero.\n\n        Examples:\n            &gt;&gt;&gt; client.reset_api_call_count()\n            &gt;&gt;&gt; client.api_call_count\n            0\n        \"\"\"\n        self._api_call_count = 0\n        logger.info(\"API call counter reset to 0\")\n\n    def get_document_metadata(self, did: str) -&gt; DocumentMetaData:\n        \"\"\"\n        Get meta data for a specified document.\n\n        Args:\n            did: The unique identifier of the document.\n\n        Returns:\n            Meta data for the specified document as a DocumentMetaData object or None if the document is not found\n\n        Examples:\n            &gt;&gt;&gt; document_meta_data = client.get_document_metadata(\"document_id\n            &gt;&gt;&gt; print(document_meta_data)\n            DocumentMetaData(\n                defaultWorkspace=DefaultWorkspace(id=\"739221fb10c88c2bebb456e8\", type=\"workspace\"),\n                name=\"Document Name\",\n                id=\"a1c1addf75444f54b504f25c\"\n            )\n        \"\"\"\n        if len(did) != 24:\n            raise ValueError(f\"Invalid document ID: {did}\")\n\n        res = self.request(HTTP.GET, \"/api/documents/\" + did)\n\n        if res.status_code == 404:\n            raise ValueError(f\"Document does not exist: {did}\")\n        elif res.status_code == 403:\n            raise ValueError(f\"Access forbidden for document: {did}\")\n\n        document = DocumentMetaData.model_validate(res.json())\n        document.name = get_sanitized_name(document.name)\n\n        return document\n\n    def get_elements(self, did: str, wtype: str, wid: str) -&gt; dict[str, Element]:\n        \"\"\"\n        Get a list of all elements in a document.\n\n        Args:\n            did: The unique identifier of the document.\n            wtype: The type of workspace.\n            wid: The unique identifier of the workspace.\n\n        Returns:\n            A dictionary of element name and Element object pairs.\n\n        Examples:\n            &gt;&gt;&gt; elements = client.get_elements(\n            ...     did=\"a1c1addf75444f54b504f25c\",\n            ...     wtype=\"w\",\n            ...     wid=\"0d17b8ebb2a4c76be9fff3c7\"\n            ... )\n            &gt;&gt;&gt; print(elements)\n            {\n                \"wheelAndFork\": Element(id='0b0c209535554345432581fe', name='wheelAndFork', elementType='PARTSTUDIO',\n                                         microversionId='9b3be6165c7a2b1f6dd61305'),\n                \"frame\": Element(id='0b0c209535554345432581fe', name='frame', elementType='PARTSTUDIO',\n                                 microversionId='9b3be6165c7a2b1f6dd61305')\n            }\n        \"\"\"\n\n        # /documents/d/{did}/{wvm}/{wvmid}/elements\n        request_path = \"/api/documents/d/\" + did + \"/\" + wtype + \"/\" + wid + \"/elements\"\n        response = self.request(\n            HTTP.GET,\n            request_path,\n        )\n\n        if response.status_code == 404:\n            logger.error(f\"Elements not found for document: {did}\")\n            return {}\n\n        elif response.status_code == 403:\n            logger.error(f\"Access forbidden for document: {did}\")\n            return {}\n\n        return {element[\"name\"]: Element.model_validate(element) for element in response.json()}\n\n    def get_variables(self, did: str, wid: str, eid: str) -&gt; dict[str, Variable]:\n        \"\"\"\n        Get a list of variables in a variable studio within a document.\n\n        Args:\n            did: The unique identifier of the document.\n            wid: The unique identifier of the workspace.\n            eid: The unique identifier of the variable studio.\n\n        Returns:\n            A dictionary of variable name and Variable object pairs.\n\n        Examples:\n            &gt;&gt;&gt; variables = client.get_variables(\n            ...     did=\"a1c1addf75444f54b504f25c\",\n            ...     wid=\"0d17b8ebb2a4c76be9fff3c7\",\n            ...     eid=\"cba5e3ca026547f34f8d9f0f\"\n            ... )\n            &gt;&gt;&gt; print(variables)\n            {\n                \"forkAngle\": Variable(\n                    type='ANGLE',\n                    name='forkAngle',\n                    value=None,\n                    description='Fork angle for front wheel assembly in deg',\n                    expression='15 deg'\n                )\n            }\n        \"\"\"\n        request_path = \"/api/variables/d/\" + did + \"/w/\" + wid + \"/e/\" + eid + \"/variables\"\n\n        _variables_json = self.request(\n            HTTP.GET,\n            request_path,\n        ).json()\n\n        return {variable[\"name\"]: Variable.model_validate(variable) for variable in _variables_json[0][\"variables\"]}\n\n    def set_variables(self, did: str, wid: str, eid: str, variables: dict[str, str]) -&gt; requests.Response:\n        \"\"\"\n        Set values for variables of a variable studio in a document.\n\n        Args:\n            did: The unique identifier of the document.\n            wid: The unique identifier of the workspace.\n            eid: The unique identifier of the variable studio.\n            variables: A dictionary of variable name and expression pairs.\n\n        Returns:\n            requests.Response: Response from Onshape API after setting the variables.\n\n        Examples:\n            &gt;&gt;&gt; variables = {\n            ...     \"forkAngle\": \"15 deg\",\n            ...     \"wheelRadius\": \"0.5 m\"\n            ... }\n            &gt;&gt;&gt; client.set_variables(\n            ...     did=\"a1c1addf75444f54b504f25c\",\n            ...     wid=\"0d17b8ebb2a4c76be9fff3c7\",\n            ...     eid=\"cba5e3ca026547f34f8d9f0f\",\n            ...     variables=variables\n            ... )\n            &lt;Response [200]&gt;\n        \"\"\"\n\n        payload = [{\"name\": name, \"expression\": expression} for name, expression in variables.items()]\n\n        # api/v9/variables/d/a1c1addf75444f54b504f25c/w/0d17b8ebb2a4c76be9fff3c7/e/cba5e3ca026547f34f8d9f0f/variables\n        request_path = \"/api/variables/d/\" + did + \"/w/\" + wid + \"/e/\" + eid + \"/variables\"\n\n        response = self.request(\n            HTTP.POST,\n            request_path,\n            body=payload,\n        )\n\n        record_variable_update(element_id=eid, expressions=variables)\n\n        return response\n\n    def get_features(\n        self,\n        did: str,\n        wtype: str,\n        wid: str,\n        eid: str,\n    ) -&gt; Features:\n        \"\"\"\n        Get all assembly features\n\n        Args:\n            did: The unique identifier of the document.\n            wtype: The type of workspace.\n            wid: The unique identifier of the workspace.\n            eid: The unique identifier of the assembly.\n        \"\"\"\n        request_path = f\"/api/assemblies/d/{did}/{wtype}/{wid}/e/{eid}/features\"\n        response_json = self.request(HTTP.GET, request_path, log_response=True).json()\n        return Features.model_validate(response_json)\n\n    def get_assembly_name(\n        self,\n        did: str,\n        wtype: str,\n        wid: str,\n        eid: str,\n        configuration: str = \"default\",\n    ) -&gt; Optional[str]:\n        \"\"\"\n        Get assembly name for a specified document / workspace / assembly.\n\n        Args:\n            did: The unique identifier of the document.\n            wtype: The type of workspace.\n            wid: The unique identifier of the workspace.\n            eid: The unique identifier of the assembly.\n            configuration: The configuration of the assembly.\n\n        Returns:\n            str: Assembly name\n\n        Examples:\n            &gt;&gt;&gt; assembly_name = client.get_assembly_name(\n            ...     did=\"a1c1addf75444f54b504f25c\",\n            ...     wtype=\"w\",\n            ...     wid=\"0d17b8ebb2a4c76be9fff3c7\",\n            ...     eid=\"a86aaf34d2f4353288df8812\"\n            ... )\n            &gt;&gt;&gt; print(assembly_name)\n            \"Assembly Name\"\n        \"\"\"\n        request_path = \"/api/metadata/d/\" + did + \"/\" + wtype + \"/\" + wid + \"/e/\" + eid\n        result_json = self.request(\n            HTTP.GET,\n            request_path,\n            query={\n                \"inferMetadataOwner\": \"false\",\n                \"includeComputedProperties\": \"false\",\n                \"includeComputedAssemblyProperties\": \"false\",\n                \"thumbnail\": \"false\",\n                \"configuration\": configuration,\n            },\n            log_response=False,\n        ).json()\n\n        name = None\n        try:\n            name = result_json[\"properties\"][0][\"value\"]\n            name = get_sanitized_name(name)\n\n        except KeyError:\n            logger.warning(f\"Assembly name not found for document: {did}\")\n\n        return name\n\n    def get_root_assembly(\n        self,\n        did: str,\n        wtype: str,\n        wid: str,\n        eid: str,\n        configuration: str = \"default\",\n        with_mass_properties: bool = False,\n        log_response: bool = True,\n        with_meta_data: bool = True,\n    ) -&gt; RootAssembly:\n        \"\"\"\n        Get root assembly data for a specified document / workspace / element.\n\n        Args:\n            did: The unique identifier of the document.\n            wtype: The type of workspace.\n            wid: The unique identifier of the workspace.\n            eid: The unique identifier of the element.\n            configuration: The configuration of the assembly.\n            with_mass_properties: Whether to include mass properties in the assembly data.\n            log_response: Log the response from the API request.\n            with_meta_data: Whether to include meta data in the assembly data.\n\n        Returns:\n            RootAssembly: RootAssembly object containing the root assembly data\n\n        Examples:\n            &gt;&gt;&gt; root_assembly = client.get_root_assembly(\n            ...     did=\"a1c1addf75444f54b504f25c\",\n            ...     wtype=\"w\",\n            ...     wid=\"0d17b8ebb2a4c76be9fff3c7\",\n            ...     eid=\"a86aaf34d2f4353288df8812\",\n            ...     configuration=\"default\",\n            ...     with_mass_properties=True,\n            ...     log_response=False,\n            ...     with_meta_data=True\n            ... )\n            &gt;&gt;&gt; print(root_assembly)\n            RootAssembly(\n                instances=[...],\n                patterns=[...],\n                features=[...],\n                occurrences=[...],\n                fullConfiguration=\"default\",\n                configuration=\"default\",\n                documentId=\"a1c1addf75444f54b504f25c\",\n                elementId=\"0b0c209535554345432581fe\",\n                documentMicroversion=\"349f6413cafefe8fb4ab3b07\",\n            )\n        \"\"\"\n        request_path = \"/api/assemblies/d/\" + did + \"/\" + wtype + \"/\" + wid + \"/e/\" + eid\n        res = self.request(\n            HTTP.GET,\n            request_path,\n            query={\n                \"includeMateFeatures\": \"true\",\n                \"includeMateConnectors\": \"true\",\n                \"includeNonSolids\": \"false\",\n                \"configuration\": configuration,\n            },\n            log_response=log_response,\n        )\n\n        if res.status_code == 401:\n            logger.warning(f\"Unauthorized access to document: {did}\")\n            logger.warning(\"Please check the API keys in your env file.\")\n            exit(1)\n\n        if res.status_code == 404:\n            logger.error(f\"Assembly not found: {did}\")\n            logger.error(\n                generate_url(\n                    base_url=self._url,\n                    did=did,\n                    wtype=wtype,\n                    wid=wid,\n                    eid=eid,\n                )\n            )\n            exit(1)\n\n        assembly_json = res.json()\n        assembly = RootAssembly.model_validate(assembly_json[\"rootAssembly\"])\n\n        if with_mass_properties:\n            assembly.MassProperty = self.get_assembly_mass_properties(\n                did=did,\n                wid=wid,\n                eid=eid,\n                wtype=wtype,\n            )\n\n        if with_meta_data:\n            assembly.documentMetaData = self.get_document_metadata(did)\n\n        return assembly\n\n    def get_assembly(\n        self,\n        did: str,\n        wtype: str,\n        wid: str,\n        eid: str,\n        configuration: str = \"default\",\n        log_response: bool = True,\n        with_meta_data: bool = True,\n    ) -&gt; Assembly:\n        \"\"\"\n        Get assembly data for a specified document / workspace / assembly.\n\n        Args:\n            did: The unique identifier of the document.\n            wtype: The type of workspace.\n            wid: The unique identifier of the workspace.\n            eid: The unique identifier of the assembly.\n            configuration: The configuration of the assembly.\n            log_response: Log the response from the API request.\n            with_meta_data: Include meta data in the assembly data.\n\n        Returns:\n            Assembly: Assembly object containing the assembly data\n\n        Examples:\n            &gt;&gt;&gt; assembly = client.get_assembly(\n            ...     did=\"a1c1addf75444f54b504f25c\",\n            ...     wtype=\"w\",\n            ...     wid=\"0d17b8ebb2a4c76be9fff3c7\",\n            ...     eid=\"a86aaf34d2f4353288df8812\"\n            ... )\n            &gt;&gt;&gt; print(assembly)\n            Assembly(\n                rootAssembly=RootAssembly(\n                    instances=[...],\n                    patterns=[...],\n                    features=[...],\n                    occurrences=[...],\n                    fullConfiguration=\"default\",\n                    configuration=\"default\",\n                    documentId=\"a1c1addf75444f54b504f25c\",\n                    elementId=\"0b0c209535554345432581fe\",\n                    documentMicroversion=\"349f6413cafefe8fb4ab3b07\",\n                ),\n                subAssemblies=[...],\n                parts=[...],\n                partStudioFeatures=[...],\n                document=Document(\n                    url=\"https://cad.onshape.com/documents/a1c1addf75444f54b504f25c/w/0d17b8ebb2a4c76be9fff3c7/e/a86aaf34d2f4353288df8812\",\n                    did=\"a1c1addf75444f54b504f25c\",\n                    wtype=\"w\",\n                    wid=\"0d17b8ebb2a4c76be9fff3c7\",\n                    eid=\"a86aaf34d2f4353288df8812\"\n                )\n            )\n        \"\"\"\n        request_path = \"/api/assemblies/d/\" + did + \"/\" + wtype + \"/\" + wid + \"/e/\" + eid\n        res = self.request(\n            HTTP.GET,\n            request_path,\n            query={\n                \"includeMateFeatures\": \"true\",\n                \"includeMateConnectors\": \"true\",\n                \"includeNonSolids\": \"false\",\n                \"configuration\": configuration,\n            },\n            log_response=log_response,\n        )\n\n        if res.status_code == 401 or res.status_code == 403:\n            logger.warning(f\"Unauthorized access to document: {did}\")\n            logger.warning(\"Please check the API keys in your env file.\")\n            exit(1)\n\n        if res.status_code == 404:\n            logger.error(f\"Assembly not found: {did}\")\n            logger.error(\n                generate_url(\n                    base_url=self._url,\n                    did=did,\n                    wtype=wtype,\n                    wid=wid,\n                    eid=eid,\n                )\n            )\n            exit(1)\n\n        # Clean numerical values from API response before validation\n        from onshape_robotics_toolkit.utilities.helpers import clean_json_numerics\n\n        assembly_data = clean_json_numerics(res.json(), threshold=1e-10, decimals=8)\n        assembly = Assembly.model_validate(assembly_data)\n        document = Document(did=did, wtype=wtype, wid=wid, eid=eid)\n        assembly.document = document\n\n        if with_meta_data:\n            assembly.name = self.get_assembly_name(did, wtype, wid, eid, configuration)\n            document_meta_data = self.get_document_metadata(did)\n            assembly.document.name = document_meta_data.name\n\n        record_document_config(\n            url=getattr(assembly.document, \"url\", None),\n            base_url=self._url,\n            did=did,\n            wtype=wtype,\n            wid=wid,\n            eid=eid,\n            name=getattr(assembly.document, \"name\", None),\n        )\n        record_assembly_config(\n            element_id=eid,\n            configuration=configuration,\n            log_response=log_response,\n            with_meta_data=with_meta_data,\n        )\n\n        return assembly\n\n    def download_assembly_stl(\n        self,\n        did: str,\n        wtype: str,\n        wid: str,\n        eid: str,\n        buffer: BinaryIO,\n        configuration: str = \"default\",\n    ) -&gt; Optional[BinaryIO]:\n        \"\"\"\n        Download an STL file from an assembly. The file is written to the buffer.\n\n        Args:\n            did: The unique identifier of the document.\n            wtype: The type of workspace.\n            wid: The unique identifier of the workspace.\n            eid: The unique identifier of the element.\n            buffer: BinaryIO object to write the STL file to.\n            configuration: The configuration of the assembly.\n\n        \"\"\"\n        req_headers = {\"Accept\": \"application/vnd.onshape.v1+octet-stream\"}\n        request_path = f\"/api/assemblies/d/{did}/{wtype}/{wid}/e/{eid}/translations\"\n\n        # Initiate the translation\n        payload = {\n            \"formatName\": \"STL\",\n            \"storeInDocument\": \"false\",\n        }\n        response = self.request(\n            HTTP.POST,\n            path=request_path,\n            body=payload,\n            log_response=False,\n        )\n\n        if response.status_code == 200:\n            job_info = response.json()\n            translation_id = job_info.get(\"id\")\n            if not translation_id:\n                logger.error(\"Translation job ID not found in response.\")\n                return None\n\n            status_path = f\"/api/translations/{translation_id}\"\n            while True:\n                status_response = self.request(HTTP.GET, path=status_path)\n                if status_response.status_code != 200:\n                    logger.error(f\"Failed to get translation status: {status_response.text}\")\n                    return None\n\n                status_info = status_response.json()\n                request_state = status_info.get(\"requestState\")\n                logger.info(f\"Current status: {request_state}\")\n                if request_state == \"DONE\":\n                    logger.info(\"Translation job completed.\")\n                    break\n                elif request_state == \"FAILED\":\n                    logger.error(\"Translation job failed.\")\n                    return None\n                time.sleep(1)\n\n            fid = status_info.get(\"resultExternalDataIds\")[0]\n            data_path = f\"/api/documents/d/{did}/externaldata/{fid}\"\n\n            download_response = self.request(\n                HTTP.GET,\n                path=data_path,\n                headers=req_headers,\n                log_response=False,\n            )\n            if download_response.status_code == 200:\n                buffer.write(download_response.content)\n                logger.info(\"STL file downloaded successfully.\")\n                return buffer\n            else:\n                logger.error(f\"Failed to download STL file: {download_response.text}\")\n                return None\n\n        else:\n            logger.info(f\"Failed to download assembly: {response.status_code} - {response.text}\")\n            logger.info(\n                generate_url(\n                    base_url=self._url,\n                    did=did,\n                    wtype=wtype,\n                    wid=wid,\n                    eid=eid,\n                )\n            )\n\n        return buffer\n\n    def download_part_stl(\n        self,\n        did: str,\n        wtype: str,\n        wid: str,\n        eid: str,\n        partID: str,\n        buffer: BinaryIO,\n    ) -&gt; BinaryIO:\n        \"\"\"\n        Download an STL file from a part studio. The file is written to the buffer.\n\n        Args:\n            did: The unique identifier of the document.\n            wtype: The type of workspace.\n            wid: The unique identifier of the workspace.\n            eid: The unique identifier of the element.\n            partID: The unique identifier of the part.\n            buffer: BinaryIO object to write the STL file to.\n\n        Returns:\n            BinaryIO: BinaryIO object containing the STL file\n\n        Examples:\n            &gt;&gt;&gt; with io.BytesIO() as buffer:\n            ...     client.download_part_stl(\n            ...         \"a1c1addf75444f54b504f25c\",\n            ...         \"0d17b8ebb2a4c76be9fff3c7\",\n            ...         \"a86aaf34d2f4353288df8812\",\n            ...         \"0b0c209535554345432581fe\",\n            ...         buffer,\n            ...         \"w\",\n            ...         \"0d17b8ebb2a4c76be9fff3c7\"\n            ...     )\n            &gt;&gt;&gt; buffer.seek(0)\n            &gt;&gt;&gt; raw_mesh = stl.mesh.Mesh.from_file(None, fh=buffer)\n            &gt;&gt;&gt; raw_mesh.save(\"mesh.stl\")\n        \"\"\"\n        # TODO: version id seems to always work, should this default behavior be changed?\n        req_headers = {\"Accept\": \"application/vnd.onshape.v1+octet-stream\"}\n        request_path = f\"/api/parts/d/{did}/{wtype}/{wid}/e/{eid}/partid/{partID}/stl\"\n        _query = {\n            \"mode\": \"binary\",\n            \"grouping\": True,\n            \"units\": \"meter\",\n        }\n        response = self.request(\n            HTTP.GET,\n            path=request_path,\n            headers=req_headers,\n            query=_query,\n            log_response=False,\n        )\n        if response.status_code == 200:\n            buffer.write(response.content)\n        else:\n            url = generate_url(\n                base_url=self._url,\n                did=did,\n                wtype=wtype,\n                wid=wid,\n                eid=eid,\n            )\n            logger.info(f\"{url}\")\n            logger.info(f\"Failed to download STL file: {response.status_code} - {response.text}\")\n\n        return buffer\n\n    def get_assembly_mass_properties(\n        self,\n        did: str,\n        wtype: str,\n        wid: str,\n        eid: str,\n    ) -&gt; MassProperties:\n        \"\"\"\n        Get mass properties of a rigid assembly in a document.\n\n        Args:\n            did: The unique identifier of the document.\n            wtype: The type of workspace.\n            wid: The unique identifier of the workspace.\n            eid: The unique identifier of the rigid assembly.\n\n        Returns:\n            MassProperties object containing the mass properties of the assembly.\n\n        Examples:\n            &gt;&gt;&gt; mass_properties = client.get_assembly_mass_properties(\n            ...     did=\"a1c1addf75444f54b504f25c\",\n            ...     wid=\"0d17b8ebb2a4c76be9fff3c7\",\n            ...     eid=\"a86aaf34d2f4353288df8812\",\n            ...     wtype=\"w\"\n            ... )\n            &gt;&gt;&gt; print(mass_properties)\n            MassProperties(\n                volume=[0.003411385108378978, 0.003410724395374695, 0.0034120458213832646],\n                mass=[9.585992154544929, 9.584199206938452, 9.587785102151415],\n                centroid=[...],\n                inertia=[...],\n                principalInertia=[0.09944605933465941, 0.09944605954654827, 0.19238058837442526],\n                principalAxes=[...]\n            )\n        \"\"\"\n        request_path = f\"/api/assemblies/d/{did}/{wtype}/{wid}/e/{eid}/massproperties\"\n        res = self.request(HTTP.GET, request_path, log_response=False)\n\n        if res.status_code == 404:\n            url = generate_url(\n                base_url=self._url,\n                did=did,\n                wtype=wtype,\n                wid=wid,\n                eid=eid,\n            )\n            raise ValueError(f\"Assembly: {url} does not have a mass property\")\n\n        return MassProperties.model_validate(res.json())\n\n    def get_mass_property(\n        self,\n        did: str,\n        wtype: str,\n        wid: str,\n        eid: str,\n        partID: str,\n    ) -&gt; MassProperties:\n        \"\"\"\n        Get mass properties of a part in a part studio.\n\n        Args:\n            did: The unique identifier of the document.\n            wtype: The type of workspace.\n            wid: The unique identifier of the workspace.\n            eid: The unique identifier of the element.\n            partID: The identifier of the part.\n\n        Returns:\n            MassProperties object containing the mass properties of the part.\n\n        Examples:\n            &gt;&gt;&gt; mass_properties = client.get_mass_property(\n            ...     did=\"a1c1addf75444f54b504f25c\",\n            ...     wid=\"0d17b8ebb2a4c76be9fff3c7\",\n            ...     eid=\"a86aaf34d2f4353288df8812\",\n            ...     partID=\"0b0c209535554345432581fe\"\n            ...     wtype=\"w\"\n            ... )\n            &gt;&gt;&gt; print(mass_properties)\n            MassProperties(\n                volume=[0.003411385108378978, 0.003410724395374695, 0.0034120458213832646],\n                mass=[9.585992154544929, 9.584199206938452, 9.587785102151415],\n                centroid=[...],\n                inertia=[...],\n                principalInertia=[0.09944605933465941, 0.09944605954654827, 0.19238058837442526],\n                principalAxes=[...]\n            )\n        \"\"\"\n        # TODO: version id seems to always work, should this default behavior be changed?\n        request_path = f\"/api/parts/d/{did}/{wtype}/{wid}/e/{eid}/partid/{partID}/massproperties\"\n        res = self.request(HTTP.GET, request_path, {\"useMassPropertiesOverrides\": True}, log_response=False)\n\n        if res.status_code == 404:\n            # TODO: There doesn't seem to be a way to assign material to a part currently\n            # It is possible that the workspace got deleted\n            url = generate_url(\n                base_url=self._url,\n                did=did,\n                wtype=wtype,\n                wid=wid,\n                eid=eid,\n            )\n            raise ValueError(f\"Part: {url} does not have a material assigned or the part is not found\")\n\n        elif res.status_code == 429:\n            raise ValueError(f\"Too many requests, please retry after {res.headers['Retry-After']} seconds\")\n\n        resonse_json = res.json()\n\n        if \"bodies\" not in resonse_json:\n            raise KeyError(f\"Bodies not found in response, broken part? {partID}\")\n\n        return MassProperties.model_validate(resonse_json[\"bodies\"][partID])\n\n    def request(\n        self,\n        method: HTTP,\n        path: str,\n        query: Optional[dict[str, Any]] = None,\n        headers: Optional[dict[str, Any]] = None,\n        body: Optional[Union[dict[str, Any], list[dict[str, Any]]]] = None,\n        base_url: Optional[str] = None,\n        log_response: bool = True,\n        timeout: int = 50,\n    ) -&gt; requests.Response:\n        \"\"\"\n        Send a request to the Onshape API.\n\n        Args:\n            method: HTTP method (GET, POST, DELETE)\n            path: URL path for the request\n            query: Query string in key-value pairs\n            headers: Additional headers for the request\n            body: Body of the request\n            base_url: Base URL for the request\n            log_response: Log the response from the API request\n            timeout: Timeout for the request in seconds\n        Returns:\n            requests.Response: Response from the Onshape API request\n        \"\"\"\n        if query is None:\n            query = {}\n        if headers is None:\n            headers = {}\n        if base_url is None:\n            base_url = self._url\n\n        req_headers = self._make_headers(method, path, query, headers)\n        url = self._build_url(base_url, path, query)\n\n        logger.debug(f\"Request body: {body}\")\n        logger.debug(f\"Request headers: {req_headers}\")\n        logger.debug(f\"Request URL: {url}\")\n\n        res = self._send_request(method, url, req_headers, body, timeout)\n\n        if res.status_code == 307:\n            return self._handle_redirect(res, method, headers, log_response)\n        else:\n            if log_response:\n                self._log_response(res)\n\n        # Increment API call counter for successful responses (2xx status codes)\n        if 200 &lt;= res.status_code &lt; 300:\n            self._api_call_count += 1\n\n        return res\n\n    def _build_url(self, base_url: str, path: str, query: dict[str, Any]) -&gt; str:\n        \"\"\"\n        Build the URL for the request.\n\n        Args:\n            base_url: The base URL for the request.\n            path: The path for the request.\n            query: The query string for the request.\n\n        Returns:\n            The URL for the request.\n        \"\"\"\n        return base_url + path + \"?\" + urlencode(query)\n\n    def _send_request(\n        self,\n        method: HTTP,\n        url: str,\n        headers: dict[str, Any],\n        body: Optional[Union[dict[str, Any], list[dict[str, Any]]]],\n        timeout: int,\n    ) -&gt; requests.Response:\n        \"\"\"\n        Send the request to the Onshape API.\n\n        Args:\n            method: The HTTP method for the request.\n            url: The URL for the request.\n            headers: The headers for the request.\n            body: The body for the request.\n            timeout: The timeout for the request in seconds.\n\n        Returns:\n            The response from the Onshape API request.\n        \"\"\"\n        return requests.request(\n            method,\n            url,\n            headers=headers,\n            json=body,\n            allow_redirects=False,\n            stream=True,\n            timeout=timeout,  # Specify an appropriate timeout value in seconds\n        )\n\n    def _handle_redirect(\n        self,\n        res: requests.Response,\n        method: HTTP,\n        headers: dict[str, Any],\n        log_response: bool = True,\n    ) -&gt; requests.Response:\n        \"\"\"\n        Handle a redirect response from the Onshape API.\n\n        Args:\n            res: The response from the Onshape API request.\n            method: The HTTP method for the request.\n            headers: The headers for the request.\n            log_response: Whether to log the response from the API request.\n\n        Returns:\n            The response from the Onshape API request.\n        \"\"\"\n        location = urlparse(res.headers[\"Location\"])\n        querystring = parse_qs(location.query)\n\n        logger.debug(f\"Request redirected to: {location.geturl()}\")\n\n        new_query = {key: querystring[key][0] for key in querystring}\n        new_base_url = location.scheme + \"://\" + location.netloc\n\n        return self.request(\n            method, location.path, query=new_query, headers=headers, base_url=new_base_url, log_response=log_response\n        )\n\n    def _log_response(self, res: requests.Response) -&gt; None:\n        \"\"\"\n        Log the response from the Onshape API request.\n\n        Args:\n            res: The response from the Onshape API request.\n        \"\"\"\n        try:\n            if not 200 &lt;= res.status_code &lt;= 206:\n                logger.debug(f\"Request failed, details: {res.text}\")\n            else:\n                logger.debug(f\"Request succeeded, details: {res.text}\")\n        except UnicodeEncodeError as e:\n            logger.error(f\"UnicodeEncodeError: {e}\")\n\n    def _make_auth(\n        self,\n        method: HTTP,\n        date: str,\n        nonce: str,\n        path: str,\n        query: Optional[dict[str, Any]] = None,\n        ctype: str = \"application/json\",\n    ) -&gt; str:\n        \"\"\"\n        Make the authentication header for the Onshape API request.\n\n        Args:\n            method: The HTTP method for the request.\n            date: The date for the request.\n            nonce: The nonce for the request.\n            path: The path for the request.\n            query: The query string for the request.\n            ctype: The content type for the request.\n\n        Returns:\n            The authentication header for the Onshape API request.\n        \"\"\"\n        if query is None:\n            query = {}\n        query_string = urlencode(query)\n\n        hmac_str = (\n            str(method + \"\\n\" + nonce + \"\\n\" + date + \"\\n\" + ctype + \"\\n\" + path + \"\\n\" + query_string + \"\\n\")\n            .lower()\n            .encode(\"utf-8\")\n        )\n\n        signature = base64.b64encode(\n            hmac.new(self._secret_key.encode(\"utf-8\"), hmac_str, digestmod=hashlib.sha256).digest()\n        )\n        auth = \"On \" + self._access_key + \":HmacSHA256:\" + signature.decode(\"utf-8\")\n\n        logger.debug(f\"query: {query_string}, hmac_str: {hmac_str!r}, signature: {signature!r}, auth: {auth}\")\n\n        return auth\n\n    def _make_headers(\n        self,\n        method: HTTP,\n        path: str,\n        query: Optional[dict[str, Any]] = None,\n        headers: Optional[dict[str, Any]] = None,\n    ) -&gt; dict[str, Any]:\n        \"\"\"\n        Make the headers for the Onshape API request.\n\n        Args:\n            method: The HTTP method for the request.\n            path: The path for the request.\n            query: The query string for the request.\n            headers: The headers for the request.\n\n        Returns:\n            The headers for the Onshape API request.\n        \"\"\"\n        if headers is None:\n            headers = {}\n        if query is None:\n            query = {}\n        date = datetime.datetime.utcnow().strftime(\"%a, %d %b %Y %H:%M:%S GMT\")\n        nonce = make_nonce()\n        ctype = headers.get(\"Content-Type\") if headers.get(\"Content-Type\") else \"application/json\"\n\n        auth = self._make_auth(method, date, nonce, path, query=query, ctype=ctype or \"application/json\")\n\n        req_headers = {\n            \"Content-Type\": \"application/json\",\n            \"Date\": date,\n            \"On-Nonce\": nonce,\n            \"Authorization\": auth,\n            \"User-Agent\": \"Onshape Python Sample App\",\n            \"Accept\": \"application/json\",\n        }\n\n        # add in user-defined headers\n        for h in headers:\n            req_headers[h] = headers[h]\n\n        return req_headers\n\n    @property\n    def base_url(self) -&gt; str:\n        \"\"\"\n        Get the base URL for the Onshape API request.\n\n        Returns:\n            The base URL for the Onshape API request.\n        \"\"\"\n        return self._url\n</code></pre>"},{"location":"api/connect/#onshape_robotics_toolkit.connect.Client.api_call_count","title":"<code>api_call_count</code>  <code>property</code>","text":"<p>Get the current API call count.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of successful API calls made by this client</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; client.api_call_count\n42\n</code></pre>"},{"location":"api/connect/#onshape_robotics_toolkit.connect.Client.base_url","title":"<code>base_url</code>  <code>property</code>","text":"<p>Get the base URL for the Onshape API request.</p> <p>Returns:</p> Type Description <code>str</code> <p>The base URL for the Onshape API request.</p>"},{"location":"api/connect/#onshape_robotics_toolkit.connect.Client.__init__","title":"<code>__init__(env=None, base_url=BASE_URL)</code>","text":"<p>Initialize the Onshape API client.</p> <p>Parameters:</p> Name Type Description Default <code>env</code> <code>Union[str, None]</code> <p>Path to the environment file containing the access and secret keys</p> <code>None</code> <code>base_url</code> <code>str</code> <p>Base URL for the Onshape API</p> <code>BASE_URL</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; client = Client(\n...     env=\".env\",\n... )\n</code></pre> Source code in <code>onshape_robotics_toolkit/connect.py</code> <pre><code>def __init__(self, env: Union[str, None] = None, base_url: str = BASE_URL):\n    \"\"\"\n    Initialize the Onshape API client.\n\n    Args:\n        env: Path to the environment file containing the access and secret keys\n        base_url: Base URL for the Onshape API\n\n    Examples:\n        &gt;&gt;&gt; client = Client(\n        ...     env=\".env\",\n        ... )\n    \"\"\"\n\n    self._url = base_url\n    self._access_key, self._secret_key = load_env_variables(env)\n    self._api_call_count = 0\n    logger.info(f\"Onshape API initialized with env file: {env}\")\n    record_client_config(env=env, base_url=base_url)\n\n    # Register cleanup function to log API usage on exit\n    atexit.register(self._log_final_api_count)\n</code></pre>"},{"location":"api/connect/#onshape_robotics_toolkit.connect.Client.download_assembly_stl","title":"<code>download_assembly_stl(did, wtype, wid, eid, buffer, configuration='default')</code>","text":"<p>Download an STL file from an assembly. The file is written to the buffer.</p> <p>Parameters:</p> Name Type Description Default <code>did</code> <code>str</code> <p>The unique identifier of the document.</p> required <code>wtype</code> <code>str</code> <p>The type of workspace.</p> required <code>wid</code> <code>str</code> <p>The unique identifier of the workspace.</p> required <code>eid</code> <code>str</code> <p>The unique identifier of the element.</p> required <code>buffer</code> <code>BinaryIO</code> <p>BinaryIO object to write the STL file to.</p> required <code>configuration</code> <code>str</code> <p>The configuration of the assembly.</p> <code>'default'</code> Source code in <code>onshape_robotics_toolkit/connect.py</code> <pre><code>def download_assembly_stl(\n    self,\n    did: str,\n    wtype: str,\n    wid: str,\n    eid: str,\n    buffer: BinaryIO,\n    configuration: str = \"default\",\n) -&gt; Optional[BinaryIO]:\n    \"\"\"\n    Download an STL file from an assembly. The file is written to the buffer.\n\n    Args:\n        did: The unique identifier of the document.\n        wtype: The type of workspace.\n        wid: The unique identifier of the workspace.\n        eid: The unique identifier of the element.\n        buffer: BinaryIO object to write the STL file to.\n        configuration: The configuration of the assembly.\n\n    \"\"\"\n    req_headers = {\"Accept\": \"application/vnd.onshape.v1+octet-stream\"}\n    request_path = f\"/api/assemblies/d/{did}/{wtype}/{wid}/e/{eid}/translations\"\n\n    # Initiate the translation\n    payload = {\n        \"formatName\": \"STL\",\n        \"storeInDocument\": \"false\",\n    }\n    response = self.request(\n        HTTP.POST,\n        path=request_path,\n        body=payload,\n        log_response=False,\n    )\n\n    if response.status_code == 200:\n        job_info = response.json()\n        translation_id = job_info.get(\"id\")\n        if not translation_id:\n            logger.error(\"Translation job ID not found in response.\")\n            return None\n\n        status_path = f\"/api/translations/{translation_id}\"\n        while True:\n            status_response = self.request(HTTP.GET, path=status_path)\n            if status_response.status_code != 200:\n                logger.error(f\"Failed to get translation status: {status_response.text}\")\n                return None\n\n            status_info = status_response.json()\n            request_state = status_info.get(\"requestState\")\n            logger.info(f\"Current status: {request_state}\")\n            if request_state == \"DONE\":\n                logger.info(\"Translation job completed.\")\n                break\n            elif request_state == \"FAILED\":\n                logger.error(\"Translation job failed.\")\n                return None\n            time.sleep(1)\n\n        fid = status_info.get(\"resultExternalDataIds\")[0]\n        data_path = f\"/api/documents/d/{did}/externaldata/{fid}\"\n\n        download_response = self.request(\n            HTTP.GET,\n            path=data_path,\n            headers=req_headers,\n            log_response=False,\n        )\n        if download_response.status_code == 200:\n            buffer.write(download_response.content)\n            logger.info(\"STL file downloaded successfully.\")\n            return buffer\n        else:\n            logger.error(f\"Failed to download STL file: {download_response.text}\")\n            return None\n\n    else:\n        logger.info(f\"Failed to download assembly: {response.status_code} - {response.text}\")\n        logger.info(\n            generate_url(\n                base_url=self._url,\n                did=did,\n                wtype=wtype,\n                wid=wid,\n                eid=eid,\n            )\n        )\n\n    return buffer\n</code></pre>"},{"location":"api/connect/#onshape_robotics_toolkit.connect.Client.download_part_stl","title":"<code>download_part_stl(did, wtype, wid, eid, partID, buffer)</code>","text":"<p>Download an STL file from a part studio. The file is written to the buffer.</p> <p>Parameters:</p> Name Type Description Default <code>did</code> <code>str</code> <p>The unique identifier of the document.</p> required <code>wtype</code> <code>str</code> <p>The type of workspace.</p> required <code>wid</code> <code>str</code> <p>The unique identifier of the workspace.</p> required <code>eid</code> <code>str</code> <p>The unique identifier of the element.</p> required <code>partID</code> <code>str</code> <p>The unique identifier of the part.</p> required <code>buffer</code> <code>BinaryIO</code> <p>BinaryIO object to write the STL file to.</p> required <p>Returns:</p> Name Type Description <code>BinaryIO</code> <code>BinaryIO</code> <p>BinaryIO object containing the STL file</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; with io.BytesIO() as buffer:\n...     client.download_part_stl(\n...         \"a1c1addf75444f54b504f25c\",\n...         \"0d17b8ebb2a4c76be9fff3c7\",\n...         \"a86aaf34d2f4353288df8812\",\n...         \"0b0c209535554345432581fe\",\n...         buffer,\n...         \"w\",\n...         \"0d17b8ebb2a4c76be9fff3c7\"\n...     )\n&gt;&gt;&gt; buffer.seek(0)\n&gt;&gt;&gt; raw_mesh = stl.mesh.Mesh.from_file(None, fh=buffer)\n&gt;&gt;&gt; raw_mesh.save(\"mesh.stl\")\n</code></pre> Source code in <code>onshape_robotics_toolkit/connect.py</code> <pre><code>def download_part_stl(\n    self,\n    did: str,\n    wtype: str,\n    wid: str,\n    eid: str,\n    partID: str,\n    buffer: BinaryIO,\n) -&gt; BinaryIO:\n    \"\"\"\n    Download an STL file from a part studio. The file is written to the buffer.\n\n    Args:\n        did: The unique identifier of the document.\n        wtype: The type of workspace.\n        wid: The unique identifier of the workspace.\n        eid: The unique identifier of the element.\n        partID: The unique identifier of the part.\n        buffer: BinaryIO object to write the STL file to.\n\n    Returns:\n        BinaryIO: BinaryIO object containing the STL file\n\n    Examples:\n        &gt;&gt;&gt; with io.BytesIO() as buffer:\n        ...     client.download_part_stl(\n        ...         \"a1c1addf75444f54b504f25c\",\n        ...         \"0d17b8ebb2a4c76be9fff3c7\",\n        ...         \"a86aaf34d2f4353288df8812\",\n        ...         \"0b0c209535554345432581fe\",\n        ...         buffer,\n        ...         \"w\",\n        ...         \"0d17b8ebb2a4c76be9fff3c7\"\n        ...     )\n        &gt;&gt;&gt; buffer.seek(0)\n        &gt;&gt;&gt; raw_mesh = stl.mesh.Mesh.from_file(None, fh=buffer)\n        &gt;&gt;&gt; raw_mesh.save(\"mesh.stl\")\n    \"\"\"\n    # TODO: version id seems to always work, should this default behavior be changed?\n    req_headers = {\"Accept\": \"application/vnd.onshape.v1+octet-stream\"}\n    request_path = f\"/api/parts/d/{did}/{wtype}/{wid}/e/{eid}/partid/{partID}/stl\"\n    _query = {\n        \"mode\": \"binary\",\n        \"grouping\": True,\n        \"units\": \"meter\",\n    }\n    response = self.request(\n        HTTP.GET,\n        path=request_path,\n        headers=req_headers,\n        query=_query,\n        log_response=False,\n    )\n    if response.status_code == 200:\n        buffer.write(response.content)\n    else:\n        url = generate_url(\n            base_url=self._url,\n            did=did,\n            wtype=wtype,\n            wid=wid,\n            eid=eid,\n        )\n        logger.info(f\"{url}\")\n        logger.info(f\"Failed to download STL file: {response.status_code} - {response.text}\")\n\n    return buffer\n</code></pre>"},{"location":"api/connect/#onshape_robotics_toolkit.connect.Client.get_assembly","title":"<code>get_assembly(did, wtype, wid, eid, configuration='default', log_response=True, with_meta_data=True)</code>","text":"<p>Get assembly data for a specified document / workspace / assembly.</p> <p>Parameters:</p> Name Type Description Default <code>did</code> <code>str</code> <p>The unique identifier of the document.</p> required <code>wtype</code> <code>str</code> <p>The type of workspace.</p> required <code>wid</code> <code>str</code> <p>The unique identifier of the workspace.</p> required <code>eid</code> <code>str</code> <p>The unique identifier of the assembly.</p> required <code>configuration</code> <code>str</code> <p>The configuration of the assembly.</p> <code>'default'</code> <code>log_response</code> <code>bool</code> <p>Log the response from the API request.</p> <code>True</code> <code>with_meta_data</code> <code>bool</code> <p>Include meta data in the assembly data.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>Assembly</code> <code>Assembly</code> <p>Assembly object containing the assembly data</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assembly = client.get_assembly(\n...     did=\"a1c1addf75444f54b504f25c\",\n...     wtype=\"w\",\n...     wid=\"0d17b8ebb2a4c76be9fff3c7\",\n...     eid=\"a86aaf34d2f4353288df8812\"\n... )\n&gt;&gt;&gt; print(assembly)\nAssembly(\n    rootAssembly=RootAssembly(\n        instances=[...],\n        patterns=[...],\n        features=[...],\n        occurrences=[...],\n        fullConfiguration=\"default\",\n        configuration=\"default\",\n        documentId=\"a1c1addf75444f54b504f25c\",\n        elementId=\"0b0c209535554345432581fe\",\n        documentMicroversion=\"349f6413cafefe8fb4ab3b07\",\n    ),\n    subAssemblies=[...],\n    parts=[...],\n    partStudioFeatures=[...],\n    document=Document(\n        url=\"https://cad.onshape.com/documents/a1c1addf75444f54b504f25c/w/0d17b8ebb2a4c76be9fff3c7/e/a86aaf34d2f4353288df8812\",\n        did=\"a1c1addf75444f54b504f25c\",\n        wtype=\"w\",\n        wid=\"0d17b8ebb2a4c76be9fff3c7\",\n        eid=\"a86aaf34d2f4353288df8812\"\n    )\n)\n</code></pre> Source code in <code>onshape_robotics_toolkit/connect.py</code> <pre><code>def get_assembly(\n    self,\n    did: str,\n    wtype: str,\n    wid: str,\n    eid: str,\n    configuration: str = \"default\",\n    log_response: bool = True,\n    with_meta_data: bool = True,\n) -&gt; Assembly:\n    \"\"\"\n    Get assembly data for a specified document / workspace / assembly.\n\n    Args:\n        did: The unique identifier of the document.\n        wtype: The type of workspace.\n        wid: The unique identifier of the workspace.\n        eid: The unique identifier of the assembly.\n        configuration: The configuration of the assembly.\n        log_response: Log the response from the API request.\n        with_meta_data: Include meta data in the assembly data.\n\n    Returns:\n        Assembly: Assembly object containing the assembly data\n\n    Examples:\n        &gt;&gt;&gt; assembly = client.get_assembly(\n        ...     did=\"a1c1addf75444f54b504f25c\",\n        ...     wtype=\"w\",\n        ...     wid=\"0d17b8ebb2a4c76be9fff3c7\",\n        ...     eid=\"a86aaf34d2f4353288df8812\"\n        ... )\n        &gt;&gt;&gt; print(assembly)\n        Assembly(\n            rootAssembly=RootAssembly(\n                instances=[...],\n                patterns=[...],\n                features=[...],\n                occurrences=[...],\n                fullConfiguration=\"default\",\n                configuration=\"default\",\n                documentId=\"a1c1addf75444f54b504f25c\",\n                elementId=\"0b0c209535554345432581fe\",\n                documentMicroversion=\"349f6413cafefe8fb4ab3b07\",\n            ),\n            subAssemblies=[...],\n            parts=[...],\n            partStudioFeatures=[...],\n            document=Document(\n                url=\"https://cad.onshape.com/documents/a1c1addf75444f54b504f25c/w/0d17b8ebb2a4c76be9fff3c7/e/a86aaf34d2f4353288df8812\",\n                did=\"a1c1addf75444f54b504f25c\",\n                wtype=\"w\",\n                wid=\"0d17b8ebb2a4c76be9fff3c7\",\n                eid=\"a86aaf34d2f4353288df8812\"\n            )\n        )\n    \"\"\"\n    request_path = \"/api/assemblies/d/\" + did + \"/\" + wtype + \"/\" + wid + \"/e/\" + eid\n    res = self.request(\n        HTTP.GET,\n        request_path,\n        query={\n            \"includeMateFeatures\": \"true\",\n            \"includeMateConnectors\": \"true\",\n            \"includeNonSolids\": \"false\",\n            \"configuration\": configuration,\n        },\n        log_response=log_response,\n    )\n\n    if res.status_code == 401 or res.status_code == 403:\n        logger.warning(f\"Unauthorized access to document: {did}\")\n        logger.warning(\"Please check the API keys in your env file.\")\n        exit(1)\n\n    if res.status_code == 404:\n        logger.error(f\"Assembly not found: {did}\")\n        logger.error(\n            generate_url(\n                base_url=self._url,\n                did=did,\n                wtype=wtype,\n                wid=wid,\n                eid=eid,\n            )\n        )\n        exit(1)\n\n    # Clean numerical values from API response before validation\n    from onshape_robotics_toolkit.utilities.helpers import clean_json_numerics\n\n    assembly_data = clean_json_numerics(res.json(), threshold=1e-10, decimals=8)\n    assembly = Assembly.model_validate(assembly_data)\n    document = Document(did=did, wtype=wtype, wid=wid, eid=eid)\n    assembly.document = document\n\n    if with_meta_data:\n        assembly.name = self.get_assembly_name(did, wtype, wid, eid, configuration)\n        document_meta_data = self.get_document_metadata(did)\n        assembly.document.name = document_meta_data.name\n\n    record_document_config(\n        url=getattr(assembly.document, \"url\", None),\n        base_url=self._url,\n        did=did,\n        wtype=wtype,\n        wid=wid,\n        eid=eid,\n        name=getattr(assembly.document, \"name\", None),\n    )\n    record_assembly_config(\n        element_id=eid,\n        configuration=configuration,\n        log_response=log_response,\n        with_meta_data=with_meta_data,\n    )\n\n    return assembly\n</code></pre>"},{"location":"api/connect/#onshape_robotics_toolkit.connect.Client.get_assembly_mass_properties","title":"<code>get_assembly_mass_properties(did, wtype, wid, eid)</code>","text":"<p>Get mass properties of a rigid assembly in a document.</p> <p>Parameters:</p> Name Type Description Default <code>did</code> <code>str</code> <p>The unique identifier of the document.</p> required <code>wtype</code> <code>str</code> <p>The type of workspace.</p> required <code>wid</code> <code>str</code> <p>The unique identifier of the workspace.</p> required <code>eid</code> <code>str</code> <p>The unique identifier of the rigid assembly.</p> required <p>Returns:</p> Type Description <code>MassProperties</code> <p>MassProperties object containing the mass properties of the assembly.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; mass_properties = client.get_assembly_mass_properties(\n...     did=\"a1c1addf75444f54b504f25c\",\n...     wid=\"0d17b8ebb2a4c76be9fff3c7\",\n...     eid=\"a86aaf34d2f4353288df8812\",\n...     wtype=\"w\"\n... )\n&gt;&gt;&gt; print(mass_properties)\nMassProperties(\n    volume=[0.003411385108378978, 0.003410724395374695, 0.0034120458213832646],\n    mass=[9.585992154544929, 9.584199206938452, 9.587785102151415],\n    centroid=[...],\n    inertia=[...],\n    principalInertia=[0.09944605933465941, 0.09944605954654827, 0.19238058837442526],\n    principalAxes=[...]\n)\n</code></pre> Source code in <code>onshape_robotics_toolkit/connect.py</code> <pre><code>def get_assembly_mass_properties(\n    self,\n    did: str,\n    wtype: str,\n    wid: str,\n    eid: str,\n) -&gt; MassProperties:\n    \"\"\"\n    Get mass properties of a rigid assembly in a document.\n\n    Args:\n        did: The unique identifier of the document.\n        wtype: The type of workspace.\n        wid: The unique identifier of the workspace.\n        eid: The unique identifier of the rigid assembly.\n\n    Returns:\n        MassProperties object containing the mass properties of the assembly.\n\n    Examples:\n        &gt;&gt;&gt; mass_properties = client.get_assembly_mass_properties(\n        ...     did=\"a1c1addf75444f54b504f25c\",\n        ...     wid=\"0d17b8ebb2a4c76be9fff3c7\",\n        ...     eid=\"a86aaf34d2f4353288df8812\",\n        ...     wtype=\"w\"\n        ... )\n        &gt;&gt;&gt; print(mass_properties)\n        MassProperties(\n            volume=[0.003411385108378978, 0.003410724395374695, 0.0034120458213832646],\n            mass=[9.585992154544929, 9.584199206938452, 9.587785102151415],\n            centroid=[...],\n            inertia=[...],\n            principalInertia=[0.09944605933465941, 0.09944605954654827, 0.19238058837442526],\n            principalAxes=[...]\n        )\n    \"\"\"\n    request_path = f\"/api/assemblies/d/{did}/{wtype}/{wid}/e/{eid}/massproperties\"\n    res = self.request(HTTP.GET, request_path, log_response=False)\n\n    if res.status_code == 404:\n        url = generate_url(\n            base_url=self._url,\n            did=did,\n            wtype=wtype,\n            wid=wid,\n            eid=eid,\n        )\n        raise ValueError(f\"Assembly: {url} does not have a mass property\")\n\n    return MassProperties.model_validate(res.json())\n</code></pre>"},{"location":"api/connect/#onshape_robotics_toolkit.connect.Client.get_assembly_name","title":"<code>get_assembly_name(did, wtype, wid, eid, configuration='default')</code>","text":"<p>Get assembly name for a specified document / workspace / assembly.</p> <p>Parameters:</p> Name Type Description Default <code>did</code> <code>str</code> <p>The unique identifier of the document.</p> required <code>wtype</code> <code>str</code> <p>The type of workspace.</p> required <code>wid</code> <code>str</code> <p>The unique identifier of the workspace.</p> required <code>eid</code> <code>str</code> <p>The unique identifier of the assembly.</p> required <code>configuration</code> <code>str</code> <p>The configuration of the assembly.</p> <code>'default'</code> <p>Returns:</p> Name Type Description <code>str</code> <code>Optional[str]</code> <p>Assembly name</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assembly_name = client.get_assembly_name(\n...     did=\"a1c1addf75444f54b504f25c\",\n...     wtype=\"w\",\n...     wid=\"0d17b8ebb2a4c76be9fff3c7\",\n...     eid=\"a86aaf34d2f4353288df8812\"\n... )\n&gt;&gt;&gt; print(assembly_name)\n\"Assembly Name\"\n</code></pre> Source code in <code>onshape_robotics_toolkit/connect.py</code> <pre><code>def get_assembly_name(\n    self,\n    did: str,\n    wtype: str,\n    wid: str,\n    eid: str,\n    configuration: str = \"default\",\n) -&gt; Optional[str]:\n    \"\"\"\n    Get assembly name for a specified document / workspace / assembly.\n\n    Args:\n        did: The unique identifier of the document.\n        wtype: The type of workspace.\n        wid: The unique identifier of the workspace.\n        eid: The unique identifier of the assembly.\n        configuration: The configuration of the assembly.\n\n    Returns:\n        str: Assembly name\n\n    Examples:\n        &gt;&gt;&gt; assembly_name = client.get_assembly_name(\n        ...     did=\"a1c1addf75444f54b504f25c\",\n        ...     wtype=\"w\",\n        ...     wid=\"0d17b8ebb2a4c76be9fff3c7\",\n        ...     eid=\"a86aaf34d2f4353288df8812\"\n        ... )\n        &gt;&gt;&gt; print(assembly_name)\n        \"Assembly Name\"\n    \"\"\"\n    request_path = \"/api/metadata/d/\" + did + \"/\" + wtype + \"/\" + wid + \"/e/\" + eid\n    result_json = self.request(\n        HTTP.GET,\n        request_path,\n        query={\n            \"inferMetadataOwner\": \"false\",\n            \"includeComputedProperties\": \"false\",\n            \"includeComputedAssemblyProperties\": \"false\",\n            \"thumbnail\": \"false\",\n            \"configuration\": configuration,\n        },\n        log_response=False,\n    ).json()\n\n    name = None\n    try:\n        name = result_json[\"properties\"][0][\"value\"]\n        name = get_sanitized_name(name)\n\n    except KeyError:\n        logger.warning(f\"Assembly name not found for document: {did}\")\n\n    return name\n</code></pre>"},{"location":"api/connect/#onshape_robotics_toolkit.connect.Client.get_document_metadata","title":"<code>get_document_metadata(did)</code>","text":"<p>Get meta data for a specified document.</p> <p>Parameters:</p> Name Type Description Default <code>did</code> <code>str</code> <p>The unique identifier of the document.</p> required <p>Returns:</p> Type Description <code>DocumentMetaData</code> <p>Meta data for the specified document as a DocumentMetaData object or None if the document is not found</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; document_meta_data = client.get_document_metadata(\"document_id\n&gt;&gt;&gt; print(document_meta_data)\nDocumentMetaData(\n    defaultWorkspace=DefaultWorkspace(id=\"739221fb10c88c2bebb456e8\", type=\"workspace\"),\n    name=\"Document Name\",\n    id=\"a1c1addf75444f54b504f25c\"\n)\n</code></pre> Source code in <code>onshape_robotics_toolkit/connect.py</code> <pre><code>def get_document_metadata(self, did: str) -&gt; DocumentMetaData:\n    \"\"\"\n    Get meta data for a specified document.\n\n    Args:\n        did: The unique identifier of the document.\n\n    Returns:\n        Meta data for the specified document as a DocumentMetaData object or None if the document is not found\n\n    Examples:\n        &gt;&gt;&gt; document_meta_data = client.get_document_metadata(\"document_id\n        &gt;&gt;&gt; print(document_meta_data)\n        DocumentMetaData(\n            defaultWorkspace=DefaultWorkspace(id=\"739221fb10c88c2bebb456e8\", type=\"workspace\"),\n            name=\"Document Name\",\n            id=\"a1c1addf75444f54b504f25c\"\n        )\n    \"\"\"\n    if len(did) != 24:\n        raise ValueError(f\"Invalid document ID: {did}\")\n\n    res = self.request(HTTP.GET, \"/api/documents/\" + did)\n\n    if res.status_code == 404:\n        raise ValueError(f\"Document does not exist: {did}\")\n    elif res.status_code == 403:\n        raise ValueError(f\"Access forbidden for document: {did}\")\n\n    document = DocumentMetaData.model_validate(res.json())\n    document.name = get_sanitized_name(document.name)\n\n    return document\n</code></pre>"},{"location":"api/connect/#onshape_robotics_toolkit.connect.Client.get_elements","title":"<code>get_elements(did, wtype, wid)</code>","text":"<p>Get a list of all elements in a document.</p> <p>Parameters:</p> Name Type Description Default <code>did</code> <code>str</code> <p>The unique identifier of the document.</p> required <code>wtype</code> <code>str</code> <p>The type of workspace.</p> required <code>wid</code> <code>str</code> <p>The unique identifier of the workspace.</p> required <p>Returns:</p> Type Description <code>dict[str, Element]</code> <p>A dictionary of element name and Element object pairs.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; elements = client.get_elements(\n...     did=\"a1c1addf75444f54b504f25c\",\n...     wtype=\"w\",\n...     wid=\"0d17b8ebb2a4c76be9fff3c7\"\n... )\n&gt;&gt;&gt; print(elements)\n{\n    \"wheelAndFork\": Element(id='0b0c209535554345432581fe', name='wheelAndFork', elementType='PARTSTUDIO',\n                             microversionId='9b3be6165c7a2b1f6dd61305'),\n    \"frame\": Element(id='0b0c209535554345432581fe', name='frame', elementType='PARTSTUDIO',\n                     microversionId='9b3be6165c7a2b1f6dd61305')\n}\n</code></pre> Source code in <code>onshape_robotics_toolkit/connect.py</code> <pre><code>def get_elements(self, did: str, wtype: str, wid: str) -&gt; dict[str, Element]:\n    \"\"\"\n    Get a list of all elements in a document.\n\n    Args:\n        did: The unique identifier of the document.\n        wtype: The type of workspace.\n        wid: The unique identifier of the workspace.\n\n    Returns:\n        A dictionary of element name and Element object pairs.\n\n    Examples:\n        &gt;&gt;&gt; elements = client.get_elements(\n        ...     did=\"a1c1addf75444f54b504f25c\",\n        ...     wtype=\"w\",\n        ...     wid=\"0d17b8ebb2a4c76be9fff3c7\"\n        ... )\n        &gt;&gt;&gt; print(elements)\n        {\n            \"wheelAndFork\": Element(id='0b0c209535554345432581fe', name='wheelAndFork', elementType='PARTSTUDIO',\n                                     microversionId='9b3be6165c7a2b1f6dd61305'),\n            \"frame\": Element(id='0b0c209535554345432581fe', name='frame', elementType='PARTSTUDIO',\n                             microversionId='9b3be6165c7a2b1f6dd61305')\n        }\n    \"\"\"\n\n    # /documents/d/{did}/{wvm}/{wvmid}/elements\n    request_path = \"/api/documents/d/\" + did + \"/\" + wtype + \"/\" + wid + \"/elements\"\n    response = self.request(\n        HTTP.GET,\n        request_path,\n    )\n\n    if response.status_code == 404:\n        logger.error(f\"Elements not found for document: {did}\")\n        return {}\n\n    elif response.status_code == 403:\n        logger.error(f\"Access forbidden for document: {did}\")\n        return {}\n\n    return {element[\"name\"]: Element.model_validate(element) for element in response.json()}\n</code></pre>"},{"location":"api/connect/#onshape_robotics_toolkit.connect.Client.get_features","title":"<code>get_features(did, wtype, wid, eid)</code>","text":"<p>Get all assembly features</p> <p>Parameters:</p> Name Type Description Default <code>did</code> <code>str</code> <p>The unique identifier of the document.</p> required <code>wtype</code> <code>str</code> <p>The type of workspace.</p> required <code>wid</code> <code>str</code> <p>The unique identifier of the workspace.</p> required <code>eid</code> <code>str</code> <p>The unique identifier of the assembly.</p> required Source code in <code>onshape_robotics_toolkit/connect.py</code> <pre><code>def get_features(\n    self,\n    did: str,\n    wtype: str,\n    wid: str,\n    eid: str,\n) -&gt; Features:\n    \"\"\"\n    Get all assembly features\n\n    Args:\n        did: The unique identifier of the document.\n        wtype: The type of workspace.\n        wid: The unique identifier of the workspace.\n        eid: The unique identifier of the assembly.\n    \"\"\"\n    request_path = f\"/api/assemblies/d/{did}/{wtype}/{wid}/e/{eid}/features\"\n    response_json = self.request(HTTP.GET, request_path, log_response=True).json()\n    return Features.model_validate(response_json)\n</code></pre>"},{"location":"api/connect/#onshape_robotics_toolkit.connect.Client.get_mass_property","title":"<code>get_mass_property(did, wtype, wid, eid, partID)</code>","text":"<p>Get mass properties of a part in a part studio.</p> <p>Parameters:</p> Name Type Description Default <code>did</code> <code>str</code> <p>The unique identifier of the document.</p> required <code>wtype</code> <code>str</code> <p>The type of workspace.</p> required <code>wid</code> <code>str</code> <p>The unique identifier of the workspace.</p> required <code>eid</code> <code>str</code> <p>The unique identifier of the element.</p> required <code>partID</code> <code>str</code> <p>The identifier of the part.</p> required <p>Returns:</p> Type Description <code>MassProperties</code> <p>MassProperties object containing the mass properties of the part.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; mass_properties = client.get_mass_property(\n...     did=\"a1c1addf75444f54b504f25c\",\n...     wid=\"0d17b8ebb2a4c76be9fff3c7\",\n...     eid=\"a86aaf34d2f4353288df8812\",\n...     partID=\"0b0c209535554345432581fe\"\n...     wtype=\"w\"\n... )\n&gt;&gt;&gt; print(mass_properties)\nMassProperties(\n    volume=[0.003411385108378978, 0.003410724395374695, 0.0034120458213832646],\n    mass=[9.585992154544929, 9.584199206938452, 9.587785102151415],\n    centroid=[...],\n    inertia=[...],\n    principalInertia=[0.09944605933465941, 0.09944605954654827, 0.19238058837442526],\n    principalAxes=[...]\n)\n</code></pre> Source code in <code>onshape_robotics_toolkit/connect.py</code> <pre><code>def get_mass_property(\n    self,\n    did: str,\n    wtype: str,\n    wid: str,\n    eid: str,\n    partID: str,\n) -&gt; MassProperties:\n    \"\"\"\n    Get mass properties of a part in a part studio.\n\n    Args:\n        did: The unique identifier of the document.\n        wtype: The type of workspace.\n        wid: The unique identifier of the workspace.\n        eid: The unique identifier of the element.\n        partID: The identifier of the part.\n\n    Returns:\n        MassProperties object containing the mass properties of the part.\n\n    Examples:\n        &gt;&gt;&gt; mass_properties = client.get_mass_property(\n        ...     did=\"a1c1addf75444f54b504f25c\",\n        ...     wid=\"0d17b8ebb2a4c76be9fff3c7\",\n        ...     eid=\"a86aaf34d2f4353288df8812\",\n        ...     partID=\"0b0c209535554345432581fe\"\n        ...     wtype=\"w\"\n        ... )\n        &gt;&gt;&gt; print(mass_properties)\n        MassProperties(\n            volume=[0.003411385108378978, 0.003410724395374695, 0.0034120458213832646],\n            mass=[9.585992154544929, 9.584199206938452, 9.587785102151415],\n            centroid=[...],\n            inertia=[...],\n            principalInertia=[0.09944605933465941, 0.09944605954654827, 0.19238058837442526],\n            principalAxes=[...]\n        )\n    \"\"\"\n    # TODO: version id seems to always work, should this default behavior be changed?\n    request_path = f\"/api/parts/d/{did}/{wtype}/{wid}/e/{eid}/partid/{partID}/massproperties\"\n    res = self.request(HTTP.GET, request_path, {\"useMassPropertiesOverrides\": True}, log_response=False)\n\n    if res.status_code == 404:\n        # TODO: There doesn't seem to be a way to assign material to a part currently\n        # It is possible that the workspace got deleted\n        url = generate_url(\n            base_url=self._url,\n            did=did,\n            wtype=wtype,\n            wid=wid,\n            eid=eid,\n        )\n        raise ValueError(f\"Part: {url} does not have a material assigned or the part is not found\")\n\n    elif res.status_code == 429:\n        raise ValueError(f\"Too many requests, please retry after {res.headers['Retry-After']} seconds\")\n\n    resonse_json = res.json()\n\n    if \"bodies\" not in resonse_json:\n        raise KeyError(f\"Bodies not found in response, broken part? {partID}\")\n\n    return MassProperties.model_validate(resonse_json[\"bodies\"][partID])\n</code></pre>"},{"location":"api/connect/#onshape_robotics_toolkit.connect.Client.get_root_assembly","title":"<code>get_root_assembly(did, wtype, wid, eid, configuration='default', with_mass_properties=False, log_response=True, with_meta_data=True)</code>","text":"<p>Get root assembly data for a specified document / workspace / element.</p> <p>Parameters:</p> Name Type Description Default <code>did</code> <code>str</code> <p>The unique identifier of the document.</p> required <code>wtype</code> <code>str</code> <p>The type of workspace.</p> required <code>wid</code> <code>str</code> <p>The unique identifier of the workspace.</p> required <code>eid</code> <code>str</code> <p>The unique identifier of the element.</p> required <code>configuration</code> <code>str</code> <p>The configuration of the assembly.</p> <code>'default'</code> <code>with_mass_properties</code> <code>bool</code> <p>Whether to include mass properties in the assembly data.</p> <code>False</code> <code>log_response</code> <code>bool</code> <p>Log the response from the API request.</p> <code>True</code> <code>with_meta_data</code> <code>bool</code> <p>Whether to include meta data in the assembly data.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>RootAssembly</code> <code>RootAssembly</code> <p>RootAssembly object containing the root assembly data</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; root_assembly = client.get_root_assembly(\n...     did=\"a1c1addf75444f54b504f25c\",\n...     wtype=\"w\",\n...     wid=\"0d17b8ebb2a4c76be9fff3c7\",\n...     eid=\"a86aaf34d2f4353288df8812\",\n...     configuration=\"default\",\n...     with_mass_properties=True,\n...     log_response=False,\n...     with_meta_data=True\n... )\n&gt;&gt;&gt; print(root_assembly)\nRootAssembly(\n    instances=[...],\n    patterns=[...],\n    features=[...],\n    occurrences=[...],\n    fullConfiguration=\"default\",\n    configuration=\"default\",\n    documentId=\"a1c1addf75444f54b504f25c\",\n    elementId=\"0b0c209535554345432581fe\",\n    documentMicroversion=\"349f6413cafefe8fb4ab3b07\",\n)\n</code></pre> Source code in <code>onshape_robotics_toolkit/connect.py</code> <pre><code>def get_root_assembly(\n    self,\n    did: str,\n    wtype: str,\n    wid: str,\n    eid: str,\n    configuration: str = \"default\",\n    with_mass_properties: bool = False,\n    log_response: bool = True,\n    with_meta_data: bool = True,\n) -&gt; RootAssembly:\n    \"\"\"\n    Get root assembly data for a specified document / workspace / element.\n\n    Args:\n        did: The unique identifier of the document.\n        wtype: The type of workspace.\n        wid: The unique identifier of the workspace.\n        eid: The unique identifier of the element.\n        configuration: The configuration of the assembly.\n        with_mass_properties: Whether to include mass properties in the assembly data.\n        log_response: Log the response from the API request.\n        with_meta_data: Whether to include meta data in the assembly data.\n\n    Returns:\n        RootAssembly: RootAssembly object containing the root assembly data\n\n    Examples:\n        &gt;&gt;&gt; root_assembly = client.get_root_assembly(\n        ...     did=\"a1c1addf75444f54b504f25c\",\n        ...     wtype=\"w\",\n        ...     wid=\"0d17b8ebb2a4c76be9fff3c7\",\n        ...     eid=\"a86aaf34d2f4353288df8812\",\n        ...     configuration=\"default\",\n        ...     with_mass_properties=True,\n        ...     log_response=False,\n        ...     with_meta_data=True\n        ... )\n        &gt;&gt;&gt; print(root_assembly)\n        RootAssembly(\n            instances=[...],\n            patterns=[...],\n            features=[...],\n            occurrences=[...],\n            fullConfiguration=\"default\",\n            configuration=\"default\",\n            documentId=\"a1c1addf75444f54b504f25c\",\n            elementId=\"0b0c209535554345432581fe\",\n            documentMicroversion=\"349f6413cafefe8fb4ab3b07\",\n        )\n    \"\"\"\n    request_path = \"/api/assemblies/d/\" + did + \"/\" + wtype + \"/\" + wid + \"/e/\" + eid\n    res = self.request(\n        HTTP.GET,\n        request_path,\n        query={\n            \"includeMateFeatures\": \"true\",\n            \"includeMateConnectors\": \"true\",\n            \"includeNonSolids\": \"false\",\n            \"configuration\": configuration,\n        },\n        log_response=log_response,\n    )\n\n    if res.status_code == 401:\n        logger.warning(f\"Unauthorized access to document: {did}\")\n        logger.warning(\"Please check the API keys in your env file.\")\n        exit(1)\n\n    if res.status_code == 404:\n        logger.error(f\"Assembly not found: {did}\")\n        logger.error(\n            generate_url(\n                base_url=self._url,\n                did=did,\n                wtype=wtype,\n                wid=wid,\n                eid=eid,\n            )\n        )\n        exit(1)\n\n    assembly_json = res.json()\n    assembly = RootAssembly.model_validate(assembly_json[\"rootAssembly\"])\n\n    if with_mass_properties:\n        assembly.MassProperty = self.get_assembly_mass_properties(\n            did=did,\n            wid=wid,\n            eid=eid,\n            wtype=wtype,\n        )\n\n    if with_meta_data:\n        assembly.documentMetaData = self.get_document_metadata(did)\n\n    return assembly\n</code></pre>"},{"location":"api/connect/#onshape_robotics_toolkit.connect.Client.get_variables","title":"<code>get_variables(did, wid, eid)</code>","text":"<p>Get a list of variables in a variable studio within a document.</p> <p>Parameters:</p> Name Type Description Default <code>did</code> <code>str</code> <p>The unique identifier of the document.</p> required <code>wid</code> <code>str</code> <p>The unique identifier of the workspace.</p> required <code>eid</code> <code>str</code> <p>The unique identifier of the variable studio.</p> required <p>Returns:</p> Type Description <code>dict[str, Variable]</code> <p>A dictionary of variable name and Variable object pairs.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; variables = client.get_variables(\n...     did=\"a1c1addf75444f54b504f25c\",\n...     wid=\"0d17b8ebb2a4c76be9fff3c7\",\n...     eid=\"cba5e3ca026547f34f8d9f0f\"\n... )\n&gt;&gt;&gt; print(variables)\n{\n    \"forkAngle\": Variable(\n        type='ANGLE',\n        name='forkAngle',\n        value=None,\n        description='Fork angle for front wheel assembly in deg',\n        expression='15 deg'\n    )\n}\n</code></pre> Source code in <code>onshape_robotics_toolkit/connect.py</code> <pre><code>def get_variables(self, did: str, wid: str, eid: str) -&gt; dict[str, Variable]:\n    \"\"\"\n    Get a list of variables in a variable studio within a document.\n\n    Args:\n        did: The unique identifier of the document.\n        wid: The unique identifier of the workspace.\n        eid: The unique identifier of the variable studio.\n\n    Returns:\n        A dictionary of variable name and Variable object pairs.\n\n    Examples:\n        &gt;&gt;&gt; variables = client.get_variables(\n        ...     did=\"a1c1addf75444f54b504f25c\",\n        ...     wid=\"0d17b8ebb2a4c76be9fff3c7\",\n        ...     eid=\"cba5e3ca026547f34f8d9f0f\"\n        ... )\n        &gt;&gt;&gt; print(variables)\n        {\n            \"forkAngle\": Variable(\n                type='ANGLE',\n                name='forkAngle',\n                value=None,\n                description='Fork angle for front wheel assembly in deg',\n                expression='15 deg'\n            )\n        }\n    \"\"\"\n    request_path = \"/api/variables/d/\" + did + \"/w/\" + wid + \"/e/\" + eid + \"/variables\"\n\n    _variables_json = self.request(\n        HTTP.GET,\n        request_path,\n    ).json()\n\n    return {variable[\"name\"]: Variable.model_validate(variable) for variable in _variables_json[0][\"variables\"]}\n</code></pre>"},{"location":"api/connect/#onshape_robotics_toolkit.connect.Client.request","title":"<code>request(method, path, query=None, headers=None, body=None, base_url=None, log_response=True, timeout=50)</code>","text":"<p>Send a request to the Onshape API.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>HTTP</code> <p>HTTP method (GET, POST, DELETE)</p> required <code>path</code> <code>str</code> <p>URL path for the request</p> required <code>query</code> <code>Optional[dict[str, Any]]</code> <p>Query string in key-value pairs</p> <code>None</code> <code>headers</code> <code>Optional[dict[str, Any]]</code> <p>Additional headers for the request</p> <code>None</code> <code>body</code> <code>Optional[Union[dict[str, Any], list[dict[str, Any]]]]</code> <p>Body of the request</p> <code>None</code> <code>base_url</code> <code>Optional[str]</code> <p>Base URL for the request</p> <code>None</code> <code>log_response</code> <code>bool</code> <p>Log the response from the API request</p> <code>True</code> <code>timeout</code> <code>int</code> <p>Timeout for the request in seconds</p> <code>50</code> <p>Returns:     requests.Response: Response from the Onshape API request</p> Source code in <code>onshape_robotics_toolkit/connect.py</code> <pre><code>def request(\n    self,\n    method: HTTP,\n    path: str,\n    query: Optional[dict[str, Any]] = None,\n    headers: Optional[dict[str, Any]] = None,\n    body: Optional[Union[dict[str, Any], list[dict[str, Any]]]] = None,\n    base_url: Optional[str] = None,\n    log_response: bool = True,\n    timeout: int = 50,\n) -&gt; requests.Response:\n    \"\"\"\n    Send a request to the Onshape API.\n\n    Args:\n        method: HTTP method (GET, POST, DELETE)\n        path: URL path for the request\n        query: Query string in key-value pairs\n        headers: Additional headers for the request\n        body: Body of the request\n        base_url: Base URL for the request\n        log_response: Log the response from the API request\n        timeout: Timeout for the request in seconds\n    Returns:\n        requests.Response: Response from the Onshape API request\n    \"\"\"\n    if query is None:\n        query = {}\n    if headers is None:\n        headers = {}\n    if base_url is None:\n        base_url = self._url\n\n    req_headers = self._make_headers(method, path, query, headers)\n    url = self._build_url(base_url, path, query)\n\n    logger.debug(f\"Request body: {body}\")\n    logger.debug(f\"Request headers: {req_headers}\")\n    logger.debug(f\"Request URL: {url}\")\n\n    res = self._send_request(method, url, req_headers, body, timeout)\n\n    if res.status_code == 307:\n        return self._handle_redirect(res, method, headers, log_response)\n    else:\n        if log_response:\n            self._log_response(res)\n\n    # Increment API call counter for successful responses (2xx status codes)\n    if 200 &lt;= res.status_code &lt; 300:\n        self._api_call_count += 1\n\n    return res\n</code></pre>"},{"location":"api/connect/#onshape_robotics_toolkit.connect.Client.reset_api_call_count","title":"<code>reset_api_call_count()</code>","text":"<p>Reset the API call counter to zero.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; client.reset_api_call_count()\n&gt;&gt;&gt; client.api_call_count\n0\n</code></pre> Source code in <code>onshape_robotics_toolkit/connect.py</code> <pre><code>def reset_api_call_count(self) -&gt; None:\n    \"\"\"\n    Reset the API call counter to zero.\n\n    Examples:\n        &gt;&gt;&gt; client.reset_api_call_count()\n        &gt;&gt;&gt; client.api_call_count\n        0\n    \"\"\"\n    self._api_call_count = 0\n    logger.info(\"API call counter reset to 0\")\n</code></pre>"},{"location":"api/connect/#onshape_robotics_toolkit.connect.Client.set_base_url","title":"<code>set_base_url(base_url)</code>","text":"<p>Set the base URL for the Onshape API.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>Base URL for the Onshape API</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; client.set_base_url(\"https://cad.onshape.com\")\n</code></pre> Source code in <code>onshape_robotics_toolkit/connect.py</code> <pre><code>def set_base_url(self, base_url: str) -&gt; None:\n    \"\"\"\n    Set the base URL for the Onshape API.\n\n    Args:\n        base_url: Base URL for the Onshape API\n\n    Examples:\n        &gt;&gt;&gt; client.set_base_url(\"https://cad.onshape.com\")\n    \"\"\"\n    self._url = base_url\n</code></pre>"},{"location":"api/connect/#onshape_robotics_toolkit.connect.Client.set_variables","title":"<code>set_variables(did, wid, eid, variables)</code>","text":"<p>Set values for variables of a variable studio in a document.</p> <p>Parameters:</p> Name Type Description Default <code>did</code> <code>str</code> <p>The unique identifier of the document.</p> required <code>wid</code> <code>str</code> <p>The unique identifier of the workspace.</p> required <code>eid</code> <code>str</code> <p>The unique identifier of the variable studio.</p> required <code>variables</code> <code>dict[str, str]</code> <p>A dictionary of variable name and expression pairs.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>requests.Response: Response from Onshape API after setting the variables.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; variables = {\n...     \"forkAngle\": \"15 deg\",\n...     \"wheelRadius\": \"0.5 m\"\n... }\n&gt;&gt;&gt; client.set_variables(\n...     did=\"a1c1addf75444f54b504f25c\",\n...     wid=\"0d17b8ebb2a4c76be9fff3c7\",\n...     eid=\"cba5e3ca026547f34f8d9f0f\",\n...     variables=variables\n... )\n&lt;Response [200]&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/connect.py</code> <pre><code>def set_variables(self, did: str, wid: str, eid: str, variables: dict[str, str]) -&gt; requests.Response:\n    \"\"\"\n    Set values for variables of a variable studio in a document.\n\n    Args:\n        did: The unique identifier of the document.\n        wid: The unique identifier of the workspace.\n        eid: The unique identifier of the variable studio.\n        variables: A dictionary of variable name and expression pairs.\n\n    Returns:\n        requests.Response: Response from Onshape API after setting the variables.\n\n    Examples:\n        &gt;&gt;&gt; variables = {\n        ...     \"forkAngle\": \"15 deg\",\n        ...     \"wheelRadius\": \"0.5 m\"\n        ... }\n        &gt;&gt;&gt; client.set_variables(\n        ...     did=\"a1c1addf75444f54b504f25c\",\n        ...     wid=\"0d17b8ebb2a4c76be9fff3c7\",\n        ...     eid=\"cba5e3ca026547f34f8d9f0f\",\n        ...     variables=variables\n        ... )\n        &lt;Response [200]&gt;\n    \"\"\"\n\n    payload = [{\"name\": name, \"expression\": expression} for name, expression in variables.items()]\n\n    # api/v9/variables/d/a1c1addf75444f54b504f25c/w/0d17b8ebb2a4c76be9fff3c7/e/cba5e3ca026547f34f8d9f0f/variables\n    request_path = \"/api/variables/d/\" + did + \"/w/\" + wid + \"/e/\" + eid + \"/variables\"\n\n    response = self.request(\n        HTTP.POST,\n        request_path,\n        body=payload,\n    )\n\n    record_variable_update(element_id=eid, expressions=variables)\n\n    return response\n</code></pre>"},{"location":"api/connect/#onshape_robotics_toolkit.connect.HTTP","title":"<code>HTTP</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enumerates the possible HTTP methods.</p> <p>Attributes:</p> Name Type Description <code>GET</code> <code>str</code> <p>HTTP GET method</p> <code>POST</code> <code>str</code> <p>HTTP POST method</p> <code>DELETE</code> <code>str</code> <p>HTTP DELETE method</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; HTTP.GET\n'get'\n&gt;&gt;&gt; HTTP.POST\n'post'\n</code></pre> Source code in <code>onshape_robotics_toolkit/connect.py</code> <pre><code>class HTTP(str, Enum):\n    \"\"\"\n    Enumerates the possible HTTP methods.\n\n    Attributes:\n        GET (str): HTTP GET method\n        POST (str): HTTP POST method\n        DELETE (str): HTTP DELETE method\n\n    Examples:\n        &gt;&gt;&gt; HTTP.GET\n        'get'\n        &gt;&gt;&gt; HTTP.POST\n        'post'\n    \"\"\"\n\n    GET = \"get\"\n    POST = \"post\"\n    DELETE = \"delete\"\n</code></pre>"},{"location":"api/connect/#onshape_robotics_toolkit.connect.load_env_variables","title":"<code>load_env_variables(env)</code>","text":"<p>Load access and secret keys required for Onshape API requests.</p> <p>Parameters:</p> Name Type Description Default <code>env</code> <code>Union[str, None]</code> <p>Path to the environment file containing the access and secret keys. If <code>None</code>, the environment variables are loaded from the system environment with <code>os.getenv</code>. If <code>not None</code>, the environment variables are loaded from the file with <code>dotenv.get_key</code>.</p> required <p>Returns:</p> Type Description <code>tuple[str, str]</code> <p>tuple[str, str]: Access and secret keys</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the environment file is not found</p> <code>ValueError</code> <p>If the required environment variables are missing</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; load_env_variables(\".env\")\n('asdagflkdfjsdlfkdfjlsdf', 'asdkkjdnknsdgkjsdguoiuosdg')\n</code></pre> Source code in <code>onshape_robotics_toolkit/connect.py</code> <pre><code>def load_env_variables(env: Union[str, None]) -&gt; tuple[str, str]:\n    \"\"\"Load access and secret keys required for Onshape API requests.\n\n    Args:\n        env: Path to the environment file containing the access and secret keys. If\n            `None`, the environment variables are loaded from the system environment\n            with `os.getenv`. If `not None`, the environment variables are loaded from\n            the file with `dotenv.get_key`.\n\n    Returns:\n        tuple[str, str]: Access and secret keys\n\n    Raises:\n        FileNotFoundError: If the environment file is not found\n        ValueError: If the required environment variables are missing\n\n    Examples:\n        &gt;&gt;&gt; load_env_variables(\".env\")\n        ('asdagflkdfjsdlfkdfjlsdf', 'asdkkjdnknsdgkjsdguoiuosdg')\n    \"\"\"\n\n    if env is not None:\n        return (load_key_from_dotenv(env, ONSHAPE_KEY_NAMES[0]), load_key_from_dotenv(env, ONSHAPE_KEY_NAMES[1]))\n    else:\n        return (load_key_from_environment(ONSHAPE_KEY_NAMES[0]), load_key_from_environment(ONSHAPE_KEY_NAMES[1]))\n</code></pre>"},{"location":"api/connect/#onshape_robotics_toolkit.connect.make_nonce","title":"<code>make_nonce()</code>","text":"<p>Generate a unique ID for the request, 25 chars in length</p> <p>Returns:</p> Type Description <code>str</code> <p>Cryptographic nonce string for the API request</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; make_nonce()\n'a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p'\n</code></pre> Source code in <code>onshape_robotics_toolkit/connect.py</code> <pre><code>def make_nonce() -&gt; str:\n    \"\"\"\n    Generate a unique ID for the request, 25 chars in length\n\n    Returns:\n        Cryptographic nonce string for the API request\n\n    Examples:\n        &gt;&gt;&gt; make_nonce()\n        'a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p'\n    \"\"\"\n\n    chars = string.digits + string.ascii_letters\n    nonce = \"\".join(secrets.choice(chars) for i in range(25))\n    logger.debug(f\"nonce created: {nonce}\")\n\n    return nonce\n</code></pre>"},{"location":"api/document/","title":"Document","text":"<p>This module defines data models for Onshape document, workspace, element, and other related entities retrieved from Onshape REST API responses.</p> <p>The data models are implemented as Pydantic BaseModel classes, which are used to</p> <pre><code>1. Parse JSON responses from the API into Python objects.\n2. Validate the structure and types of the JSON responses.\n3. Provide type hints for better code clarity and autocompletion.\n</code></pre> <p>These models ensure that the data received from the API adheres to the expected format and types, facilitating easier and safer manipulation of the data within the application.</p> Models <ul> <li>Document: Represents an Onshape document, containing the document ID, workspace type, workspace ID,   and element ID.</li> <li>DocumentMetaData: Represents metadata of an Onshape document, containing the default workspace   information and name.</li> </ul> Supplementary models <ul> <li>DefaultWorkspace: Represents the default workspace of an Onshape document, containing the   workspace ID and type.</li> </ul> Enum <ul> <li>WorkspaceType: Enumerates the possible workspace types in Onshape (w, v, m).</li> <li>MetaWorkspaceType: Enumerates the possible meta workspace types in Onshape (workspace,   version, microversion).</li> </ul>"},{"location":"api/document/#onshape_robotics_toolkit.models.document.DefaultWorkspace","title":"<code>DefaultWorkspace</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents the default workspace of an Onshape document, containing the workspace ID and type.</p> JSON <pre><code>{\n    \"id\": \"739221fb10c88c2bebb456e8\"\n    \"type\": \"workspace\"\n}\n</code></pre> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>The unique identifier of the workspace</p> <code>type</code> <code>MetaWorkspaceType</code> <p>The type of workspace (workspace, version, microversion)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; DefaultWorkspace(id=\"739221fb10c88c2bebb456e8\", type=\"workspace\")\nDefaultWorkspace(id=\"739221fb10c88c2bebb456e8\", type=\"workspace\")\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/document.py</code> <pre><code>class DefaultWorkspace(BaseModel):\n    \"\"\"\n    Represents the default workspace of an Onshape document, containing the workspace ID and type.\n\n    JSON:\n        ```json\n        {\n            \"id\": \"739221fb10c88c2bebb456e8\"\n            \"type\": \"workspace\"\n        }\n        ```\n\n    Attributes:\n        id: The unique identifier of the workspace\n        type: The type of workspace (workspace, version, microversion)\n\n    Examples:\n        &gt;&gt;&gt; DefaultWorkspace(id=\"739221fb10c88c2bebb456e8\", type=\"workspace\")\n        DefaultWorkspace(id=\"739221fb10c88c2bebb456e8\", type=\"workspace\")\n    \"\"\"\n\n    id: str = Field(..., description=\"The unique identifier of the workspace\")\n    type: MetaWorkspaceType = Field(..., description=\"The type of workspace (workspace, version, microversion)\")\n</code></pre>"},{"location":"api/document/#onshape_robotics_toolkit.models.document.Document","title":"<code>Document</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents an Onshape document, containing the document ID, workspace type, workspace ID, and element ID.</p> <p>Attributes:</p> Name Type Description <code>url</code> <code>Union[str, None]</code> <p>URL to the document element</p> <code>did</code> <code>str</code> <p>The unique identifier of the document</p> <code>wtype</code> <code>str</code> <p>The type of workspace (w, v, m)</p> <code>wid</code> <code>str</code> <p>The unique identifier of the workspace</p> <code>eid</code> <code>str</code> <p>The unique identifier of the element</p> <code>name</code> <code>Union[str, None]</code> <p>The name of the document</p> <p>Methods:</p> Name Description <code>from_url</code> <p>Create a Document instance from an Onshape URL</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Document(\n...     url=\"https://cad.onshape.com/documents/a1c1addf75444f54b504f25c/w/0d17b8ebb2a4c76be9fff3c7/e/a86aaf34d2f4353288df8812\",\n...     did=\"a1c1addf75444f54b504f25c\",\n...     wtype=\"w\",\n...     wid=\"0d17b8ebb2a4c76be9fff3c7\",\n...     eid=\"a86aaf34d2f4353288df8812\"\n... )\nDocument(\n    url=\"https://cad.onshape.com/documents/a1c1addf75444f54b504f25c/w/0d17b8ebb2a4c76be9fff3c7/e/a86aaf34d2f4353288df8812\",\n    did=\"a1c1addf75444f54b504f25c\",\n    wtype=\"w\",\n    wid=\"0d17b8ebb2a4c76be9fff3c7\",\n    eid=\"a86aaf34d2f4353288df8812\"\n)\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/document.py</code> <pre><code>class Document(BaseModel):\n    \"\"\"\n    Represents an Onshape document, containing the document ID, workspace type, workspace ID, and element ID.\n\n    Attributes:\n        url: URL to the document element\n        did: The unique identifier of the document\n        wtype: The type of workspace (w, v, m)\n        wid: The unique identifier of the workspace\n        eid: The unique identifier of the element\n        name: The name of the document\n\n    Methods:\n        from_url: Create a Document instance from an Onshape URL\n\n    Examples:\n        &gt;&gt;&gt; Document(\n        ...     url=\"https://cad.onshape.com/documents/a1c1addf75444f54b504f25c/w/0d17b8ebb2a4c76be9fff3c7/e/a86aaf34d2f4353288df8812\",\n        ...     did=\"a1c1addf75444f54b504f25c\",\n        ...     wtype=\"w\",\n        ...     wid=\"0d17b8ebb2a4c76be9fff3c7\",\n        ...     eid=\"a86aaf34d2f4353288df8812\"\n        ... )\n        Document(\n            url=\"https://cad.onshape.com/documents/a1c1addf75444f54b504f25c/w/0d17b8ebb2a4c76be9fff3c7/e/a86aaf34d2f4353288df8812\",\n            did=\"a1c1addf75444f54b504f25c\",\n            wtype=\"w\",\n            wid=\"0d17b8ebb2a4c76be9fff3c7\",\n            eid=\"a86aaf34d2f4353288df8812\"\n        )\n    \"\"\"\n\n    url: Union[str, None] = Field(None, description=\"URL to the document element\")\n    base_url: str = Field(BASE_URL, description=\"Base URL of the document\")\n    did: str = Field(..., description=\"The unique identifier of the document\")\n    wtype: str = Field(..., description=\"The type of workspace (w, v, m)\")\n    wid: str = Field(..., description=\"The unique identifier of the workspace\")\n    eid: str = Field(..., description=\"The unique identifier of the element\")\n    name: Union[str, None] = Field(None, description=\"The name of the document\")\n\n    def __init__(self, **data: Any):\n        super().__init__(**data)\n        if self.url is None:\n            self.url = generate_url(self.base_url, self.did, self.wtype, self.wid, self.eid)\n\n    @field_validator(\"did\", \"wid\", \"eid\")\n    def check_ids(cls, value: str) -&gt; str:\n        \"\"\"\n        Validate the document, workspace, and element IDs\n\n        Args:\n            value: The ID to validate\n\n        Returns:\n            value: The validated ID\n\n        Raises:\n            ValueError: If the ID is empty or not 24 characters long\n        \"\"\"\n        if not value:\n            raise ValueError(\"ID cannot be empty, please check the URL\")\n        if not len(value) == 24:\n            raise ValueError(\"ID must be 24 characters long, please check the URL\")\n        return value\n\n    @field_validator(\"wtype\")\n    def check_wtype(cls, value: str) -&gt; str:\n        \"\"\"\n        Validate the workspace type\n\n        Args:\n            value: The workspace type to validate\n\n        Returns:\n            value: The validated workspace type\n\n        Raises:\n            ValueError: If the workspace type is empty or not one of the valid values\n        \"\"\"\n        if not value:\n            raise ValueError(\"Workspace type cannot be empty, please check the URL\")\n\n        if value not in WorkspaceType.__members__.values():\n            raise ValueError(\n                f\"Invalid workspace type. Must be one of {WorkspaceType.__members__.values()}, please check the URL\"\n            )\n\n        return value\n\n    @classmethod\n    def from_url(cls, url: str) -&gt; \"Document\":\n        \"\"\"\n        Create a Document instance from an Onshape URL\n\n        Args:\n            url: URL to the document element\n\n        Returns:\n            Document: The Document instance created from the URL\n\n        Raises:\n            ValueError: If the URL does not match the expected pattern\n\n        Examples:\n            &gt;&gt;&gt; Document.from_url(\n            ...     \"https://cad.onshape.com/documents/a1c1addf75444f54b504f25c/w/0d17b8ebb2a4c76be9fff3c7/e/a86aaf34d2f4353288df8812\"\n            ... )\n            Document(\n                url=\"https://cad.onshape.com/documents/a1c1addf75444f54b504f25c/w/0d17b8ebb2a4c76be9fff3c7/e/a86aaf34d2f4353288df8812\",\n                base_url=\"https://cad.onshape.com\",\n                did=\"a1c1addf75444f54b504f25c\",\n                wtype=\"w\",\n                wid=\"0d17b8ebb2a4c76be9fff3c7\",\n                eid=\"a86aaf34d2f4353288df8812\"\n            )\n        \"\"\"\n        base_url, did, wtype, wid, eid = parse_url(url)\n        return cls(url=url, base_url=base_url, did=did, wtype=wtype, wid=wid, eid=eid)\n</code></pre>"},{"location":"api/document/#onshape_robotics_toolkit.models.document.Document.check_ids","title":"<code>check_ids(value)</code>","text":"<p>Validate the document, workspace, and element IDs</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The ID to validate</p> required <p>Returns:</p> Name Type Description <code>value</code> <code>str</code> <p>The validated ID</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the ID is empty or not 24 characters long</p> Source code in <code>onshape_robotics_toolkit/models/document.py</code> <pre><code>@field_validator(\"did\", \"wid\", \"eid\")\ndef check_ids(cls, value: str) -&gt; str:\n    \"\"\"\n    Validate the document, workspace, and element IDs\n\n    Args:\n        value: The ID to validate\n\n    Returns:\n        value: The validated ID\n\n    Raises:\n        ValueError: If the ID is empty or not 24 characters long\n    \"\"\"\n    if not value:\n        raise ValueError(\"ID cannot be empty, please check the URL\")\n    if not len(value) == 24:\n        raise ValueError(\"ID must be 24 characters long, please check the URL\")\n    return value\n</code></pre>"},{"location":"api/document/#onshape_robotics_toolkit.models.document.Document.check_wtype","title":"<code>check_wtype(value)</code>","text":"<p>Validate the workspace type</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The workspace type to validate</p> required <p>Returns:</p> Name Type Description <code>value</code> <code>str</code> <p>The validated workspace type</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the workspace type is empty or not one of the valid values</p> Source code in <code>onshape_robotics_toolkit/models/document.py</code> <pre><code>@field_validator(\"wtype\")\ndef check_wtype(cls, value: str) -&gt; str:\n    \"\"\"\n    Validate the workspace type\n\n    Args:\n        value: The workspace type to validate\n\n    Returns:\n        value: The validated workspace type\n\n    Raises:\n        ValueError: If the workspace type is empty or not one of the valid values\n    \"\"\"\n    if not value:\n        raise ValueError(\"Workspace type cannot be empty, please check the URL\")\n\n    if value not in WorkspaceType.__members__.values():\n        raise ValueError(\n            f\"Invalid workspace type. Must be one of {WorkspaceType.__members__.values()}, please check the URL\"\n        )\n\n    return value\n</code></pre>"},{"location":"api/document/#onshape_robotics_toolkit.models.document.Document.from_url","title":"<code>from_url(url)</code>  <code>classmethod</code>","text":"<p>Create a Document instance from an Onshape URL</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to the document element</p> required <p>Returns:</p> Name Type Description <code>Document</code> <code>Document</code> <p>The Document instance created from the URL</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the URL does not match the expected pattern</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Document.from_url(\n...     \"https://cad.onshape.com/documents/a1c1addf75444f54b504f25c/w/0d17b8ebb2a4c76be9fff3c7/e/a86aaf34d2f4353288df8812\"\n... )\nDocument(\n    url=\"https://cad.onshape.com/documents/a1c1addf75444f54b504f25c/w/0d17b8ebb2a4c76be9fff3c7/e/a86aaf34d2f4353288df8812\",\n    base_url=\"https://cad.onshape.com\",\n    did=\"a1c1addf75444f54b504f25c\",\n    wtype=\"w\",\n    wid=\"0d17b8ebb2a4c76be9fff3c7\",\n    eid=\"a86aaf34d2f4353288df8812\"\n)\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/document.py</code> <pre><code>@classmethod\ndef from_url(cls, url: str) -&gt; \"Document\":\n    \"\"\"\n    Create a Document instance from an Onshape URL\n\n    Args:\n        url: URL to the document element\n\n    Returns:\n        Document: The Document instance created from the URL\n\n    Raises:\n        ValueError: If the URL does not match the expected pattern\n\n    Examples:\n        &gt;&gt;&gt; Document.from_url(\n        ...     \"https://cad.onshape.com/documents/a1c1addf75444f54b504f25c/w/0d17b8ebb2a4c76be9fff3c7/e/a86aaf34d2f4353288df8812\"\n        ... )\n        Document(\n            url=\"https://cad.onshape.com/documents/a1c1addf75444f54b504f25c/w/0d17b8ebb2a4c76be9fff3c7/e/a86aaf34d2f4353288df8812\",\n            base_url=\"https://cad.onshape.com\",\n            did=\"a1c1addf75444f54b504f25c\",\n            wtype=\"w\",\n            wid=\"0d17b8ebb2a4c76be9fff3c7\",\n            eid=\"a86aaf34d2f4353288df8812\"\n        )\n    \"\"\"\n    base_url, did, wtype, wid, eid = parse_url(url)\n    return cls(url=url, base_url=base_url, did=did, wtype=wtype, wid=wid, eid=eid)\n</code></pre>"},{"location":"api/document/#onshape_robotics_toolkit.models.document.DocumentMetaData","title":"<code>DocumentMetaData</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents metadata of an Onshape document, containing the default workspace information and name.</p> JSON <pre><code>{\n    \"defaultWorkspace\": {\n        \"id\": \"739221fb10c88c2bebb456e8\",\n        \"type\": \"workspace\"\n    },\n    \"name\": \"Document Name\",\n    \"id\": \"a1c1addf75444f54b504f25c\"\n}\n</code></pre> <p>Attributes:</p> Name Type Description <code>defaultWorkspace</code> <code>DefaultWorkspace</code> <p>Default workspace information</p> <code>name</code> <code>str</code> <p>The name of the document</p> <code>id</code> <code>str</code> <p>The unique identifier of the document</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; DocumentMetaData(\n...     defaultWorkspace=DefaultWorkspace(id=\"739221fb10c88c2bebb456e8\", type=\"workspace\"),\n...     name=\"Document Name\",\n...     id=\"a1c1addf75444f54b504f25c\"\n... )\nDocumentMetaData(\n    defaultWorkspace=DefaultWorkspace(id=\"739221fb10c88c2bebb456e8\", type=\"workspace\"),\n    name=\"Document Name\",\n    id=\"a1c1addf75444f54b504f25c\"\n)\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/document.py</code> <pre><code>class DocumentMetaData(BaseModel):\n    \"\"\"\n    Represents metadata of an Onshape document, containing the default workspace information and name.\n\n    JSON:\n        ```json\n        {\n            \"defaultWorkspace\": {\n                \"id\": \"739221fb10c88c2bebb456e8\",\n                \"type\": \"workspace\"\n            },\n            \"name\": \"Document Name\",\n            \"id\": \"a1c1addf75444f54b504f25c\"\n        }\n        ```\n\n    Attributes:\n        defaultWorkspace: Default workspace information\n        name: The name of the document\n        id: The unique identifier of the document\n\n    Examples:\n        &gt;&gt;&gt; DocumentMetaData(\n        ...     defaultWorkspace=DefaultWorkspace(id=\"739221fb10c88c2bebb456e8\", type=\"workspace\"),\n        ...     name=\"Document Name\",\n        ...     id=\"a1c1addf75444f54b504f25c\"\n        ... )\n        DocumentMetaData(\n            defaultWorkspace=DefaultWorkspace(id=\"739221fb10c88c2bebb456e8\", type=\"workspace\"),\n            name=\"Document Name\",\n            id=\"a1c1addf75444f54b504f25c\"\n        )\n    \"\"\"\n\n    defaultWorkspace: DefaultWorkspace = Field(..., description=\"Default workspace information\")\n    name: str = Field(..., description=\"The name of the document\")\n    id: str = Field(..., description=\"The unique identifier of the document\")\n</code></pre>"},{"location":"api/document/#onshape_robotics_toolkit.models.document.MetaWorkspaceType","title":"<code>MetaWorkspaceType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enumerates the possible meta workspace types in Onshape</p> <p>Attributes:</p> Name Type Description <code>WORKSPACE</code> <p>workspace</p> <code>VERSION</code> <p>version</p> <code>MICROVERSION</code> <p>microversion</p> Properties <p>shorthand: Shorthand representation of the meta workspace type (first letter)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; MetaWorkspaceType.WORKSPACE.shorthand\n\"w\"\n&gt;&gt;&gt; MetaWorkspaceType.VERSION\n\"version\"\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/document.py</code> <pre><code>class MetaWorkspaceType(str, Enum):\n    \"\"\"\n    Enumerates the possible meta workspace types in Onshape\n\n    Attributes:\n        WORKSPACE: workspace\n        VERSION: version\n        MICROVERSION: microversion\n\n    Properties:\n        shorthand: Shorthand representation of the meta workspace type (first letter)\n\n    Examples:\n        &gt;&gt;&gt; MetaWorkspaceType.WORKSPACE.shorthand\n        \"w\"\n        &gt;&gt;&gt; MetaWorkspaceType.VERSION\n        \"version\"\n    \"\"\"\n\n    WORKSPACE = \"workspace\"\n    VERSION = \"version\"\n    MICROVERSION = \"microversion\"\n\n    @property\n    def shorthand(self) -&gt; str:\n        return self.value[0]\n</code></pre>"},{"location":"api/document/#onshape_robotics_toolkit.models.document.WorkspaceType","title":"<code>WorkspaceType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enumerates the possible workspace types in Onshape</p> <p>Attributes:</p> Name Type Description <code>W</code> <code>str</code> <p>Workspace</p> <code>V</code> <code>str</code> <p>Version</p> <code>M</code> <code>str</code> <p>Microversion</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; WorkspaceType.W\n\"w\"\n&gt;&gt;&gt; WorkspaceType.M\n\"m\"\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/document.py</code> <pre><code>class WorkspaceType(str, Enum):\n    \"\"\"\n    Enumerates the possible workspace types in Onshape\n\n    Attributes:\n        W (str): Workspace\n        V (str): Version\n        M (str): Microversion\n\n    Examples:\n        &gt;&gt;&gt; WorkspaceType.W\n        \"w\"\n        &gt;&gt;&gt; WorkspaceType.M\n        \"m\"\n    \"\"\"\n\n    W = \"w\"\n    V = \"v\"\n    M = \"m\"\n</code></pre>"},{"location":"api/document/#onshape_robotics_toolkit.models.document.generate_url","title":"<code>generate_url(base_url, did, wtype, wid, eid)</code>","text":"<p>Generate Onshape URL from document ID, workspace type, workspace ID, and element ID</p> <p>Parameters:</p> Name Type Description Default <code>did</code> <code>str</code> <p>The unique identifier of the document</p> required <code>wtype</code> <code>str</code> <p>The type of workspace (w, v, m)</p> required <code>wid</code> <code>str</code> <p>The unique identifier of the workspace</p> required <code>eid</code> <code>str</code> <p>The unique identifier of the element</p> required <p>Returns:</p> Name Type Description <code>url</code> <code>str</code> <p>URL to the Onshape document element</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; generate_url(\"a1c1addf75444f54b504f25c\", \"w\", \"0d17b8ebb2a4c76be9fff3c7\", \"a86aaf34d2f4353288df8812\")\n\"https://cad.onshape.com/documents/a1c1addf75444f54b504f25c/w/0d17b8ebb2a4c76be9fff3c7/e/a86aaf34d2f4353288df8812\"\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/document.py</code> <pre><code>def generate_url(base_url: str, did: str, wtype: str, wid: str, eid: str) -&gt; str:\n    \"\"\"\n    Generate Onshape URL from document ID, workspace type, workspace ID, and element ID\n\n    Args:\n        did: The unique identifier of the document\n        wtype: The type of workspace (w, v, m)\n        wid: The unique identifier of the workspace\n        eid: The unique identifier of the element\n\n    Returns:\n        url: URL to the Onshape document element\n\n    Examples:\n        &gt;&gt;&gt; generate_url(\"a1c1addf75444f54b504f25c\", \"w\", \"0d17b8ebb2a4c76be9fff3c7\", \"a86aaf34d2f4353288df8812\")\n        \"https://cad.onshape.com/documents/a1c1addf75444f54b504f25c/w/0d17b8ebb2a4c76be9fff3c7/e/a86aaf34d2f4353288df8812\"\n    \"\"\"\n    return f\"{base_url}/documents/{did}/{wtype}/{wid}/e/{eid}\"\n</code></pre>"},{"location":"api/document/#onshape_robotics_toolkit.models.document.parse_url","title":"<code>parse_url(url)</code>","text":"<p>Parse Onshape URL and return document ID, workspace type, workspace ID, and element ID</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to an Onshape document element</p> required <p>Returns:</p> Type Description <code>tuple[str, str, WorkspaceType, str, str]</code> <p>Tuple containing: - base_url: The base URL - did: The unique identifier of the document - wtype: The type of workspace (w, v, m) - wid: The unique identifier of the workspace - eid: The unique identifier of the element</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the URL does not match the expected pattern</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; parse_url(\"https://cad.onshape.com/documents/a1c1addf75444f54b504f25c/w/0d17b8ebb2a4c76be9fff3c7/e/a86aaf34d2f4353288df8812\")\n(\"https://cad.onshape.com\", \"a1c1addf75444f54b504f25c\", \"w\",\n \"0d17b8ebb2a4c76be9fff3c7\", \"a86aaf34d2f4353288df8812\")\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/document.py</code> <pre><code>def parse_url(url: str) -&gt; tuple[str, str, WorkspaceType, str, str]:\n    \"\"\"\n    Parse Onshape URL and return document ID, workspace type, workspace ID, and element ID\n\n    Args:\n        url: URL to an Onshape document element\n\n    Returns:\n        Tuple containing:\n            - base_url: The base URL\n            - did: The unique identifier of the document\n            - wtype: The type of workspace (w, v, m)\n            - wid: The unique identifier of the workspace\n            - eid: The unique identifier of the element\n\n    Raises:\n        ValueError: If the URL does not match the expected pattern\n\n    Examples:\n        &gt;&gt;&gt; parse_url(\"https://cad.onshape.com/documents/a1c1addf75444f54b504f25c/w/0d17b8ebb2a4c76be9fff3c7/e/a86aaf34d2f4353288df8812\")\n        (\"https://cad.onshape.com\", \"a1c1addf75444f54b504f25c\", \"w\",\n         \"0d17b8ebb2a4c76be9fff3c7\", \"a86aaf34d2f4353288df8812\")\n    \"\"\"\n    pattern = re.match(\n        DOCUMENT_PATTERN,\n        url,\n    )\n\n    if not pattern:\n        raise ValueError(\"Invalid Onshape URL\")\n\n    base_url = pattern.group(1)\n    did = pattern.group(2)\n    wtype = cast(WorkspaceType, pattern.group(3))\n    wid = pattern.group(4)\n    eid = pattern.group(5)\n\n    return base_url, did, wtype, wid, eid\n</code></pre>"},{"location":"api/element/","title":"Element","text":"<p>This module defines data model for elements retrieved from Onshape REST API responses.</p> <p>The data models are implemented as Pydantic BaseModel classes, which are used to</p> <pre><code>1. Parse JSON responses from the API into Python objects.\n2. Validate the structure and types of the JSON responses.\n3. Provide type hints for better code clarity and autocompletion.\n</code></pre> <p>These models ensure that the data received from the API adheres to the expected format and types, facilitating easier and safer manipulation of the data within the application.</p> Models <ul> <li>Element: Represents an Onshape element, containing the element ID, name, type, and microversion ID.</li> </ul> Enum <ul> <li>ElementType: Enumerates the possible element types in Onshape (PARTSTUDIO, ASSEMBLY, DRAWING, etc.).</li> </ul>"},{"location":"api/element/#onshape_robotics_toolkit.models.element.Element","title":"<code>Element</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents an Onshape element, containing the element ID, name, type, and microversion ID.</p> JSON <pre><code>    {\n        \"name\": \"wheelAndFork\",\n        \"id\": \"0b0c209535554345432581fe\",\n        \"type\": \"Part Studio\",\n        \"elementType\": \"PARTSTUDIO\",\n        \"dataType\": \"onshape/partstudio\",\n        \"microversionId\": \"9b3be6165c7a2b1f6dd61305\",\n        \"lengthUnits\": \"millimeter\",\n        \"angleUnits\": \"degree\",\n        \"massUnits\": \"kilogram\",\n        \"timeUnits\": \"second\",\n        \"forceUnits\": \"newton\",\n        \"pressureUnits\": \"pascal\",\n        \"momentUnits\": \"newtonMeter\",\n        \"accelerationUnits\": \"meterPerSecondSquared\",\n        \"angularVelocityUnits\": \"degreePerSecond\",\n        \"energyUnits\": \"footPoundForce\",\n        \"areaUnits\": \"squareMillimeter\",\n        \"volumeUnits\": \"cubicMillimeter\",\n    }\n</code></pre> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>The unique identifier of the element.</p> <code>name</code> <code>str</code> <p>The name of the element.</p> <code>elementType</code> <code>str</code> <p>The type of the element (e.g., PARTSTUDIO, ASSEMBLY, DRAWING).</p> <code>microversionId</code> <code>str</code> <p>The unique identifier of the microversion of the element.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; element = Element(id=\"0b0c209535554345432581fe\", name=\"wheelAndFork\", elementType=\"PARTSTUDIO\",\n...                   microversionId=\"9b3be6165c7a2b1f6dd61305\")\n&gt;&gt;&gt; element\nElement(id='0b0c209535554345432581fe', name='wheelAndFork', elementType='PARTSTUDIO',\n        microversionId='9b3be6165c7a2b1f6dd61305')\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/element.py</code> <pre><code>class Element(BaseModel):\n    \"\"\"\n    Represents an Onshape element, containing the element ID, name, type, and microversion ID.\n\n    JSON:\n        ```json\n            {\n                \"name\": \"wheelAndFork\",\n                \"id\": \"0b0c209535554345432581fe\",\n                \"type\": \"Part Studio\",\n                \"elementType\": \"PARTSTUDIO\",\n                \"dataType\": \"onshape/partstudio\",\n                \"microversionId\": \"9b3be6165c7a2b1f6dd61305\",\n                \"lengthUnits\": \"millimeter\",\n                \"angleUnits\": \"degree\",\n                \"massUnits\": \"kilogram\",\n                \"timeUnits\": \"second\",\n                \"forceUnits\": \"newton\",\n                \"pressureUnits\": \"pascal\",\n                \"momentUnits\": \"newtonMeter\",\n                \"accelerationUnits\": \"meterPerSecondSquared\",\n                \"angularVelocityUnits\": \"degreePerSecond\",\n                \"energyUnits\": \"footPoundForce\",\n                \"areaUnits\": \"squareMillimeter\",\n                \"volumeUnits\": \"cubicMillimeter\",\n            }\n        ```\n\n    Attributes:\n        id (str): The unique identifier of the element.\n        name (str): The name of the element.\n        elementType (str): The type of the element (e.g., PARTSTUDIO, ASSEMBLY, DRAWING).\n        microversionId (str): The unique identifier of the microversion of the element.\n\n    Examples:\n        &gt;&gt;&gt; element = Element(id=\"0b0c209535554345432581fe\", name=\"wheelAndFork\", elementType=\"PARTSTUDIO\",\n        ...                   microversionId=\"9b3be6165c7a2b1f6dd61305\")\n        &gt;&gt;&gt; element\n        Element(id='0b0c209535554345432581fe', name='wheelAndFork', elementType='PARTSTUDIO',\n                microversionId='9b3be6165c7a2b1f6dd61305')\n    \"\"\"\n\n    id: str = Field(..., description=\"The unique identifier of the element\")\n    name: str = Field(..., description=\"The name of the element\")\n    elementType: str = Field(..., description=\"The type of the element\")\n    microversionId: str = Field(..., description=\"The unique identifier of the microversion of the element\")\n\n    @field_validator(\"elementType\")\n    def validate_type(cls, value: str) -&gt; str:\n        \"\"\"\n        Validate the element type.\n\n        Args:\n            value: The element type to validate.\n\n        Returns:\n            The validated element type.\n\n        Raises:\n            ValueError: If the element type is not one of the valid types.\n        \"\"\"\n\n        if value not in ElementType.__members__.values():\n            raise ValueError(f\"Invalid element type: {value}\")\n\n        return value\n\n    @field_validator(\"id\")\n    def validate_id(cls, value: str) -&gt; str:\n        \"\"\"\n        Validate the element ID.\n\n        Args:\n            value: The element ID to validate.\n\n        Returns:\n            The validated element ID.\n\n        Raises:\n            ValueError: If the element ID is not 24 characters long.\n        \"\"\"\n\n        if len(value) != 24:\n            raise ValueError(f\"Invalid element ID: {value}, must be 24 characters long\")\n\n        return value\n\n    @field_validator(\"microversionId\")\n    def validate_mid(cls, value: str) -&gt; str:\n        \"\"\"\n        Validate the microversion ID.\n\n        Args:\n            value: The microversion ID to validate.\n\n        Returns:\n            The validated microversion ID.\n\n        Raises:\n            ValueError: If the microversion ID is not 24 characters long.\n        \"\"\"\n\n        if len(value) != 24:\n            raise ValueError(f\"Invalid microversion ID: {value}, must be 24 characters long\")\n\n        return value\n</code></pre>"},{"location":"api/element/#onshape_robotics_toolkit.models.element.Element.validate_id","title":"<code>validate_id(value)</code>","text":"<p>Validate the element ID.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The element ID to validate.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The validated element ID.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the element ID is not 24 characters long.</p> Source code in <code>onshape_robotics_toolkit/models/element.py</code> <pre><code>@field_validator(\"id\")\ndef validate_id(cls, value: str) -&gt; str:\n    \"\"\"\n    Validate the element ID.\n\n    Args:\n        value: The element ID to validate.\n\n    Returns:\n        The validated element ID.\n\n    Raises:\n        ValueError: If the element ID is not 24 characters long.\n    \"\"\"\n\n    if len(value) != 24:\n        raise ValueError(f\"Invalid element ID: {value}, must be 24 characters long\")\n\n    return value\n</code></pre>"},{"location":"api/element/#onshape_robotics_toolkit.models.element.Element.validate_mid","title":"<code>validate_mid(value)</code>","text":"<p>Validate the microversion ID.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The microversion ID to validate.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The validated microversion ID.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the microversion ID is not 24 characters long.</p> Source code in <code>onshape_robotics_toolkit/models/element.py</code> <pre><code>@field_validator(\"microversionId\")\ndef validate_mid(cls, value: str) -&gt; str:\n    \"\"\"\n    Validate the microversion ID.\n\n    Args:\n        value: The microversion ID to validate.\n\n    Returns:\n        The validated microversion ID.\n\n    Raises:\n        ValueError: If the microversion ID is not 24 characters long.\n    \"\"\"\n\n    if len(value) != 24:\n        raise ValueError(f\"Invalid microversion ID: {value}, must be 24 characters long\")\n\n    return value\n</code></pre>"},{"location":"api/element/#onshape_robotics_toolkit.models.element.Element.validate_type","title":"<code>validate_type(value)</code>","text":"<p>Validate the element type.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The element type to validate.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The validated element type.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the element type is not one of the valid types.</p> Source code in <code>onshape_robotics_toolkit/models/element.py</code> <pre><code>@field_validator(\"elementType\")\ndef validate_type(cls, value: str) -&gt; str:\n    \"\"\"\n    Validate the element type.\n\n    Args:\n        value: The element type to validate.\n\n    Returns:\n        The validated element type.\n\n    Raises:\n        ValueError: If the element type is not one of the valid types.\n    \"\"\"\n\n    if value not in ElementType.__members__.values():\n        raise ValueError(f\"Invalid element type: {value}\")\n\n    return value\n</code></pre>"},{"location":"api/element/#onshape_robotics_toolkit.models.element.ElementType","title":"<code>ElementType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enumerates the possible element types in Onshape</p> <p>Attributes:</p> Name Type Description <code>PARTSTUDIO</code> <code>str</code> <p>Part Studio</p> <code>ASSEMBLY</code> <code>str</code> <p>Assembly</p> <code>VARIABLESTUDIO</code> <code>str</code> <p>Variable Studio</p> <code>DRAWING</code> <code>str</code> <p>Drawing</p> <code>BILLOFMATERIALS</code> <code>str</code> <p>Bill of Materials</p> <code>APPLICATION</code> <code>str</code> <p>Application</p> <code>BLOB</code> <code>str</code> <p>Blob</p> <code>FEATURESTUDIO</code> <code>str</code> <p>Feature Studio</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ElementType.PARTSTUDIO\n'PARTSTUDIO'\n&gt;&gt;&gt; ElementType.ASSEMBLY\n'ASSEMBLY'\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/element.py</code> <pre><code>class ElementType(str, Enum):\n    \"\"\"\n    Enumerates the possible element types in Onshape\n\n    Attributes:\n        PARTSTUDIO (str): Part Studio\n        ASSEMBLY (str): Assembly\n        VARIABLESTUDIO (str): Variable Studio\n        DRAWING (str): Drawing\n        BILLOFMATERIALS (str): Bill of Materials\n        APPLICATION (str): Application\n        BLOB (str): Blob\n        FEATURESTUDIO (str): Feature Studio\n\n    Examples:\n        &gt;&gt;&gt; ElementType.PARTSTUDIO\n        'PARTSTUDIO'\n        &gt;&gt;&gt; ElementType.ASSEMBLY\n        'ASSEMBLY'\n    \"\"\"\n\n    PARTSTUDIO = \"PARTSTUDIO\"\n    ASSEMBLY = \"ASSEMBLY\"\n    VARIABLESTUDIO = \"VARIABLESTUDIO\"\n    DRAWING = \"DRAWING\"\n    BILLOFMATERIALS = \"BILLOFMATERIALS\"\n    APPLICATION = \"APPLICATION\"\n    BLOB = \"BLOB\"\n    FEATURESTUDIO = \"FEATURESTUDIO\"\n</code></pre>"},{"location":"api/geometry/","title":"Geometry","text":"<p>This module contains classes for representing geometry in Onshape.</p> Class <ul> <li>BaseGeometry: Abstract base class for geometry objects.</li> <li>BoxGeometry: Represents a box geometry.</li> <li>CylinderGeometry: Represents a cylinder geometry.</li> <li>SphereGeometry: Represents a sphere geometry.</li> <li>MeshGeometry: Represents a mesh geometry.</li> </ul>"},{"location":"api/geometry/#onshape_robotics_toolkit.models.geometry.BaseGeometry","title":"<code>BaseGeometry</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for geometry objects.</p> Abstract Methods <p>to_xml: Converts the geometry object to an XML element.</p> Source code in <code>onshape_robotics_toolkit/models/geometry.py</code> <pre><code>@dataclass\nclass BaseGeometry(ABC):\n    \"\"\"\n    Abstract base class for geometry objects.\n\n    Abstract Methods:\n        to_xml: Converts the geometry object to an XML element.\n    \"\"\"\n\n    @abstractmethod\n    def to_xml(self, root: Optional[_Element] = None) -&gt; _Element: ...\n\n    @abstractmethod\n    def to_mjcf(self, root: _Element) -&gt; None: ...\n\n    @classmethod\n    @abstractmethod\n    def from_xml(cls, element: _Element) -&gt; \"BaseGeometry\": ...\n\n    @property\n    @abstractmethod\n    def geometry_type(self) -&gt; str: ...\n</code></pre>"},{"location":"api/geometry/#onshape_robotics_toolkit.models.geometry.BoxGeometry","title":"<code>BoxGeometry</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseGeometry</code></p> <p>Represents a box geometry.</p> <p>Attributes:</p> Name Type Description <code>size</code> <code>tuple[float, float, float]</code> <p>The size of the box in the x, y, and z dimensions.</p> <p>Methods:</p> Name Description <code>to_xml</code> <p>Converts the box geometry to an XML element.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; box = BoxGeometry(size=(1.0, 2.0, 3.0))\n&gt;&gt;&gt; box.to_xml()\n&lt;Element 'geometry' at 0x7f8b3c0b4c70&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/geometry.py</code> <pre><code>@dataclass\nclass BoxGeometry(BaseGeometry):\n    \"\"\"\n    Represents a box geometry.\n\n    Attributes:\n        size (tuple[float, float, float]): The size of the box in the x, y, and z dimensions.\n\n    Methods:\n        to_xml: Converts the box geometry to an XML element.\n\n    Examples:\n        &gt;&gt;&gt; box = BoxGeometry(size=(1.0, 2.0, 3.0))\n        &gt;&gt;&gt; box.to_xml()\n        &lt;Element 'geometry' at 0x7f8b3c0b4c70&gt;\n    \"\"\"\n\n    size: tuple[float, float, float]\n\n    def to_xml(self, root: Optional[_Element] = None) -&gt; _Element:\n        \"\"\"\n        Convert the box geometry to an XML element.\n\n        Args:\n            root: The root element to append the box geometry to.\n\n        Returns:\n            The XML element representing the box geometry.\n\n        Examples:\n            &gt;&gt;&gt; box = BoxGeometry(size=(1.0, 2.0, 3.0))\n            &gt;&gt;&gt; box.to_xml()\n            &lt;Element 'geometry' at 0x7f8b3c0b4c70&gt;\n        \"\"\"\n        geometry = ETreeElement(\"geometry\") if root is None else SubElement(root, \"geometry\")\n        SubElement(geometry, \"box\", size=\" \".join(format_number(v) for v in self.size))\n        return geometry\n\n    def to_mjcf(self, root: _Element) -&gt; None:\n        \"\"\"\n        Convert the box geometry to an MJCF element.\n\n        Args:\n            root: The root element to append the box geometry to.\n\n        Returns:\n            The MJCF element representing the box geometry.\n\n        Examples:\n            &gt;&gt;&gt; box = BoxGeometry(size=(1.0, 2.0, 3.0))\n            &gt;&gt;&gt; box.to_mjcf()\n            &lt;Element 'geom' at 0x7f8b3c0b4c70&gt;\n        \"\"\"\n        geom = root if root.tag == \"geom\" else SubElement(root, \"geom\")\n        geom.set(\"type\", GeometryType.BOX)\n        geom.set(\"size\", \" \".join(format_number(v) for v in self.size))\n\n    @classmethod\n    def from_xml(cls, element: _Element) -&gt; \"BoxGeometry\":\n        \"\"\"\n        Create a box geometry from an XML element.\n\n        Args:\n            element: The XML element to create the box geometry from.\n\n        Returns:\n            The box geometry created from the XML element.\n\n        Examples:\n            &gt;&gt;&gt; element = Element(\"geometry\")\n            &gt;&gt;&gt; SubElement(element, \"box\", size=\"1.0 2.0 3.0\")\n            &gt;&gt;&gt; BoxGeometry.from_xml(element)\n            BoxGeometry(size=(1.0, 2.0, 3.0))\n        \"\"\"\n        box_element = element.find(\"box\")\n        if box_element is None:\n            raise ValueError(\"No box element found\")\n        size_values = [float(v) for v in box_element.attrib[\"size\"].split()]\n        if len(size_values) != 3:\n            raise ValueError(\"Box size must have exactly 3 values\")\n        size = (size_values[0], size_values[1], size_values[2])\n        return cls(size)\n\n    @property\n    def geometry_type(self) -&gt; str:\n        return GeometryType.BOX\n</code></pre>"},{"location":"api/geometry/#onshape_robotics_toolkit.models.geometry.BoxGeometry.from_xml","title":"<code>from_xml(element)</code>  <code>classmethod</code>","text":"<p>Create a box geometry from an XML element.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>_Element</code> <p>The XML element to create the box geometry from.</p> required <p>Returns:</p> Type Description <code>BoxGeometry</code> <p>The box geometry created from the XML element.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; element = Element(\"geometry\")\n&gt;&gt;&gt; SubElement(element, \"box\", size=\"1.0 2.0 3.0\")\n&gt;&gt;&gt; BoxGeometry.from_xml(element)\nBoxGeometry(size=(1.0, 2.0, 3.0))\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/geometry.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: _Element) -&gt; \"BoxGeometry\":\n    \"\"\"\n    Create a box geometry from an XML element.\n\n    Args:\n        element: The XML element to create the box geometry from.\n\n    Returns:\n        The box geometry created from the XML element.\n\n    Examples:\n        &gt;&gt;&gt; element = Element(\"geometry\")\n        &gt;&gt;&gt; SubElement(element, \"box\", size=\"1.0 2.0 3.0\")\n        &gt;&gt;&gt; BoxGeometry.from_xml(element)\n        BoxGeometry(size=(1.0, 2.0, 3.0))\n    \"\"\"\n    box_element = element.find(\"box\")\n    if box_element is None:\n        raise ValueError(\"No box element found\")\n    size_values = [float(v) for v in box_element.attrib[\"size\"].split()]\n    if len(size_values) != 3:\n        raise ValueError(\"Box size must have exactly 3 values\")\n    size = (size_values[0], size_values[1], size_values[2])\n    return cls(size)\n</code></pre>"},{"location":"api/geometry/#onshape_robotics_toolkit.models.geometry.BoxGeometry.to_mjcf","title":"<code>to_mjcf(root)</code>","text":"<p>Convert the box geometry to an MJCF element.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>_Element</code> <p>The root element to append the box geometry to.</p> required <p>Returns:</p> Type Description <code>None</code> <p>The MJCF element representing the box geometry.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; box = BoxGeometry(size=(1.0, 2.0, 3.0))\n&gt;&gt;&gt; box.to_mjcf()\n&lt;Element 'geom' at 0x7f8b3c0b4c70&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/geometry.py</code> <pre><code>def to_mjcf(self, root: _Element) -&gt; None:\n    \"\"\"\n    Convert the box geometry to an MJCF element.\n\n    Args:\n        root: The root element to append the box geometry to.\n\n    Returns:\n        The MJCF element representing the box geometry.\n\n    Examples:\n        &gt;&gt;&gt; box = BoxGeometry(size=(1.0, 2.0, 3.0))\n        &gt;&gt;&gt; box.to_mjcf()\n        &lt;Element 'geom' at 0x7f8b3c0b4c70&gt;\n    \"\"\"\n    geom = root if root.tag == \"geom\" else SubElement(root, \"geom\")\n    geom.set(\"type\", GeometryType.BOX)\n    geom.set(\"size\", \" \".join(format_number(v) for v in self.size))\n</code></pre>"},{"location":"api/geometry/#onshape_robotics_toolkit.models.geometry.BoxGeometry.to_xml","title":"<code>to_xml(root=None)</code>","text":"<p>Convert the box geometry to an XML element.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>Optional[_Element]</code> <p>The root element to append the box geometry to.</p> <code>None</code> <p>Returns:</p> Type Description <code>_Element</code> <p>The XML element representing the box geometry.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; box = BoxGeometry(size=(1.0, 2.0, 3.0))\n&gt;&gt;&gt; box.to_xml()\n&lt;Element 'geometry' at 0x7f8b3c0b4c70&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/geometry.py</code> <pre><code>def to_xml(self, root: Optional[_Element] = None) -&gt; _Element:\n    \"\"\"\n    Convert the box geometry to an XML element.\n\n    Args:\n        root: The root element to append the box geometry to.\n\n    Returns:\n        The XML element representing the box geometry.\n\n    Examples:\n        &gt;&gt;&gt; box = BoxGeometry(size=(1.0, 2.0, 3.0))\n        &gt;&gt;&gt; box.to_xml()\n        &lt;Element 'geometry' at 0x7f8b3c0b4c70&gt;\n    \"\"\"\n    geometry = ETreeElement(\"geometry\") if root is None else SubElement(root, \"geometry\")\n    SubElement(geometry, \"box\", size=\" \".join(format_number(v) for v in self.size))\n    return geometry\n</code></pre>"},{"location":"api/geometry/#onshape_robotics_toolkit.models.geometry.CylinderGeometry","title":"<code>CylinderGeometry</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseGeometry</code></p> <p>Represents a cylinder geometry.</p> <p>Attributes:</p> Name Type Description <code>radius</code> <code>float</code> <p>The radius of the cylinder.</p> <code>length</code> <code>float</code> <p>The length of the cylinder.</p> <p>Methods:</p> Name Description <code>to_xml</code> <p>Converts the cylinder geometry to an XML element.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cylinder = CylinderGeometry(radius=1.0, length=2.0)\n&gt;&gt;&gt; cylinder.to_xml()\n&lt;Element 'geometry' at 0x7f8b3c0b4c70&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/geometry.py</code> <pre><code>@dataclass\nclass CylinderGeometry(BaseGeometry):\n    \"\"\"\n    Represents a cylinder geometry.\n\n    Attributes:\n        radius (float): The radius of the cylinder.\n        length (float): The length of the cylinder.\n\n    Methods:\n        to_xml: Converts the cylinder geometry to an XML element.\n\n    Examples:\n        &gt;&gt;&gt; cylinder = CylinderGeometry(radius=1.0, length=2.0)\n        &gt;&gt;&gt; cylinder.to_xml()\n        &lt;Element 'geometry' at 0x7f8b3c0b4c70&gt;\n    \"\"\"\n\n    radius: float\n    length: float\n\n    def to_xml(self, root: Optional[_Element] = None) -&gt; _Element:\n        \"\"\"\n        Convert the cylinder geometry to an XML element.\n\n        Args:\n            root: The root element to append the cylinder geometry to.\n\n        Returns:\n            The XML element representing the cylinder geometry.\n\n        Examples:\n            &gt;&gt;&gt; cylinder = CylinderGeometry(radius=1.0, length=2.0)\n            &gt;&gt;&gt; cylinder.to_xml()\n            &lt;Element 'geometry' at 0x7f8b3c0b4c70&gt;\n        \"\"\"\n        geometry = ETreeElement(\"geometry\") if root is None else SubElement(root, \"geometry\")\n        SubElement(\n            geometry,\n            \"cylinder\",\n            radius=format_number(self.radius),\n            length=format_number(self.length),\n        )\n        return geometry\n\n    def to_mjcf(self, root: _Element) -&gt; None:\n        \"\"\"\n        Convert the cylinder geometry to an MJCF element.\n\n        Args:\n            root: The root element to append the cylinder geometry to.\n\n        Returns:\n            The MJCF element representing the cylinder geometry.\n\n        Examples:\n            &gt;&gt;&gt; cylinder = CylinderGeometry(radius=1.0, length=2.0)\n            &gt;&gt;&gt; cylinder.to_mjcf()\n            &lt;Element 'geom' at 0x7f8b3c0b4c70&gt;\n        \"\"\"\n        geom = root if root.tag == \"geom\" else SubElement(root, \"geom\")\n        geom.set(\"type\", GeometryType.CYLINDER)\n        geom.set(\"size\", f\"{format_number(self.radius)} {format_number(self.length)}\")\n\n    @classmethod\n    def from_xml(cls, element: _Element) -&gt; \"CylinderGeometry\":\n        \"\"\"\n        Create a cylinder geometry from an XML element.\n\n        Args:\n            element: The XML element to create the cylinder geometry from.\n\n        Returns:\n            The cylinder geometry created from the XML element.\n\n        Examples:\n            &gt;&gt;&gt; element = Element(\"geometry\")\n            &gt;&gt;&gt; SubElement(element, \"cylinder\", radius=\"1.0\", length=\"2.0\")\n            &gt;&gt;&gt; CylinderGeometry.from_xml(element)\n            CylinderGeometry(radius=1.0, length=2.0)\n        \"\"\"\n        cylinder_element = element.find(\"cylinder\")\n        if cylinder_element is None:\n            raise ValueError(\"No cylinder element found\")\n        radius = float(cylinder_element.attrib[\"radius\"])\n        length = float(cylinder_element.attrib[\"length\"])\n        return cls(radius, length)\n\n    @property\n    def geometry_type(self) -&gt; str:\n        return GeometryType.CYLINDER\n</code></pre>"},{"location":"api/geometry/#onshape_robotics_toolkit.models.geometry.CylinderGeometry.from_xml","title":"<code>from_xml(element)</code>  <code>classmethod</code>","text":"<p>Create a cylinder geometry from an XML element.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>_Element</code> <p>The XML element to create the cylinder geometry from.</p> required <p>Returns:</p> Type Description <code>CylinderGeometry</code> <p>The cylinder geometry created from the XML element.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; element = Element(\"geometry\")\n&gt;&gt;&gt; SubElement(element, \"cylinder\", radius=\"1.0\", length=\"2.0\")\n&gt;&gt;&gt; CylinderGeometry.from_xml(element)\nCylinderGeometry(radius=1.0, length=2.0)\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/geometry.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: _Element) -&gt; \"CylinderGeometry\":\n    \"\"\"\n    Create a cylinder geometry from an XML element.\n\n    Args:\n        element: The XML element to create the cylinder geometry from.\n\n    Returns:\n        The cylinder geometry created from the XML element.\n\n    Examples:\n        &gt;&gt;&gt; element = Element(\"geometry\")\n        &gt;&gt;&gt; SubElement(element, \"cylinder\", radius=\"1.0\", length=\"2.0\")\n        &gt;&gt;&gt; CylinderGeometry.from_xml(element)\n        CylinderGeometry(radius=1.0, length=2.0)\n    \"\"\"\n    cylinder_element = element.find(\"cylinder\")\n    if cylinder_element is None:\n        raise ValueError(\"No cylinder element found\")\n    radius = float(cylinder_element.attrib[\"radius\"])\n    length = float(cylinder_element.attrib[\"length\"])\n    return cls(radius, length)\n</code></pre>"},{"location":"api/geometry/#onshape_robotics_toolkit.models.geometry.CylinderGeometry.to_mjcf","title":"<code>to_mjcf(root)</code>","text":"<p>Convert the cylinder geometry to an MJCF element.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>_Element</code> <p>The root element to append the cylinder geometry to.</p> required <p>Returns:</p> Type Description <code>None</code> <p>The MJCF element representing the cylinder geometry.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cylinder = CylinderGeometry(radius=1.0, length=2.0)\n&gt;&gt;&gt; cylinder.to_mjcf()\n&lt;Element 'geom' at 0x7f8b3c0b4c70&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/geometry.py</code> <pre><code>def to_mjcf(self, root: _Element) -&gt; None:\n    \"\"\"\n    Convert the cylinder geometry to an MJCF element.\n\n    Args:\n        root: The root element to append the cylinder geometry to.\n\n    Returns:\n        The MJCF element representing the cylinder geometry.\n\n    Examples:\n        &gt;&gt;&gt; cylinder = CylinderGeometry(radius=1.0, length=2.0)\n        &gt;&gt;&gt; cylinder.to_mjcf()\n        &lt;Element 'geom' at 0x7f8b3c0b4c70&gt;\n    \"\"\"\n    geom = root if root.tag == \"geom\" else SubElement(root, \"geom\")\n    geom.set(\"type\", GeometryType.CYLINDER)\n    geom.set(\"size\", f\"{format_number(self.radius)} {format_number(self.length)}\")\n</code></pre>"},{"location":"api/geometry/#onshape_robotics_toolkit.models.geometry.CylinderGeometry.to_xml","title":"<code>to_xml(root=None)</code>","text":"<p>Convert the cylinder geometry to an XML element.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>Optional[_Element]</code> <p>The root element to append the cylinder geometry to.</p> <code>None</code> <p>Returns:</p> Type Description <code>_Element</code> <p>The XML element representing the cylinder geometry.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cylinder = CylinderGeometry(radius=1.0, length=2.0)\n&gt;&gt;&gt; cylinder.to_xml()\n&lt;Element 'geometry' at 0x7f8b3c0b4c70&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/geometry.py</code> <pre><code>def to_xml(self, root: Optional[_Element] = None) -&gt; _Element:\n    \"\"\"\n    Convert the cylinder geometry to an XML element.\n\n    Args:\n        root: The root element to append the cylinder geometry to.\n\n    Returns:\n        The XML element representing the cylinder geometry.\n\n    Examples:\n        &gt;&gt;&gt; cylinder = CylinderGeometry(radius=1.0, length=2.0)\n        &gt;&gt;&gt; cylinder.to_xml()\n        &lt;Element 'geometry' at 0x7f8b3c0b4c70&gt;\n    \"\"\"\n    geometry = ETreeElement(\"geometry\") if root is None else SubElement(root, \"geometry\")\n    SubElement(\n        geometry,\n        \"cylinder\",\n        radius=format_number(self.radius),\n        length=format_number(self.length),\n    )\n    return geometry\n</code></pre>"},{"location":"api/geometry/#onshape_robotics_toolkit.models.geometry.GeometryType","title":"<code>GeometryType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enumerates the possible geometry types in Onshape.</p> <p>Attributes:</p> Name Type Description <code>BOX</code> <code>str</code> <p>Box geometry.</p> <code>CYLINDER</code> <code>str</code> <p>Cylinder geometry.</p> <code>SPHERE</code> <code>str</code> <p>Sphere geometry.</p> <code>MESH</code> <code>str</code> <p>Mesh geometry.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; GeometryType.BOX\n'BOX'\n&gt;&gt;&gt; GeometryType.CYLINDER\n'CYLINDER'\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/geometry.py</code> <pre><code>class GeometryType(str, Enum):\n    \"\"\"\n    Enumerates the possible geometry types in Onshape.\n\n    Attributes:\n        BOX (str): Box geometry.\n        CYLINDER (str): Cylinder geometry.\n        SPHERE (str): Sphere geometry.\n        MESH (str): Mesh geometry.\n\n    Examples:\n        &gt;&gt;&gt; GeometryType.BOX\n        'BOX'\n        &gt;&gt;&gt; GeometryType.CYLINDER\n        'CYLINDER'\n    \"\"\"\n\n    BOX = \"box\"\n    CYLINDER = \"cylinder\"\n    SPHERE = \"sphere\"\n    MESH = \"mesh\"\n</code></pre>"},{"location":"api/geometry/#onshape_robotics_toolkit.models.geometry.MeshGeometry","title":"<code>MeshGeometry</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseGeometry</code></p> <p>Represents a mesh geometry.</p> <p>Attributes:</p> Name Type Description <code>filename</code> <code>str</code> <p>The filename of the mesh.</p> <p>Methods:</p> Name Description <code>to_xml</code> <p>Converts the mesh geometry to an XML element.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; mesh = MeshGeometry(filename=\"mesh.stl\")\n&gt;&gt;&gt; mesh.to_xml()\n&lt;Element 'geometry' at 0x7f8b3c0b4c70&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/geometry.py</code> <pre><code>@dataclass\nclass MeshGeometry(BaseGeometry):\n    \"\"\"\n    Represents a mesh geometry.\n\n    Attributes:\n        filename (str): The filename of the mesh.\n\n    Methods:\n        to_xml: Converts the mesh geometry to an XML element.\n\n    Examples:\n        &gt;&gt;&gt; mesh = MeshGeometry(filename=\"mesh.stl\")\n        &gt;&gt;&gt; mesh.to_xml()\n        &lt;Element 'geometry' at 0x7f8b3c0b4c70&gt;\n    \"\"\"\n\n    filename: str\n\n    def to_xml(self, root: Optional[_Element] = None) -&gt; _Element:\n        \"\"\"\n        Convert the mesh geometry to an XML element.\n\n        Args:\n            root: The root element to append the mesh geometry to.\n\n        Returns:\n            The XML element representing the mesh geometry.\n\n        Examples:\n            &gt;&gt;&gt; mesh = MeshGeometry(filename=\"mesh.stl\")\n            &gt;&gt;&gt; mesh.to_xml()\n            &lt;Element 'geometry' at 0x7f8b3c0b4c70&gt;\n        \"\"\"\n        geometry = ETreeElement(\"geometry\") if root is None else SubElement(root, \"geometry\")\n        SubElement(geometry, \"mesh\", filename=self.filename)\n        return geometry\n\n    def to_mjcf(self, root: _Element) -&gt; None:\n        \"\"\"\n        Convert the mesh geometry to an MJCF element.\n\n        Args:\n            root: The root element to append the mesh geometry to.\n\n        Returns:\n            The MJCF element representing the mesh geometry.\n\n        Examples:\n            &gt;&gt;&gt; mesh = MeshGeometry(filename=\"mesh.stl\")\n            &gt;&gt;&gt; mesh.to_mjcf()\n            &lt;Element 'geom' at 0x7f8b3c0b4c70&gt;\n        \"\"\"\n        geom = root if root is not None and root.tag == \"geom\" else SubElement(root, \"geom\")\n        geom.set(\"type\", GeometryType.MESH)\n        geom.set(\"mesh\", self.mesh_name)\n\n    @classmethod\n    def from_xml(cls, element: _Element) -&gt; \"MeshGeometry\":\n        \"\"\"\n        Create a mesh geometry from an XML element.\n\n        Args:\n            element: The XML element to create the mesh geometry from.\n\n        Returns:\n            The mesh geometry created from the XML element.\n\n        Examples:\n            &gt;&gt;&gt; element = Element(\"geometry\")\n            &gt;&gt;&gt; SubElement(element, \"mesh\", filename=\"mesh.stl\")\n            &gt;&gt;&gt; MeshGeometry.from_xml(element)\n            MeshGeometry(filename=\"mesh.stl\")\n        \"\"\"\n        mesh_element = element.find(\"mesh\")\n        if mesh_element is None:\n            raise ValueError(\"No mesh element found\")\n        filename = mesh_element.attrib[\"filename\"]\n        return cls(filename)\n\n    def __post_init__(self) -&gt; None:\n        self.filename = xml_escape(self.filename)\n\n    @property\n    def geometry_type(self) -&gt; str:\n        return GeometryType.MESH\n\n    @property\n    def mesh_name(self) -&gt; str:\n        file_name_w_ext = os.path.basename(self.filename)\n        return os.path.splitext(file_name_w_ext)[0]\n</code></pre>"},{"location":"api/geometry/#onshape_robotics_toolkit.models.geometry.MeshGeometry.from_xml","title":"<code>from_xml(element)</code>  <code>classmethod</code>","text":"<p>Create a mesh geometry from an XML element.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>_Element</code> <p>The XML element to create the mesh geometry from.</p> required <p>Returns:</p> Type Description <code>MeshGeometry</code> <p>The mesh geometry created from the XML element.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; element = Element(\"geometry\")\n&gt;&gt;&gt; SubElement(element, \"mesh\", filename=\"mesh.stl\")\n&gt;&gt;&gt; MeshGeometry.from_xml(element)\nMeshGeometry(filename=\"mesh.stl\")\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/geometry.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: _Element) -&gt; \"MeshGeometry\":\n    \"\"\"\n    Create a mesh geometry from an XML element.\n\n    Args:\n        element: The XML element to create the mesh geometry from.\n\n    Returns:\n        The mesh geometry created from the XML element.\n\n    Examples:\n        &gt;&gt;&gt; element = Element(\"geometry\")\n        &gt;&gt;&gt; SubElement(element, \"mesh\", filename=\"mesh.stl\")\n        &gt;&gt;&gt; MeshGeometry.from_xml(element)\n        MeshGeometry(filename=\"mesh.stl\")\n    \"\"\"\n    mesh_element = element.find(\"mesh\")\n    if mesh_element is None:\n        raise ValueError(\"No mesh element found\")\n    filename = mesh_element.attrib[\"filename\"]\n    return cls(filename)\n</code></pre>"},{"location":"api/geometry/#onshape_robotics_toolkit.models.geometry.MeshGeometry.to_mjcf","title":"<code>to_mjcf(root)</code>","text":"<p>Convert the mesh geometry to an MJCF element.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>_Element</code> <p>The root element to append the mesh geometry to.</p> required <p>Returns:</p> Type Description <code>None</code> <p>The MJCF element representing the mesh geometry.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; mesh = MeshGeometry(filename=\"mesh.stl\")\n&gt;&gt;&gt; mesh.to_mjcf()\n&lt;Element 'geom' at 0x7f8b3c0b4c70&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/geometry.py</code> <pre><code>def to_mjcf(self, root: _Element) -&gt; None:\n    \"\"\"\n    Convert the mesh geometry to an MJCF element.\n\n    Args:\n        root: The root element to append the mesh geometry to.\n\n    Returns:\n        The MJCF element representing the mesh geometry.\n\n    Examples:\n        &gt;&gt;&gt; mesh = MeshGeometry(filename=\"mesh.stl\")\n        &gt;&gt;&gt; mesh.to_mjcf()\n        &lt;Element 'geom' at 0x7f8b3c0b4c70&gt;\n    \"\"\"\n    geom = root if root is not None and root.tag == \"geom\" else SubElement(root, \"geom\")\n    geom.set(\"type\", GeometryType.MESH)\n    geom.set(\"mesh\", self.mesh_name)\n</code></pre>"},{"location":"api/geometry/#onshape_robotics_toolkit.models.geometry.MeshGeometry.to_xml","title":"<code>to_xml(root=None)</code>","text":"<p>Convert the mesh geometry to an XML element.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>Optional[_Element]</code> <p>The root element to append the mesh geometry to.</p> <code>None</code> <p>Returns:</p> Type Description <code>_Element</code> <p>The XML element representing the mesh geometry.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; mesh = MeshGeometry(filename=\"mesh.stl\")\n&gt;&gt;&gt; mesh.to_xml()\n&lt;Element 'geometry' at 0x7f8b3c0b4c70&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/geometry.py</code> <pre><code>def to_xml(self, root: Optional[_Element] = None) -&gt; _Element:\n    \"\"\"\n    Convert the mesh geometry to an XML element.\n\n    Args:\n        root: The root element to append the mesh geometry to.\n\n    Returns:\n        The XML element representing the mesh geometry.\n\n    Examples:\n        &gt;&gt;&gt; mesh = MeshGeometry(filename=\"mesh.stl\")\n        &gt;&gt;&gt; mesh.to_xml()\n        &lt;Element 'geometry' at 0x7f8b3c0b4c70&gt;\n    \"\"\"\n    geometry = ETreeElement(\"geometry\") if root is None else SubElement(root, \"geometry\")\n    SubElement(geometry, \"mesh\", filename=self.filename)\n    return geometry\n</code></pre>"},{"location":"api/geometry/#onshape_robotics_toolkit.models.geometry.SphereGeometry","title":"<code>SphereGeometry</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseGeometry</code></p> <p>Represents a sphere geometry.</p> <p>Attributes:</p> Name Type Description <code>radius</code> <code>float</code> <p>The radius of the sphere.</p> <p>Methods:</p> Name Description <code>to_xml</code> <p>Converts the sphere geometry to an XML element.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sphere = SphereGeometry(radius=1.0)\n&gt;&gt;&gt; sphere.to_xml()\n&lt;Element 'geometry' at 0x7f8b3c0b4c70&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/geometry.py</code> <pre><code>@dataclass\nclass SphereGeometry(BaseGeometry):\n    \"\"\"\n    Represents a sphere geometry.\n\n    Attributes:\n        radius (float): The radius of the sphere.\n\n    Methods:\n        to_xml: Converts the sphere geometry to an XML element.\n\n    Examples:\n        &gt;&gt;&gt; sphere = SphereGeometry(radius=1.0)\n        &gt;&gt;&gt; sphere.to_xml()\n        &lt;Element 'geometry' at 0x7f8b3c0b4c70&gt;\n    \"\"\"\n\n    radius: float\n\n    def to_xml(self, root: Optional[_Element] = None) -&gt; _Element:\n        \"\"\"\n        Convert the sphere geometry to an XML element.\n\n        Args:\n            root: The root element to append the sphere geometry to.\n\n        Returns:\n            The XML element representing the sphere geometry.\n\n        Examples:\n            &gt;&gt;&gt; sphere = SphereGeometry(radius=1.0)\n            &gt;&gt;&gt; sphere.to_xml()\n            &lt;Element 'geometry' at 0x7f8b3c0b4c70&gt;\n        \"\"\"\n        geometry = ETreeElement(\"geometry\") if root is None else SubElement(root, \"geometry\")\n        SubElement(geometry, \"sphere\", radius=format_number(self.radius))\n        return geometry\n\n    def to_mjcf(self, root: _Element) -&gt; None:\n        \"\"\"\n        Convert the sphere geometry to an MJCF element.\n\n        Args:\n            root: The root element to append the sphere geometry to.\n\n        Returns:\n            The MJCF element representing the sphere geometry.\n\n        Examples:\n            &gt;&gt;&gt; sphere = SphereGeometry(radius=1.0)\n            &gt;&gt;&gt; sphere.to_mjcf()\n            &lt;Element 'geom' at 0x7f8b3c0b4c70&gt;\n        \"\"\"\n        geom = root if root is not None and root.tag == \"geom\" else SubElement(root, \"geom\")\n        geom.set(\"type\", GeometryType.SPHERE)\n        geom.set(\"size\", format_number(self.radius))\n\n    @classmethod\n    def from_xml(cls, element: _Element) -&gt; \"SphereGeometry\":\n        \"\"\"\n        Create a sphere geometry from an XML element.\n\n        Args:\n            element: The XML element to create the sphere geometry from.\n\n        Returns:\n            The sphere geometry created from the XML element.\n\n        Examples:\n            &gt;&gt;&gt; element = Element(\"geometry\")\n            &gt;&gt;&gt; SubElement(element, \"sphere\", radius=\"1.0\")\n            &gt;&gt;&gt; SphereGeometry.from_xml(element)\n            SphereGeometry(radius=1.0)\n        \"\"\"\n        sphere_element = element.find(\"sphere\")\n        if sphere_element is None:\n            raise ValueError(\"No sphere element found\")\n        radius = float(sphere_element.attrib[\"radius\"])\n        return cls(radius)\n\n    @property\n    def geometry_type(self) -&gt; str:\n        return GeometryType.SPHERE\n</code></pre>"},{"location":"api/geometry/#onshape_robotics_toolkit.models.geometry.SphereGeometry.from_xml","title":"<code>from_xml(element)</code>  <code>classmethod</code>","text":"<p>Create a sphere geometry from an XML element.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>_Element</code> <p>The XML element to create the sphere geometry from.</p> required <p>Returns:</p> Type Description <code>SphereGeometry</code> <p>The sphere geometry created from the XML element.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; element = Element(\"geometry\")\n&gt;&gt;&gt; SubElement(element, \"sphere\", radius=\"1.0\")\n&gt;&gt;&gt; SphereGeometry.from_xml(element)\nSphereGeometry(radius=1.0)\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/geometry.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: _Element) -&gt; \"SphereGeometry\":\n    \"\"\"\n    Create a sphere geometry from an XML element.\n\n    Args:\n        element: The XML element to create the sphere geometry from.\n\n    Returns:\n        The sphere geometry created from the XML element.\n\n    Examples:\n        &gt;&gt;&gt; element = Element(\"geometry\")\n        &gt;&gt;&gt; SubElement(element, \"sphere\", radius=\"1.0\")\n        &gt;&gt;&gt; SphereGeometry.from_xml(element)\n        SphereGeometry(radius=1.0)\n    \"\"\"\n    sphere_element = element.find(\"sphere\")\n    if sphere_element is None:\n        raise ValueError(\"No sphere element found\")\n    radius = float(sphere_element.attrib[\"radius\"])\n    return cls(radius)\n</code></pre>"},{"location":"api/geometry/#onshape_robotics_toolkit.models.geometry.SphereGeometry.to_mjcf","title":"<code>to_mjcf(root)</code>","text":"<p>Convert the sphere geometry to an MJCF element.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>_Element</code> <p>The root element to append the sphere geometry to.</p> required <p>Returns:</p> Type Description <code>None</code> <p>The MJCF element representing the sphere geometry.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sphere = SphereGeometry(radius=1.0)\n&gt;&gt;&gt; sphere.to_mjcf()\n&lt;Element 'geom' at 0x7f8b3c0b4c70&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/geometry.py</code> <pre><code>def to_mjcf(self, root: _Element) -&gt; None:\n    \"\"\"\n    Convert the sphere geometry to an MJCF element.\n\n    Args:\n        root: The root element to append the sphere geometry to.\n\n    Returns:\n        The MJCF element representing the sphere geometry.\n\n    Examples:\n        &gt;&gt;&gt; sphere = SphereGeometry(radius=1.0)\n        &gt;&gt;&gt; sphere.to_mjcf()\n        &lt;Element 'geom' at 0x7f8b3c0b4c70&gt;\n    \"\"\"\n    geom = root if root is not None and root.tag == \"geom\" else SubElement(root, \"geom\")\n    geom.set(\"type\", GeometryType.SPHERE)\n    geom.set(\"size\", format_number(self.radius))\n</code></pre>"},{"location":"api/geometry/#onshape_robotics_toolkit.models.geometry.SphereGeometry.to_xml","title":"<code>to_xml(root=None)</code>","text":"<p>Convert the sphere geometry to an XML element.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>Optional[_Element]</code> <p>The root element to append the sphere geometry to.</p> <code>None</code> <p>Returns:</p> Type Description <code>_Element</code> <p>The XML element representing the sphere geometry.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sphere = SphereGeometry(radius=1.0)\n&gt;&gt;&gt; sphere.to_xml()\n&lt;Element 'geometry' at 0x7f8b3c0b4c70&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/geometry.py</code> <pre><code>def to_xml(self, root: Optional[_Element] = None) -&gt; _Element:\n    \"\"\"\n    Convert the sphere geometry to an XML element.\n\n    Args:\n        root: The root element to append the sphere geometry to.\n\n    Returns:\n        The XML element representing the sphere geometry.\n\n    Examples:\n        &gt;&gt;&gt; sphere = SphereGeometry(radius=1.0)\n        &gt;&gt;&gt; sphere.to_xml()\n        &lt;Element 'geometry' at 0x7f8b3c0b4c70&gt;\n    \"\"\"\n    geometry = ETreeElement(\"geometry\") if root is None else SubElement(root, \"geometry\")\n    SubElement(geometry, \"sphere\", radius=format_number(self.radius))\n    return geometry\n</code></pre>"},{"location":"api/graph/","title":"Graph","text":"<p>This module contains functions and classes to create and manipulate kinematic graphs from Onshape assembly data.</p> <p>The main class is KinematicGraph, which uses the PathKey-based CAD system to build a directed graph representing the kinematic structure of a robot assembly. The graph nodes are parts involved in mates, and edges represent mate relationships.</p> <p>Classes:</p> Name Description <code>KinematicGraph</code> <p>Build and navigate kinematic graph from CAD assembly</p> <p>Functions:</p> Name Description <code>plot_graph</code> <p>Visualize graphs using matplotlib</p> <code>get_root_node</code> <p>Get root node of directed graph</p> <code>convert_to_digraph</code> <p>Convert undirected graph to directed with root detection</p> <code>get_topological_order</code> <p>Calculate topological ordering</p> <code>remove_unconnected_subgraphs</code> <p>Remove disconnected components from graph</p>"},{"location":"api/graph/#onshape_robotics_toolkit.graph.KinematicGraph","title":"<code>KinematicGraph</code>","text":"<p>               Bases: <code>DiGraph</code></p> <p>kinematic graph representation of an assembly using PathKey-based system.</p> <p>This class creates a directed graph from CAD assembly data where: - Nodes: Parts involved in mates (PathKey identifiers) - Edges: Mate relationships between parts - Root: Determined by closeness centrality or user-defined fixed part</p> <p>The tree supports: - Topological ordering for kinematic chains - Root node detection via centrality or user preference - Disconnected subgraph removal - Visualization</p> <p>Attributes:</p> Name Type Description <code>cad</code> <p>CAD assembly data with PathKey-based registries</p> <code>root_node</code> <p>PathKey of the root node in the kinematic graph</p> <code>topological_order</code> <p>Ordered sequence of nodes from root to leaves</p> Source code in <code>onshape_robotics_toolkit/graph.py</code> <pre><code>class KinematicGraph(nx.DiGraph):\n    \"\"\"\n    kinematic graph representation of an assembly using PathKey-based system.\n\n    This class creates a directed graph from CAD assembly data where:\n    - Nodes: Parts involved in mates (PathKey identifiers)\n    - Edges: Mate relationships between parts\n    - Root: Determined by closeness centrality or user-defined fixed part\n\n    The tree supports:\n    - Topological ordering for kinematic chains\n    - Root node detection via centrality or user preference\n    - Disconnected subgraph removal\n    - Visualization\n\n    Attributes:\n        cad: CAD assembly data with PathKey-based registries\n        root_node: PathKey of the root node in the kinematic graph\n        topological_order: Ordered sequence of nodes from root to leaves\n    \"\"\"\n\n    # TODO: make sure we are not mutating classes and instead creating copies\n    # refactor any method that mutates data in place and creates a destructive change\n\n    def __init__(self, cad: CAD):\n        \"\"\"\n        Initialize kinematic graph from CAD data.\n\n        Note: The preferred way to create a KinematicGraph is via the `from_cad()`\n        classmethod, which makes the construction more explicit and allows\n        configuring root node detection.\n\n        Args:\n            cad: CAD assembly with PathKey-based registries\n\n        Examples:\n            &gt;&gt;&gt; # Preferred (explicit):\n            &gt;&gt;&gt; graph = KinematicGraph.from_cad(cad, use_user_defined_root=True)\n\n            &gt;&gt;&gt; # Also works (backward compatible):\n            &gt;&gt;&gt; graph = KinematicGraph(cad)\n        \"\"\"\n        self.cad = cad\n        self.root: Optional[PathKey] = None\n\n        super().__init__()\n\n    @classmethod\n    def from_cad(cls, cad: CAD, use_user_defined_root: bool = True) -&gt; \"KinematicGraph\":\n        \"\"\"\n        Create and build kinematic graph from CAD assembly.\n\n        This is the recommended way to create a KinematicGraph. It constructs\n        the graph by processing mates, validating PathKeys, and determining\n        the kinematic structure.\n\n        Args:\n            cad: CAD assembly with PathKey-based registries\n            use_user_defined_root: Whether to use user-marked fixed part as root\n\n        Returns:\n            Fully constructed KinematicGraph with nodes, edges, and root\n\n        Examples:\n            &gt;&gt;&gt; cad = CAD.from_assembly(assembly, max_depth=1)\n            &gt;&gt;&gt; graph = KinematicGraph.from_cad(cad, use_user_defined_root=True)\n            &gt;&gt;&gt; print(f\"Root: {graph.root_node}\")\n            &gt;&gt;&gt; print(f\"Nodes: {len(graph.graph.nodes)}\")\n        \"\"\"\n        kinematic_graph = cls(cad=cad)\n        kinematic_graph._build_graph(use_user_defined_root)\n\n        record_kinematics_config(use_user_defined_root=use_user_defined_root)\n\n        return kinematic_graph\n\n    def _build_graph(self, use_user_defined_root: bool) -&gt; None:\n        \"\"\"\n        Build kinematic graph from CAD assembly data.\n\n        Process:\n        1. Collect all mates from root and subassemblies\n        2. Validate and filter mates (remove invalid PathKeys)\n        3. Get parts involved in valid mates\n        4. Add nodes for involved parts (with metadata)\n        5. Add edges from mate relationships\n\n        Args:\n            use_user_defined_root: Whether to use user-defined fixed part as root\n        \"\"\"\n        # remap the mates to switch out any parts that belong to rigid subassemblies\n        remapped_mates = self._remap_mates(self.cad)\n        involved_parts = self._get_parts_involved_in_mates(remapped_mates)\n\n        raw_graph = create_graph(\n            part_keys=involved_parts,\n            mates=remapped_mates,\n        )\n\n        self._process_graph(raw_graph, involved_parts, remapped_mates, use_user_defined_root)\n\n        if len(self.nodes) == 0:\n            logger.warning(\"KinematicGraph is empty - no valid parts found in mates\")\n            return\n\n        logger.info(\n            f\"KinematicGraph processed: {len(self.nodes)} nodes, \"\n            f\"{len(self.edges)} edges with root node: {self.root}\"\n        )\n\n    def _process_graph(\n        self,\n        raw_graph: nx.Graph,\n        parts: set[PathKey],\n        mates: dict[tuple[PathKey, PathKey], MateFeatureData],\n        use_user_defined_root: bool,\n    ) -&gt; None:\n        \"\"\"\n        Process the graph:\n            1. Remove disconnected subgraphs\n            2. Convert to directed graph with root detection\n            3. Calculate topological order\n        \"\"\"\n        # remove disconnected subgraphs\n        graph = remove_disconnected_subgraphs(raw_graph)\n\n        # Handle empty graph case (assemblies with only mate groups and no fixed/rigid parts)\n        if len(graph.nodes) == 0:\n            logger.warning(\n                \"Graph has no nodes - assembly contains only mate groups with no rigid assemblies or fixed parts. \"\n                \"Cannot create kinematic graph.\"\n            )\n            return\n\n        # Handle single-node graph case (e.g., single rigid assembly from mate groups)\n        if len(graph.nodes) == 1:\n            logger.info(\"Graph has single node - this is a fully rigid assembly (one link, no joints)\")\n            single_node = next(iter(graph.nodes))\n            self.root = single_node\n            part = self.cad.parts[single_node]\n            self.add_node(single_node, data=part)\n            return\n\n        self._find_root_node(\n            graph=graph,\n            parts=parts,\n            use_user_defined_root=use_user_defined_root,\n        )\n\n        bfs_graph = nx.bfs_tree(graph, self.root)\n        # NOTE: add all nodes in the BFS order\n        for node in bfs_graph.nodes:\n            part = self.cad.parts[node]\n            self.add_node(\n                node,\n                data=part,\n            )\n\n        for u, v in list(bfs_graph.edges()):\n            # NOTE: if raw graph has edge u-&gt;v, then mates also has (u,v) key, right?\n            # NOOOO, since the graph is undirected, the edge could be (v,u) instead\n            # even though we added the edge as (u,v), hence we use the mates dict\n            # instead to check the original parent-&gt;child order\n            if (u, v) in mates:\n                mate = copy.deepcopy(mates[(u, v)])\n                self.add_edge(\n                    u,\n                    v,\n                    data=mate,\n                )\n            elif (v, u) in mates:\n                # the mate parent-&gt;child order has flipped\n                mate = copy.deepcopy(mates[(v, u)])\n                mate.matedEntities.reverse()\n                # NOTE: we are mutating the mate data here, but\n                # preserving the BFS tree parent-&gt;child order\n                self.add_edge(\n                    u,\n                    v,\n                    data=mate,\n                )\n\n        # Add back any edges not in BFS tree (loops, etc.)\n        for u, v in mates:\n            if not bfs_graph.has_edge(u, v) and not bfs_graph.has_edge(v, u):\n                # preserve the original parent-&gt;child order\n                self.add_edge(\n                    u,\n                    v,\n                    data=mates[(u, v)],\n                )\n\n    def _remap_mates(self, cad: CAD) -&gt; dict[tuple[PathKey, PathKey], MateFeatureData]:\n        \"\"\"\n        Remap mates to replace parts that belong to rigid subassemblies with the rigid assembly part\n\n        Args:\n            cad (CAD): The CAD assembly generated from Onshape data\n\n        Returns:\n            dict[tuple[PathKey, PathKey], MateFeatureData]: A mapping of original mate paths\n            (w/o assembly keys) to their remapped counterparts\n        \"\"\"\n\n        def remap_mate(key: PathKey, index: int, mate: MateFeatureData) -&gt; PathKey:\n            \"\"\"\n            Return the rigid assembly root key if the part is inside a rigid assembly,\n            otherwise return the original key.\n            \"\"\"\n            r_key: PathKey = key\n            part = cad.parts[key]\n            if part.rigidAssemblyKey is not None:\n                r_key = part.rigidAssemblyKey\n                # NOTE: this is where we remap the matedOccurrence as well\n                mated_part_entity = mate.matedEntities[index]\n                mated_part_entity.matedOccurrence = list(r_key.path)\n\n                if part.rigidAssemblyToPartTF is None:\n                    logger.warning(\n                        f\"Part {key} belongs to rigid assembly {r_key} but has no rigidAssemblyToPartTF set. \\n\"\n                        \"This will result in malformed joints that have refer to parts within rigid assemblies.\"\n                    )\n                    return r_key\n\n                # MatedCS remapping from part-&gt;mate to rigid_root-&gt;mate\n                mated_part_entity.matedCS = MatedCS.from_tf(\n                    part.rigidAssemblyToPartTF.to_tf @ mated_part_entity.matedCS.to_tf\n                )\n\n            return r_key\n\n        remapped_mates: dict[tuple[PathKey, PathKey], MateFeatureData] = {}\n        # CAD's mates are already filtered and validated, they only include mates that\n        # need to be processed for robot generation\n        for (_, *entities), mate in cad.mates.items():\n            _mate_data = copy.deepcopy(mate)\n            remapped_keys = []\n\n            for i, key in enumerate(entities):\n                # NOTE: mate data's matedEntities have matedOccurrences that need to\n                # be remapped as well in addition to the keys\n                remapped_key = remap_mate(key, i, _mate_data)\n                remapped_keys.append(remapped_key)\n\n            remapped_mate_key: tuple[PathKey, PathKey] = tuple(remapped_keys)  # type: ignore[assignment]\n            if remapped_mate_key in remapped_mates:\n                logger.warning(\n                    \"Duplicate mate detected after remapping: %s -&gt; %s. \"\n                    \"This can happen if multiple parts in a rigid assembly are mated to the same part. \"\n                    \"Only the first mate will be kept.\",\n                    remapped_mate_key[PARENT],\n                    remapped_mate_key[CHILD],\n                )\n                continue\n\n            remapped_mates[remapped_mate_key] = _mate_data\n        return remapped_mates\n\n    def _is_root_assembly_rigid(self) -&gt; bool:\n        \"\"\"\n        Check if the root assembly should be treated as rigid.\n\n        Root assembly is rigid if it has only mate groups (no regular mates).\n        This is indicated by having 0 mates in cad.mates at the root level.\n\n        Returns:\n            True if root assembly has only mate groups, False otherwise\n        \"\"\"\n        # Check if root assembly has any regular mates (not from subassemblies)\n        root_mates = [\n            mate\n            for (assembly_key, _, _), mate in self.cad.mates.items()\n            if assembly_key is None  # Root level mates\n        ]\n\n        has_root_mates = len(root_mates) &gt; 0\n\n        if not has_root_mates:\n            logger.debug(\"Root assembly has no regular mates - checking features\")\n            # No mates at root level means root is rigid (only mate groups)\n            return True\n\n        return False\n\n    def _get_parts_involved_in_mates(self, mates: dict[tuple[PathKey, PathKey], MateFeatureData]) -&gt; set[PathKey]:\n        \"\"\"\n        Extract all part PathKeys that should be nodes in the kinematic graph.\n\n        This includes:\n        1. Parts involved in mates (normal case)\n        2. When root is rigid: single node representing entire assembly\n        3. When root has mates: rigid assemblies and root-level parts as separate nodes\n\n        Args:\n            mates: Dictionary of mate relationships\n\n        Returns:\n            Set of PathKeys for parts that should be graph nodes\n        \"\"\"\n        involved_parts: set[PathKey] = set()\n\n        # Add parts involved in mates\n        for parent_key, child_key in mates:\n            involved_parts.add(parent_key)\n            involved_parts.add(child_key)\n\n        # If no mates exist, check if root assembly is rigid\n        if len(mates) == 0:\n            root_is_rigid = self._is_root_assembly_rigid()\n\n            if root_is_rigid:\n                logger.info(\n                    \"Root assembly is rigid (only mate groups) - entire assembly will be one node. \"\n                    \"All parts and subassemblies merged into single rigid body.\"\n                )\n                # Pick one representative node for the entire rigid assembly\n                # Priority: fixed parts &gt; rigid subassemblies &gt; first root part\n                for part_key, _ in self.cad.parts.items():\n                    occurrence = self.cad.occurrences.get(part_key)\n                    if occurrence and occurrence.fixed:\n                        involved_parts.add(part_key)\n                        logger.debug(f\"Using fixed part as root for rigid assembly: {part_key}\")\n                        break\n\n                if len(involved_parts) == 0:\n                    for part_key, part in self.cad.parts.items():\n                        if part.isRigidAssembly:\n                            involved_parts.add(part_key)\n                            logger.debug(f\"Using rigid subassembly as root: {part_key}\")\n                            break\n\n                if len(involved_parts) == 0:\n                    for part_key, _ in self.cad.parts.items():\n                        if part_key.depth == 0:\n                            involved_parts.add(part_key)\n                            logger.debug(f\"Using first root part as root: {part_key}\")\n                            break\n            else:\n                logger.debug(\"Root not rigid - adding parts as separate nodes\")\n                for part_key, part in self.cad.parts.items():\n                    if part.isRigidAssembly:\n                        involved_parts.add(part_key)\n                        logger.debug(f\"Adding rigid assembly as node: {part_key}\")\n                    elif part_key.depth == 0:\n                        involved_parts.add(part_key)\n                        logger.debug(f\"Adding root-level part as node: {part_key}\")\n                    else:\n                        occurrence = self.cad.occurrences.get(part_key)\n                        if occurrence and occurrence.fixed:\n                            involved_parts.add(part_key)\n                            logger.debug(f\"Adding fixed part as node: {part_key}\")\n\n        logger.debug(f\"Found {len(involved_parts)} parts to include in graph\")\n        return involved_parts\n\n    def _find_root_node(self, graph: nx.Graph, parts: set[PathKey], use_user_defined_root: bool) -&gt; None:\n        \"\"\"\n        Find user-defined root part (marked as fixed in Onshape).\n\n        Args:\n            involved_parts: Set of parts to search within\n\n        Returns:\n            PathKey of fixed part, or None if not found\n        \"\"\"\n        root = None\n        if use_user_defined_root:\n            for part_key in parts:\n                occurrence = self.cad.occurrences.get(part_key)\n                if occurrence and occurrence.fixed:\n                    logger.debug(f\"Found user-defined root: {part_key}\")\n                    root = part_key\n                    self.root = root\n                    break\n\n            if root is None:\n                logger.warning(\"No user-defined root part found (marked as fixed in Onshape), auto-detecting root\")\n                self._find_root_node(graph, parts, use_user_defined_root=False)\n        else:\n            centrality = nx.closeness_centrality(graph)\n            root = max(centrality, key=lambda x: centrality[x])\n            if root:\n                self.root = root\n                logger.debug(f\"Auto-detected root node: {root}\")\n            else:\n                logger.warning(\"Could not determine root node via topological sort\")\n\n    def show(self, file_name: Optional[str] = None, graph: Optional[Union[nx.Graph, nx.DiGraph]] = None) -&gt; None:\n        \"\"\"\n        Visualize the kinematic graph with part names as labels instead of PathKey IDs.\n\n        Creates a more readable visualization by mapping PathKeys to their corresponding\n        part or assembly names from the CAD instance registry.\n\n        Args:\n            file_name: Optional filename to save visualization. If None, displays interactively.\n            graph: Optional graph to visualize. If None, uses the current graph.\n\n        Examples:\n            &gt;&gt;&gt; tree.show()  # Display interactively with names\n            &gt;&gt;&gt; tree.show(\"kinematic_tree.png\")  # Save to file with names\n        \"\"\"\n        if file_name is None:\n            file_name = get_sanitized_name(self.cad.name if self.cad.name else \"kinematic_graph\")\n\n        if graph is None:\n            graph = self\n\n        colors = [f\"#{random.randint(0, 0xFFFFFF):06x}\" for _ in range(len(graph.nodes))]  # noqa: S311\n        plt.figure(figsize=(8, 8))\n        pos = nx.planar_layout(graph)\n\n        nx.draw(\n            graph,\n            pos,\n            with_labels=True,\n            node_color=colors,\n            edge_color=\"white\",\n            font_color=\"white\",\n        )\n        plt.savefig(file_name, transparent=True)\n        plt.close()\n</code></pre>"},{"location":"api/graph/#onshape_robotics_toolkit.graph.KinematicGraph.__init__","title":"<code>__init__(cad)</code>","text":"<p>Initialize kinematic graph from CAD data.</p> <p>Note: The preferred way to create a KinematicGraph is via the <code>from_cad()</code> classmethod, which makes the construction more explicit and allows configuring root node detection.</p> <p>Parameters:</p> Name Type Description Default <code>cad</code> <code>CAD</code> <p>CAD assembly with PathKey-based registries</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Preferred (explicit):\n&gt;&gt;&gt; graph = KinematicGraph.from_cad(cad, use_user_defined_root=True)\n</code></pre> <pre><code>&gt;&gt;&gt; # Also works (backward compatible):\n&gt;&gt;&gt; graph = KinematicGraph(cad)\n</code></pre> Source code in <code>onshape_robotics_toolkit/graph.py</code> <pre><code>def __init__(self, cad: CAD):\n    \"\"\"\n    Initialize kinematic graph from CAD data.\n\n    Note: The preferred way to create a KinematicGraph is via the `from_cad()`\n    classmethod, which makes the construction more explicit and allows\n    configuring root node detection.\n\n    Args:\n        cad: CAD assembly with PathKey-based registries\n\n    Examples:\n        &gt;&gt;&gt; # Preferred (explicit):\n        &gt;&gt;&gt; graph = KinematicGraph.from_cad(cad, use_user_defined_root=True)\n\n        &gt;&gt;&gt; # Also works (backward compatible):\n        &gt;&gt;&gt; graph = KinematicGraph(cad)\n    \"\"\"\n    self.cad = cad\n    self.root: Optional[PathKey] = None\n\n    super().__init__()\n</code></pre>"},{"location":"api/graph/#onshape_robotics_toolkit.graph.KinematicGraph.from_cad","title":"<code>from_cad(cad, use_user_defined_root=True)</code>  <code>classmethod</code>","text":"<p>Create and build kinematic graph from CAD assembly.</p> <p>This is the recommended way to create a KinematicGraph. It constructs the graph by processing mates, validating PathKeys, and determining the kinematic structure.</p> <p>Parameters:</p> Name Type Description Default <code>cad</code> <code>CAD</code> <p>CAD assembly with PathKey-based registries</p> required <code>use_user_defined_root</code> <code>bool</code> <p>Whether to use user-marked fixed part as root</p> <code>True</code> <p>Returns:</p> Type Description <code>KinematicGraph</code> <p>Fully constructed KinematicGraph with nodes, edges, and root</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cad = CAD.from_assembly(assembly, max_depth=1)\n&gt;&gt;&gt; graph = KinematicGraph.from_cad(cad, use_user_defined_root=True)\n&gt;&gt;&gt; print(f\"Root: {graph.root_node}\")\n&gt;&gt;&gt; print(f\"Nodes: {len(graph.graph.nodes)}\")\n</code></pre> Source code in <code>onshape_robotics_toolkit/graph.py</code> <pre><code>@classmethod\ndef from_cad(cls, cad: CAD, use_user_defined_root: bool = True) -&gt; \"KinematicGraph\":\n    \"\"\"\n    Create and build kinematic graph from CAD assembly.\n\n    This is the recommended way to create a KinematicGraph. It constructs\n    the graph by processing mates, validating PathKeys, and determining\n    the kinematic structure.\n\n    Args:\n        cad: CAD assembly with PathKey-based registries\n        use_user_defined_root: Whether to use user-marked fixed part as root\n\n    Returns:\n        Fully constructed KinematicGraph with nodes, edges, and root\n\n    Examples:\n        &gt;&gt;&gt; cad = CAD.from_assembly(assembly, max_depth=1)\n        &gt;&gt;&gt; graph = KinematicGraph.from_cad(cad, use_user_defined_root=True)\n        &gt;&gt;&gt; print(f\"Root: {graph.root_node}\")\n        &gt;&gt;&gt; print(f\"Nodes: {len(graph.graph.nodes)}\")\n    \"\"\"\n    kinematic_graph = cls(cad=cad)\n    kinematic_graph._build_graph(use_user_defined_root)\n\n    record_kinematics_config(use_user_defined_root=use_user_defined_root)\n\n    return kinematic_graph\n</code></pre>"},{"location":"api/graph/#onshape_robotics_toolkit.graph.KinematicGraph.show","title":"<code>show(file_name=None, graph=None)</code>","text":"<p>Visualize the kinematic graph with part names as labels instead of PathKey IDs.</p> <p>Creates a more readable visualization by mapping PathKeys to their corresponding part or assembly names from the CAD instance registry.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>Optional[str]</code> <p>Optional filename to save visualization. If None, displays interactively.</p> <code>None</code> <code>graph</code> <code>Optional[Union[Graph, DiGraph]]</code> <p>Optional graph to visualize. If None, uses the current graph.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tree.show()  # Display interactively with names\n&gt;&gt;&gt; tree.show(\"kinematic_tree.png\")  # Save to file with names\n</code></pre> Source code in <code>onshape_robotics_toolkit/graph.py</code> <pre><code>def show(self, file_name: Optional[str] = None, graph: Optional[Union[nx.Graph, nx.DiGraph]] = None) -&gt; None:\n    \"\"\"\n    Visualize the kinematic graph with part names as labels instead of PathKey IDs.\n\n    Creates a more readable visualization by mapping PathKeys to their corresponding\n    part or assembly names from the CAD instance registry.\n\n    Args:\n        file_name: Optional filename to save visualization. If None, displays interactively.\n        graph: Optional graph to visualize. If None, uses the current graph.\n\n    Examples:\n        &gt;&gt;&gt; tree.show()  # Display interactively with names\n        &gt;&gt;&gt; tree.show(\"kinematic_tree.png\")  # Save to file with names\n    \"\"\"\n    if file_name is None:\n        file_name = get_sanitized_name(self.cad.name if self.cad.name else \"kinematic_graph\")\n\n    if graph is None:\n        graph = self\n\n    colors = [f\"#{random.randint(0, 0xFFFFFF):06x}\" for _ in range(len(graph.nodes))]  # noqa: S311\n    plt.figure(figsize=(8, 8))\n    pos = nx.planar_layout(graph)\n\n    nx.draw(\n        graph,\n        pos,\n        with_labels=True,\n        node_color=colors,\n        edge_color=\"white\",\n        font_color=\"white\",\n    )\n    plt.savefig(file_name, transparent=True)\n    plt.close()\n</code></pre>"},{"location":"api/graph/#onshape_robotics_toolkit.graph.convert_to_digraph","title":"<code>convert_to_digraph(graph, user_defined_root=None)</code>","text":"<p>Convert a graph to a directed graph and calculate the root node using closeness centrality.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>The graph to convert.</p> required <code>user_defined_root</code> <code>Optional[PathKey]</code> <p>The node to use as the root node.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[DiGraph, PathKey]</code> <p>The directed graph and the root node of the graph, calculated using closeness centrality.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; graph = nx.Graph()\n&gt;&gt;&gt; convert_to_digraph(graph)\n(digraph, root_node)\n</code></pre> Source code in <code>onshape_robotics_toolkit/graph.py</code> <pre><code>def convert_to_digraph(graph: nx.Graph, user_defined_root: Optional[PathKey] = None) -&gt; tuple[nx.DiGraph, PathKey]:\n    \"\"\"\n    Convert a graph to a directed graph and calculate the root node using closeness centrality.\n\n    Args:\n        graph: The graph to convert.\n        user_defined_root: The node to use as the root node.\n\n    Returns:\n        The directed graph and the root node of the graph, calculated using closeness centrality.\n\n    Examples:\n        &gt;&gt;&gt; graph = nx.Graph()\n        &gt;&gt;&gt; convert_to_digraph(graph)\n        (digraph, root_node)\n    \"\"\"\n\n    centrality = nx.closeness_centrality(graph)\n    root_node = user_defined_root if user_defined_root else max(centrality, key=lambda x: centrality[x])\n\n    # Create BFS tree from root (this loses edge data!)\n    bfs_graph = nx.bfs_tree(graph, root_node)\n    di_graph = nx.DiGraph(bfs_graph)\n\n    # Restore edge data for BFS tree edges from original graph\n    for u, v in list(di_graph.edges()):\n        if graph.has_edge(u, v):\n            # Copy edge data from original undirected graph\n            di_graph[u][v].update(graph[u][v])\n        elif graph.has_edge(v, u):\n            # Edge might be reversed in undirected graph\n            di_graph[u][v].update(graph[v][u])\n\n    # Add back any edges not in BFS tree (loops, etc.)\n    for u, v, data in graph.edges(data=True):\n        if not di_graph.has_edge(u, v) and not di_graph.has_edge(v, u):\n            # Decide which direction to keep based on centrality\n            if centrality[u] &gt; centrality[v]:\n                di_graph.add_edge(u, v, **data)\n            else:\n                di_graph.add_edge(v, u, **data)\n\n    return di_graph, root_node\n</code></pre>"},{"location":"api/graph/#onshape_robotics_toolkit.graph.remove_disconnected_subgraphs","title":"<code>remove_disconnected_subgraphs(graph)</code>","text":"<p>Remove unconnected subgraphs from the graph.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>The graph to remove unconnected subgraphs from.</p> required <p>Returns:</p> Type Description <code>Graph</code> <p>The main connected subgraph of the graph, which is the largest connected subgraph.</p> Source code in <code>onshape_robotics_toolkit/graph.py</code> <pre><code>def remove_disconnected_subgraphs(graph: nx.Graph) -&gt; nx.Graph:\n    \"\"\"\n    Remove unconnected subgraphs from the graph.\n\n    Args:\n        graph: The graph to remove unconnected subgraphs from.\n\n    Returns:\n        The main connected subgraph of the graph, which is the largest connected subgraph.\n    \"\"\"\n    # Handle empty graph case (e.g., assemblies with only mate groups)\n    if len(graph.nodes) == 0:\n        logger.debug(\"Graph is empty (no nodes) - this may indicate an assembly with only mate groups\")\n        return graph\n\n    if not nx.is_connected(graph):\n        logger.warning(\"Graph has one or more unconnected subgraphs\")\n\n        # Show tree visualization of original graph\n        logger.info(\"Original graph structure:\")\n        _print_graph_tree(graph)\n\n        sub_graphs = list(nx.connected_components(graph))\n        main_graph_nodes = max(sub_graphs, key=len)\n        main_graph = graph.subgraph(main_graph_nodes).copy()\n\n        # Show tree visualization of reduced graph\n        logger.info(\"Reduced graph structure:\")\n        _print_graph_tree(main_graph)\n\n        logger.warning(f\"Reduced graph nodes from {len(graph.nodes)} to {len(main_graph.nodes)}\")\n        logger.warning(f\"Reduced graph edges from {len(graph.edges)} to {len(main_graph.edges)}\")\n        return main_graph\n    return graph\n</code></pre>"},{"location":"api/joint/","title":"Joint","text":"<p>This module contains classes for defining joints in a URDF robot model.</p> Class <ul> <li>BaseJoint: Abstract base class for joint objects.</li> <li>DummyJoint: Represents a dummy joint.</li> <li>RevoluteJoint: Represents a revolute joint.</li> <li>ContinuousJoint: Represents a continuous joint.</li> <li>PrismaticJoint: Represents a prismatic joint.</li> <li>FixedJoint: Represents a fixed joint.</li> <li>FloatingJoint: Represents a floating joint.</li> <li>PlanarJoint: Represents a planar joint.</li> </ul> Dataclass <ul> <li>JointLimits: Contains the limits for a joint.</li> <li>JointMimic: Contains the mimic information for a joint.</li> <li>JointDynamics: Contains the dynamics information for a joint.</li> <li>Axis: Contains the axis information for a joint.</li> <li>Origin: Contains the origin information for a joint.</li> </ul> Enum <ul> <li>JointType: Enumerates the possible joint types in Onshape (revolute, continuous, prismatic,   fixed, floating, planar).</li> </ul>"},{"location":"api/joint/#onshape_robotics_toolkit.models.joint.BaseJoint","title":"<code>BaseJoint</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for joint objects.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the joint.</p> <code>parent</code> <code>str</code> <p>The parent link of the joint.</p> <code>child</code> <code>str</code> <p>The child link of the joint.</p> <code>origin</code> <code>Origin</code> <p>The origin of the joint.</p> <p>Methods:</p> Name Description <code>to_xml</code> <p>Converts the joint to an XML element.</p> Abstract Properties <p>joint_type: Returns the type of the joint.</p> Source code in <code>onshape_robotics_toolkit/models/joint.py</code> <pre><code>@dataclass\nclass BaseJoint(ABC):\n    \"\"\"\n    Abstract base class for joint objects.\n\n    Attributes:\n        name (str): The name of the joint.\n        parent (str): The parent link of the joint.\n        child (str): The child link of the joint.\n        origin (Origin): The origin of the joint.\n\n    Methods:\n        to_xml: Converts the joint to an XML element.\n\n    Abstract Properties:\n        joint_type: Returns the type of the joint.\n    \"\"\"\n\n    name: str\n    parent: str\n    child: str\n    origin: Origin\n\n    def to_xml(self, root: Optional[_Element] = None) -&gt; _Element:\n        \"\"\"\n        Convert the joint to an XML element.\n\n        Args:\n            root: The root element to append the joint to.\n\n        Returns:\n            The XML element representing the joint.\n        \"\"\"\n\n        joint = ETreeElement(\"joint\") if root is None else SubElement(root, \"joint\")\n        joint.set(\"name\", self.name)\n        joint.set(\"type\", self.joint_type)\n        self.origin.to_xml(joint)\n        SubElement(joint, \"parent\", link=self.parent)\n        SubElement(joint, \"child\", link=self.child)\n        return joint\n\n    def to_mjcf(self, root: _Element) -&gt; None:\n        \"\"\"\n        Converts the joint to an XML element and appends it to the given root element.\n\n        Args:\n            root: The root element to append the joint to.\n        \"\"\"\n\n        joint: _Element = SubElement(root, \"joint\", name=self.name, type=MJCF_JOINT_MAP[JointType(self.joint_type)])\n        joint.set(\"pos\", \" \".join(map(str, self.origin.xyz)))\n\n    @property\n    @abstractmethod\n    def joint_type(self) -&gt; str: ...\n\n    @classmethod\n    @abstractmethod\n    def from_xml(cls, element: _Element) -&gt; \"BaseJoint\": ...\n</code></pre>"},{"location":"api/joint/#onshape_robotics_toolkit.models.joint.BaseJoint.to_mjcf","title":"<code>to_mjcf(root)</code>","text":"<p>Converts the joint to an XML element and appends it to the given root element.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>_Element</code> <p>The root element to append the joint to.</p> required Source code in <code>onshape_robotics_toolkit/models/joint.py</code> <pre><code>def to_mjcf(self, root: _Element) -&gt; None:\n    \"\"\"\n    Converts the joint to an XML element and appends it to the given root element.\n\n    Args:\n        root: The root element to append the joint to.\n    \"\"\"\n\n    joint: _Element = SubElement(root, \"joint\", name=self.name, type=MJCF_JOINT_MAP[JointType(self.joint_type)])\n    joint.set(\"pos\", \" \".join(map(str, self.origin.xyz)))\n</code></pre>"},{"location":"api/joint/#onshape_robotics_toolkit.models.joint.BaseJoint.to_xml","title":"<code>to_xml(root=None)</code>","text":"<p>Convert the joint to an XML element.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>Optional[_Element]</code> <p>The root element to append the joint to.</p> <code>None</code> <p>Returns:</p> Type Description <code>_Element</code> <p>The XML element representing the joint.</p> Source code in <code>onshape_robotics_toolkit/models/joint.py</code> <pre><code>def to_xml(self, root: Optional[_Element] = None) -&gt; _Element:\n    \"\"\"\n    Convert the joint to an XML element.\n\n    Args:\n        root: The root element to append the joint to.\n\n    Returns:\n        The XML element representing the joint.\n    \"\"\"\n\n    joint = ETreeElement(\"joint\") if root is None else SubElement(root, \"joint\")\n    joint.set(\"name\", self.name)\n    joint.set(\"type\", self.joint_type)\n    self.origin.to_xml(joint)\n    SubElement(joint, \"parent\", link=self.parent)\n    SubElement(joint, \"child\", link=self.child)\n    return joint\n</code></pre>"},{"location":"api/joint/#onshape_robotics_toolkit.models.joint.ContinuousJoint","title":"<code>ContinuousJoint</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseJoint</code></p> <p>Represents a continuous joint.</p> <p>Attributes:</p> Name Type Description <code>mimic</code> <code>JointMimic</code> <p>The mimic information for the joint.</p> <p>Methods:</p> Name Description <code>to_xml</code> <p>Converts the continuous joint to an XML element.</p> Properties <p>joint_type: The type of the joint.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n&gt;&gt;&gt; mimic = JointMimic(joint=\"joint1\", multiplier=1.0, offset=0.0)\n&gt;&gt;&gt; joint = ContinuousJoint(\n...     name=\"joint1\",\n...     parent=\"base_link\",\n...     child=\"link1\",\n...     origin=origin,\n...     mimic=mimic,\n... )\n&gt;&gt;&gt; joint.to_xml()\n&lt;Element 'joint' at 0x7f8b3c0b4c70&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/joint.py</code> <pre><code>@dataclass\nclass ContinuousJoint(BaseJoint):\n    \"\"\"\n    Represents a continuous joint.\n\n    Attributes:\n        mimic (JointMimic): The mimic information for the joint.\n\n    Methods:\n        to_xml: Converts the continuous joint to an XML element.\n\n    Properties:\n        joint_type: The type of the joint.\n\n    Examples:\n        &gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n        &gt;&gt;&gt; mimic = JointMimic(joint=\"joint1\", multiplier=1.0, offset=0.0)\n        &gt;&gt;&gt; joint = ContinuousJoint(\n        ...     name=\"joint1\",\n        ...     parent=\"base_link\",\n        ...     child=\"link1\",\n        ...     origin=origin,\n        ...     mimic=mimic,\n        ... )\n        &gt;&gt;&gt; joint.to_xml()\n        &lt;Element 'joint' at 0x7f8b3c0b4c70&gt;\n    \"\"\"\n\n    mimic: JointMimic | None = None\n\n    def to_xml(self, root: Optional[_Element] = None) -&gt; _Element:\n        \"\"\"\n        Convert the continuous joint to an XML element.\n\n        Args:\n            root: The root element to append the continuous joint to.\n\n        Returns:\n            The XML element representing the continuous joint.\n\n        Examples:\n            &gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n            &gt;&gt;&gt; mimic = JointMimic(joint=\"joint1\", multiplier=1.0, offset=0.0)\n            &gt;&gt;&gt; joint = ContinuousJoint(\n            ...     name=\"joint1\",\n            ...     parent=\"base_link\",\n            ...     child=\"link1\",\n            ...     origin=origin,\n            ...     mimic=mimic,\n            ... )\n            &gt;&gt;&gt; joint.to_xml()\n            &lt;Element 'joint' at 0x7f8b3c0b4c70&gt;\n        \"\"\"\n\n        joint = super().to_xml(root)\n        if self.mimic is not None:\n            self.mimic.to_xml(joint)\n        return joint\n\n    def to_mjcf(self, root: _Element) -&gt; None:\n        return super().to_mjcf(root)\n\n    @classmethod\n    def from_xml(cls, element: _Element) -&gt; \"ContinuousJoint\":\n        \"\"\"\n        Create a continuous joint from an XML element.\n\n        Args:\n            element: The XML element to create the continuous joint from.\n\n        Returns:\n            The continuous joint created from the XML element.\n\n        Examples:\n            &gt;&gt;&gt; element = ET.Element(\"joint\")\n            &gt;&gt;&gt; element.set(\"name\", \"joint1\")\n            &gt;&gt;&gt; element.set(\"type\", \"continuous\")\n            &gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n            &gt;&gt;&gt; ET.SubElement(element, \"origin\", xyz=\"0 0 0\", rpy=\"0 0 0\")\n            &gt;&gt;&gt; ET.SubElement(element, \"parent\", link=\"base_link\")\n            &gt;&gt;&gt; ET.SubElement(element, \"child\", link=\"link1\")\n            &gt;&gt;&gt; mimic = ET.SubElement(element, \"mimic\", joint=\"joint1\", multiplier=\"1.0\", offset=\"0.0\")\n            &gt;&gt;&gt; ContinuousJoint.from_xml(element)\n\n            ContinuousJoint(\n                name=\"joint1\",\n                parent=\"base_link\",\n                child=\"link1\",\n                origin=Origin(xyz=(0, 0, 0), rpy=(0, 0, 0)),\n                mimic=JointMimic(joint=\"joint1\", multiplier=1.0, offset=0.0)\n            )\n        \"\"\"\n\n        name = element.attrib[\"name\"]\n        parent_elem = element.find(\"parent\")\n        child_elem = element.find(\"child\")\n        origin_elem = element.find(\"origin\")\n\n        if parent_elem is None or child_elem is None or origin_elem is None:\n            raise ValueError(\"Missing required elements in joint XML\")\n\n        parent = parent_elem.attrib[\"link\"]\n        child = child_elem.attrib[\"link\"]\n        origin = Origin.from_xml(origin_elem)\n\n        # Handle mimic\n        mimic_element = element.find(\"mimic\")\n        mimic = JointMimic.from_xml(mimic_element) if mimic_element is not None else None\n\n        return cls(name, parent, child, origin, mimic)\n\n    @property\n    def joint_type(self) -&gt; str:\n        \"\"\"\n        The type of the joint.\n\n        Returns:\n            The type of the joint: \"continuous\".\n        \"\"\"\n\n        return JointType.CONTINUOUS\n</code></pre>"},{"location":"api/joint/#onshape_robotics_toolkit.models.joint.ContinuousJoint.joint_type","title":"<code>joint_type</code>  <code>property</code>","text":"<p>The type of the joint.</p> <p>Returns:</p> Type Description <code>str</code> <p>The type of the joint: \"continuous\".</p>"},{"location":"api/joint/#onshape_robotics_toolkit.models.joint.ContinuousJoint.from_xml","title":"<code>from_xml(element)</code>  <code>classmethod</code>","text":"<p>Create a continuous joint from an XML element.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>_Element</code> <p>The XML element to create the continuous joint from.</p> required <p>Returns:</p> Type Description <code>ContinuousJoint</code> <p>The continuous joint created from the XML element.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; element = ET.Element(\"joint\")\n&gt;&gt;&gt; element.set(\"name\", \"joint1\")\n&gt;&gt;&gt; element.set(\"type\", \"continuous\")\n&gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n&gt;&gt;&gt; ET.SubElement(element, \"origin\", xyz=\"0 0 0\", rpy=\"0 0 0\")\n&gt;&gt;&gt; ET.SubElement(element, \"parent\", link=\"base_link\")\n&gt;&gt;&gt; ET.SubElement(element, \"child\", link=\"link1\")\n&gt;&gt;&gt; mimic = ET.SubElement(element, \"mimic\", joint=\"joint1\", multiplier=\"1.0\", offset=\"0.0\")\n&gt;&gt;&gt; ContinuousJoint.from_xml(element)\n</code></pre> <p>ContinuousJoint(     name=\"joint1\",     parent=\"base_link\",     child=\"link1\",     origin=Origin(xyz=(0, 0, 0), rpy=(0, 0, 0)),     mimic=JointMimic(joint=\"joint1\", multiplier=1.0, offset=0.0) )</p> Source code in <code>onshape_robotics_toolkit/models/joint.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: _Element) -&gt; \"ContinuousJoint\":\n    \"\"\"\n    Create a continuous joint from an XML element.\n\n    Args:\n        element: The XML element to create the continuous joint from.\n\n    Returns:\n        The continuous joint created from the XML element.\n\n    Examples:\n        &gt;&gt;&gt; element = ET.Element(\"joint\")\n        &gt;&gt;&gt; element.set(\"name\", \"joint1\")\n        &gt;&gt;&gt; element.set(\"type\", \"continuous\")\n        &gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n        &gt;&gt;&gt; ET.SubElement(element, \"origin\", xyz=\"0 0 0\", rpy=\"0 0 0\")\n        &gt;&gt;&gt; ET.SubElement(element, \"parent\", link=\"base_link\")\n        &gt;&gt;&gt; ET.SubElement(element, \"child\", link=\"link1\")\n        &gt;&gt;&gt; mimic = ET.SubElement(element, \"mimic\", joint=\"joint1\", multiplier=\"1.0\", offset=\"0.0\")\n        &gt;&gt;&gt; ContinuousJoint.from_xml(element)\n\n        ContinuousJoint(\n            name=\"joint1\",\n            parent=\"base_link\",\n            child=\"link1\",\n            origin=Origin(xyz=(0, 0, 0), rpy=(0, 0, 0)),\n            mimic=JointMimic(joint=\"joint1\", multiplier=1.0, offset=0.0)\n        )\n    \"\"\"\n\n    name = element.attrib[\"name\"]\n    parent_elem = element.find(\"parent\")\n    child_elem = element.find(\"child\")\n    origin_elem = element.find(\"origin\")\n\n    if parent_elem is None or child_elem is None or origin_elem is None:\n        raise ValueError(\"Missing required elements in joint XML\")\n\n    parent = parent_elem.attrib[\"link\"]\n    child = child_elem.attrib[\"link\"]\n    origin = Origin.from_xml(origin_elem)\n\n    # Handle mimic\n    mimic_element = element.find(\"mimic\")\n    mimic = JointMimic.from_xml(mimic_element) if mimic_element is not None else None\n\n    return cls(name, parent, child, origin, mimic)\n</code></pre>"},{"location":"api/joint/#onshape_robotics_toolkit.models.joint.ContinuousJoint.to_xml","title":"<code>to_xml(root=None)</code>","text":"<p>Convert the continuous joint to an XML element.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>Optional[_Element]</code> <p>The root element to append the continuous joint to.</p> <code>None</code> <p>Returns:</p> Type Description <code>_Element</code> <p>The XML element representing the continuous joint.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n&gt;&gt;&gt; mimic = JointMimic(joint=\"joint1\", multiplier=1.0, offset=0.0)\n&gt;&gt;&gt; joint = ContinuousJoint(\n...     name=\"joint1\",\n...     parent=\"base_link\",\n...     child=\"link1\",\n...     origin=origin,\n...     mimic=mimic,\n... )\n&gt;&gt;&gt; joint.to_xml()\n&lt;Element 'joint' at 0x7f8b3c0b4c70&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/joint.py</code> <pre><code>def to_xml(self, root: Optional[_Element] = None) -&gt; _Element:\n    \"\"\"\n    Convert the continuous joint to an XML element.\n\n    Args:\n        root: The root element to append the continuous joint to.\n\n    Returns:\n        The XML element representing the continuous joint.\n\n    Examples:\n        &gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n        &gt;&gt;&gt; mimic = JointMimic(joint=\"joint1\", multiplier=1.0, offset=0.0)\n        &gt;&gt;&gt; joint = ContinuousJoint(\n        ...     name=\"joint1\",\n        ...     parent=\"base_link\",\n        ...     child=\"link1\",\n        ...     origin=origin,\n        ...     mimic=mimic,\n        ... )\n        &gt;&gt;&gt; joint.to_xml()\n        &lt;Element 'joint' at 0x7f8b3c0b4c70&gt;\n    \"\"\"\n\n    joint = super().to_xml(root)\n    if self.mimic is not None:\n        self.mimic.to_xml(joint)\n    return joint\n</code></pre>"},{"location":"api/joint/#onshape_robotics_toolkit.models.joint.DummyJoint","title":"<code>DummyJoint</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseJoint</code></p> <p>Represents a dummy joint.</p> Properties <p>joint_type: The type of the joint.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n&gt;&gt;&gt; joint = DummyJoint(\n...     name=\"joint1\",\n...     parent=\"base_link\",\n...     child=\"link1\",\n...     origin=origin,\n... )\n&gt;&gt;&gt; joint.joint_type\n'dummy'\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/joint.py</code> <pre><code>@dataclass\nclass DummyJoint(BaseJoint):\n    \"\"\"\n    Represents a dummy joint.\n\n    Properties:\n        joint_type: The type of the joint.\n\n    Examples:\n        &gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n        &gt;&gt;&gt; joint = DummyJoint(\n        ...     name=\"joint1\",\n        ...     parent=\"base_link\",\n        ...     child=\"link1\",\n        ...     origin=origin,\n        ... )\n        &gt;&gt;&gt; joint.joint_type\n        'dummy'\n    \"\"\"\n\n    @classmethod\n    def from_xml(cls, element: _Element) -&gt; \"DummyJoint\":\n        \"\"\"\n        Create a dummy joint from an XML element.\n\n        Args:\n            element: The XML element to create the dummy joint from.\n\n        Returns:\n            The dummy joint created from the XML element.\n\n        Examples:\n            &gt;&gt;&gt; element = ET.Element(\"joint\")\n            &gt;&gt;&gt; element.set(\"name\", \"joint1\")\n            &gt;&gt;&gt; element.set(\"type\", \"dummy\")\n            &gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n            &gt;&gt;&gt; ET.SubElement(element, \"origin\", xyz=\"0 0 0\", rpy=\"0 0 0\")\n            &gt;&gt;&gt; ET.SubElement(element, \"parent\", link=\"base_link\")\n            &gt;&gt;&gt; ET.SubElement(element, \"child\", link=\"link1\")\n            &gt;&gt;&gt; DummyJoint.from_xml(element)\n            DummyJoint(name=\"joint1\", parent=\"base_link\", child=\"link1\", origin=Origin(xyz=(0, 0, 0), rpy=(0, 0, 0)))\n        \"\"\"\n\n        name = element.attrib[\"name\"]\n        parent_elem = element.find(\"parent\")\n        child_elem = element.find(\"child\")\n        origin_elem = element.find(\"origin\")\n\n        if parent_elem is None or child_elem is None or origin_elem is None:\n            raise ValueError(\"Missing required elements in joint XML\")\n\n        parent = parent_elem.attrib[\"link\"]\n        child = child_elem.attrib[\"link\"]\n        origin = Origin.from_xml(origin_elem)\n        return cls(name, parent, child, origin)\n\n    @property\n    def joint_type(self) -&gt; str:\n        \"\"\"\n        The type of the joint.\n\n        Returns:\n            The type of the joint: \"dummy\".\n        \"\"\"\n\n        return \"dummy\"\n</code></pre>"},{"location":"api/joint/#onshape_robotics_toolkit.models.joint.DummyJoint.joint_type","title":"<code>joint_type</code>  <code>property</code>","text":"<p>The type of the joint.</p> <p>Returns:</p> Type Description <code>str</code> <p>The type of the joint: \"dummy\".</p>"},{"location":"api/joint/#onshape_robotics_toolkit.models.joint.DummyJoint.from_xml","title":"<code>from_xml(element)</code>  <code>classmethod</code>","text":"<p>Create a dummy joint from an XML element.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>_Element</code> <p>The XML element to create the dummy joint from.</p> required <p>Returns:</p> Type Description <code>DummyJoint</code> <p>The dummy joint created from the XML element.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; element = ET.Element(\"joint\")\n&gt;&gt;&gt; element.set(\"name\", \"joint1\")\n&gt;&gt;&gt; element.set(\"type\", \"dummy\")\n&gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n&gt;&gt;&gt; ET.SubElement(element, \"origin\", xyz=\"0 0 0\", rpy=\"0 0 0\")\n&gt;&gt;&gt; ET.SubElement(element, \"parent\", link=\"base_link\")\n&gt;&gt;&gt; ET.SubElement(element, \"child\", link=\"link1\")\n&gt;&gt;&gt; DummyJoint.from_xml(element)\nDummyJoint(name=\"joint1\", parent=\"base_link\", child=\"link1\", origin=Origin(xyz=(0, 0, 0), rpy=(0, 0, 0)))\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/joint.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: _Element) -&gt; \"DummyJoint\":\n    \"\"\"\n    Create a dummy joint from an XML element.\n\n    Args:\n        element: The XML element to create the dummy joint from.\n\n    Returns:\n        The dummy joint created from the XML element.\n\n    Examples:\n        &gt;&gt;&gt; element = ET.Element(\"joint\")\n        &gt;&gt;&gt; element.set(\"name\", \"joint1\")\n        &gt;&gt;&gt; element.set(\"type\", \"dummy\")\n        &gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n        &gt;&gt;&gt; ET.SubElement(element, \"origin\", xyz=\"0 0 0\", rpy=\"0 0 0\")\n        &gt;&gt;&gt; ET.SubElement(element, \"parent\", link=\"base_link\")\n        &gt;&gt;&gt; ET.SubElement(element, \"child\", link=\"link1\")\n        &gt;&gt;&gt; DummyJoint.from_xml(element)\n        DummyJoint(name=\"joint1\", parent=\"base_link\", child=\"link1\", origin=Origin(xyz=(0, 0, 0), rpy=(0, 0, 0)))\n    \"\"\"\n\n    name = element.attrib[\"name\"]\n    parent_elem = element.find(\"parent\")\n    child_elem = element.find(\"child\")\n    origin_elem = element.find(\"origin\")\n\n    if parent_elem is None or child_elem is None or origin_elem is None:\n        raise ValueError(\"Missing required elements in joint XML\")\n\n    parent = parent_elem.attrib[\"link\"]\n    child = child_elem.attrib[\"link\"]\n    origin = Origin.from_xml(origin_elem)\n    return cls(name, parent, child, origin)\n</code></pre>"},{"location":"api/joint/#onshape_robotics_toolkit.models.joint.FixedJoint","title":"<code>FixedJoint</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseJoint</code></p> <p>Represents a fixed joint.</p> <p>Methods:</p> Name Description <code>to_xml</code> <p>Converts the fixed joint to an XML element.</p> Properties <p>joint_type: The type of the joint.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n&gt;&gt;&gt; joint = FixedJoint(\n...     name=\"joint1\",\n...     parent=\"base_link\",\n...     child=\"link1\",\n...     origin=origin,\n... )\n&gt;&gt;&gt; joint.to_xml()\n&lt;Element 'joint' at 0x7f8b3c0b4c70&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/joint.py</code> <pre><code>@dataclass\nclass FixedJoint(BaseJoint):\n    \"\"\"\n    Represents a fixed joint.\n\n    Methods:\n        to_xml: Converts the fixed joint to an XML element.\n\n    Properties:\n        joint_type: The type of the joint.\n\n    Examples:\n        &gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n        &gt;&gt;&gt; joint = FixedJoint(\n        ...     name=\"joint1\",\n        ...     parent=\"base_link\",\n        ...     child=\"link1\",\n        ...     origin=origin,\n        ... )\n        &gt;&gt;&gt; joint.to_xml()\n        &lt;Element 'joint' at 0x7f8b3c0b4c70&gt;\n    \"\"\"\n\n    def to_xml(self, root: Optional[_Element] = None) -&gt; _Element:\n        \"\"\"\n        Convert the fixed joint to an XML element.\n\n        Args:\n            root: The root element to append the fixed joint to.\n\n        Returns:\n            The XML element representing the fixed joint.\n\n        Examples:\n            &gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n            &gt;&gt;&gt; joint = FixedJoint(\n            ...     name=\"joint1\",\n            ...     parent=\"base_link\",\n            ...     child=\"link1\",\n            ...     origin=origin,\n            ... )\n            &gt;&gt;&gt; joint.to_xml()\n            &lt;Element 'joint' at 0x7f8b3c0b4c70&gt;\n        \"\"\"\n\n        joint = super().to_xml(root)\n        return joint\n\n    @classmethod\n    def from_xml(cls, element: _Element) -&gt; \"FixedJoint\":\n        \"\"\"\n        Create a fixed joint from an XML element.\n\n        Args:\n            element: The XML element to create the fixed joint from.\n\n        Returns:\n            The fixed joint created from the XML element.\n\n        Examples:\n            &gt;&gt;&gt; element = ET.Element(\"joint\")\n            &gt;&gt;&gt; element.set(\"name\", \"joint1\")\n            &gt;&gt;&gt; element.set(\"type\", \"fixed\")\n            &gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n            &gt;&gt;&gt; ET.SubElement(element, \"origin\", xyz=\"0 0 0\", rpy=\"0 0 0\")\n            &gt;&gt;&gt; ET.SubElement(element, \"parent\", link=\"base_link\")\n            &gt;&gt;&gt; ET.SubElement(element, \"child\", link=\"link1\")\n            &gt;&gt;&gt; FixedJoint.from_xml(element)\n\n            FixedJoint(name=\"joint1\", parent=\"base_link\", child=\"link1\", origin=Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n        \"\"\"\n\n        name = element.attrib[\"name\"]\n        parent_elem = element.find(\"parent\")\n        child_elem = element.find(\"child\")\n        origin_elem = element.find(\"origin\")\n\n        if parent_elem is None or child_elem is None or origin_elem is None:\n            raise ValueError(\"Missing required elements in joint XML\")\n\n        parent = parent_elem.attrib[\"link\"]\n        child = child_elem.attrib[\"link\"]\n        origin = Origin.from_xml(origin_elem)\n        return cls(name, parent, child, origin)\n\n    @property\n    def joint_type(self) -&gt; str:\n        \"\"\"\n        The type of the joint.\n\n        Returns:\n            The type of the joint: \"fixed\".\n        \"\"\"\n\n        return JointType.FIXED\n</code></pre>"},{"location":"api/joint/#onshape_robotics_toolkit.models.joint.FixedJoint.joint_type","title":"<code>joint_type</code>  <code>property</code>","text":"<p>The type of the joint.</p> <p>Returns:</p> Type Description <code>str</code> <p>The type of the joint: \"fixed\".</p>"},{"location":"api/joint/#onshape_robotics_toolkit.models.joint.FixedJoint.from_xml","title":"<code>from_xml(element)</code>  <code>classmethod</code>","text":"<p>Create a fixed joint from an XML element.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>_Element</code> <p>The XML element to create the fixed joint from.</p> required <p>Returns:</p> Type Description <code>FixedJoint</code> <p>The fixed joint created from the XML element.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; element = ET.Element(\"joint\")\n&gt;&gt;&gt; element.set(\"name\", \"joint1\")\n&gt;&gt;&gt; element.set(\"type\", \"fixed\")\n&gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n&gt;&gt;&gt; ET.SubElement(element, \"origin\", xyz=\"0 0 0\", rpy=\"0 0 0\")\n&gt;&gt;&gt; ET.SubElement(element, \"parent\", link=\"base_link\")\n&gt;&gt;&gt; ET.SubElement(element, \"child\", link=\"link1\")\n&gt;&gt;&gt; FixedJoint.from_xml(element)\n</code></pre> <p>FixedJoint(name=\"joint1\", parent=\"base_link\", child=\"link1\", origin=Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))</p> Source code in <code>onshape_robotics_toolkit/models/joint.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: _Element) -&gt; \"FixedJoint\":\n    \"\"\"\n    Create a fixed joint from an XML element.\n\n    Args:\n        element: The XML element to create the fixed joint from.\n\n    Returns:\n        The fixed joint created from the XML element.\n\n    Examples:\n        &gt;&gt;&gt; element = ET.Element(\"joint\")\n        &gt;&gt;&gt; element.set(\"name\", \"joint1\")\n        &gt;&gt;&gt; element.set(\"type\", \"fixed\")\n        &gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n        &gt;&gt;&gt; ET.SubElement(element, \"origin\", xyz=\"0 0 0\", rpy=\"0 0 0\")\n        &gt;&gt;&gt; ET.SubElement(element, \"parent\", link=\"base_link\")\n        &gt;&gt;&gt; ET.SubElement(element, \"child\", link=\"link1\")\n        &gt;&gt;&gt; FixedJoint.from_xml(element)\n\n        FixedJoint(name=\"joint1\", parent=\"base_link\", child=\"link1\", origin=Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n    \"\"\"\n\n    name = element.attrib[\"name\"]\n    parent_elem = element.find(\"parent\")\n    child_elem = element.find(\"child\")\n    origin_elem = element.find(\"origin\")\n\n    if parent_elem is None or child_elem is None or origin_elem is None:\n        raise ValueError(\"Missing required elements in joint XML\")\n\n    parent = parent_elem.attrib[\"link\"]\n    child = child_elem.attrib[\"link\"]\n    origin = Origin.from_xml(origin_elem)\n    return cls(name, parent, child, origin)\n</code></pre>"},{"location":"api/joint/#onshape_robotics_toolkit.models.joint.FixedJoint.to_xml","title":"<code>to_xml(root=None)</code>","text":"<p>Convert the fixed joint to an XML element.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>Optional[_Element]</code> <p>The root element to append the fixed joint to.</p> <code>None</code> <p>Returns:</p> Type Description <code>_Element</code> <p>The XML element representing the fixed joint.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n&gt;&gt;&gt; joint = FixedJoint(\n...     name=\"joint1\",\n...     parent=\"base_link\",\n...     child=\"link1\",\n...     origin=origin,\n... )\n&gt;&gt;&gt; joint.to_xml()\n&lt;Element 'joint' at 0x7f8b3c0b4c70&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/joint.py</code> <pre><code>def to_xml(self, root: Optional[_Element] = None) -&gt; _Element:\n    \"\"\"\n    Convert the fixed joint to an XML element.\n\n    Args:\n        root: The root element to append the fixed joint to.\n\n    Returns:\n        The XML element representing the fixed joint.\n\n    Examples:\n        &gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n        &gt;&gt;&gt; joint = FixedJoint(\n        ...     name=\"joint1\",\n        ...     parent=\"base_link\",\n        ...     child=\"link1\",\n        ...     origin=origin,\n        ... )\n        &gt;&gt;&gt; joint.to_xml()\n        &lt;Element 'joint' at 0x7f8b3c0b4c70&gt;\n    \"\"\"\n\n    joint = super().to_xml(root)\n    return joint\n</code></pre>"},{"location":"api/joint/#onshape_robotics_toolkit.models.joint.FloatingJoint","title":"<code>FloatingJoint</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseJoint</code></p> <p>Represents a floating joint.</p> <p>Attributes:</p> Name Type Description <code>mimic</code> <code>JointMimic</code> <p>The mimic information for the joint.</p> <p>Methods:</p> Name Description <code>to_xml</code> <p>Converts the floating joint to an XML element.</p> Properties <p>joint_type: The type of the joint.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n&gt;&gt;&gt; mimic = JointMimic(joint=\"joint1\", multiplier=1.0, offset=0.0)\n&gt;&gt;&gt; joint = FloatingJoint(\n...     name=\"joint1\",\n...     parent=\"base_link\",\n...     child=\"link1\",\n...     origin=origin,\n...     mimic=mimic,\n... )\n&gt;&gt;&gt; joint.to_xml()\n&lt;Element 'joint' at 0x7f8b3c0b4c70&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/joint.py</code> <pre><code>@dataclass\nclass FloatingJoint(BaseJoint):\n    \"\"\"\n    Represents a floating joint.\n\n    Attributes:\n        mimic (JointMimic): The mimic information for the joint.\n\n    Methods:\n        to_xml: Converts the floating joint to an XML element.\n\n    Properties:\n        joint_type: The type of the joint.\n\n    Examples:\n        &gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n        &gt;&gt;&gt; mimic = JointMimic(joint=\"joint1\", multiplier=1.0, offset=0.0)\n        &gt;&gt;&gt; joint = FloatingJoint(\n        ...     name=\"joint1\",\n        ...     parent=\"base_link\",\n        ...     child=\"link1\",\n        ...     origin=origin,\n        ...     mimic=mimic,\n        ... )\n        &gt;&gt;&gt; joint.to_xml()\n        &lt;Element 'joint' at 0x7f8b3c0b4c70&gt;\n    \"\"\"\n\n    mimic: JointMimic | None = None\n\n    def to_xml(self, root: Optional[_Element] = None) -&gt; _Element:\n        \"\"\"\n        Convert the floating joint to an XML element.\n\n        Args:\n            root: The root element to append the floating joint to.\n\n        Returns:\n            The XML element representing the floating joint.\n\n        Examples:\n            &gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n            &gt;&gt;&gt; mimic = JointMimic(joint=\"joint1\", multiplier=1.0, offset=0.0)\n            &gt;&gt;&gt; joint = FloatingJoint(\n            ...     name=\"joint1\",\n            ...     parent=\"base_link\",\n            ...     child=\"link1\",\n            ...     origin=origin,\n            ...     mimic=mimic,\n            ... )\n            &gt;&gt;&gt; joint.to_xml()\n            &lt;Element 'joint' at 0x7f8b3c0b4c70&gt;\n        \"\"\"\n\n        joint = super().to_xml(root)\n        if self.mimic is not None:\n            self.mimic.to_xml(joint)\n        return joint\n\n    @classmethod\n    def from_xml(cls, element: _Element) -&gt; \"FloatingJoint\":\n        \"\"\"\n        Create a floating joint from an XML element.\n\n        Args:\n            element: The XML element to create the floating joint from.\n\n        Returns:\n            The floating joint created from the XML element.\n\n        Examples:\n            &gt;&gt;&gt; element = ET.Element(\"joint\")\n            &gt;&gt;&gt; element.set(\"name\", \"joint1\")\n            &gt;&gt;&gt; element.set(\"type\", \"floating\")\n            &gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n            &gt;&gt;&gt; ET.SubElement(element, \"origin\", xyz=\"0 0 0\", rpy=\"0 0 0\")\n            &gt;&gt;&gt; ET.SubElement(element, \"parent\", link=\"base_link\")\n            &gt;&gt;&gt; ET.SubElement(element, \"child\", link=\"link1\")\n            &gt;&gt;&gt; mimic = ET.SubElement(element, \"mimic\", joint=\"joint1\", multiplier=\"1.0\", offset=\"0.0\")\n            &gt;&gt;&gt; FloatingJoint.from_xml(element)\n\n            FloatingJoint(\n                name=\"joint1\",\n                parent=\"base_link\",\n                child=\"link1\",\n                origin=Origin(xyz=(0, 0, 0), rpy=(0, 0, 0)),\n                mimic=JointMimic(joint=\"joint1\", multiplier=1.0, offset=0.0)\n            )\n        \"\"\"\n\n        name = element.attrib[\"name\"]\n        parent_elem = element.find(\"parent\")\n        child_elem = element.find(\"child\")\n        origin_elem = element.find(\"origin\")\n\n        if parent_elem is None or child_elem is None or origin_elem is None:\n            raise ValueError(\"Missing required elements in joint XML\")\n\n        parent = parent_elem.attrib[\"link\"]\n        child = child_elem.attrib[\"link\"]\n        origin = Origin.from_xml(origin_elem)\n\n        mimic_element = element.find(\"mimic\")\n        mimic = JointMimic.from_xml(mimic_element) if mimic_element is not None else None\n\n        return cls(name, parent, child, origin, mimic)\n\n    @property\n    def joint_type(self) -&gt; str:\n        \"\"\"\n        The type of the joint.\n\n        Returns:\n            The type of the joint: \"floating\".\n        \"\"\"\n\n        return JointType.FLOATING\n</code></pre>"},{"location":"api/joint/#onshape_robotics_toolkit.models.joint.FloatingJoint.joint_type","title":"<code>joint_type</code>  <code>property</code>","text":"<p>The type of the joint.</p> <p>Returns:</p> Type Description <code>str</code> <p>The type of the joint: \"floating\".</p>"},{"location":"api/joint/#onshape_robotics_toolkit.models.joint.FloatingJoint.from_xml","title":"<code>from_xml(element)</code>  <code>classmethod</code>","text":"<p>Create a floating joint from an XML element.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>_Element</code> <p>The XML element to create the floating joint from.</p> required <p>Returns:</p> Type Description <code>FloatingJoint</code> <p>The floating joint created from the XML element.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; element = ET.Element(\"joint\")\n&gt;&gt;&gt; element.set(\"name\", \"joint1\")\n&gt;&gt;&gt; element.set(\"type\", \"floating\")\n&gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n&gt;&gt;&gt; ET.SubElement(element, \"origin\", xyz=\"0 0 0\", rpy=\"0 0 0\")\n&gt;&gt;&gt; ET.SubElement(element, \"parent\", link=\"base_link\")\n&gt;&gt;&gt; ET.SubElement(element, \"child\", link=\"link1\")\n&gt;&gt;&gt; mimic = ET.SubElement(element, \"mimic\", joint=\"joint1\", multiplier=\"1.0\", offset=\"0.0\")\n&gt;&gt;&gt; FloatingJoint.from_xml(element)\n</code></pre> <p>FloatingJoint(     name=\"joint1\",     parent=\"base_link\",     child=\"link1\",     origin=Origin(xyz=(0, 0, 0), rpy=(0, 0, 0)),     mimic=JointMimic(joint=\"joint1\", multiplier=1.0, offset=0.0) )</p> Source code in <code>onshape_robotics_toolkit/models/joint.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: _Element) -&gt; \"FloatingJoint\":\n    \"\"\"\n    Create a floating joint from an XML element.\n\n    Args:\n        element: The XML element to create the floating joint from.\n\n    Returns:\n        The floating joint created from the XML element.\n\n    Examples:\n        &gt;&gt;&gt; element = ET.Element(\"joint\")\n        &gt;&gt;&gt; element.set(\"name\", \"joint1\")\n        &gt;&gt;&gt; element.set(\"type\", \"floating\")\n        &gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n        &gt;&gt;&gt; ET.SubElement(element, \"origin\", xyz=\"0 0 0\", rpy=\"0 0 0\")\n        &gt;&gt;&gt; ET.SubElement(element, \"parent\", link=\"base_link\")\n        &gt;&gt;&gt; ET.SubElement(element, \"child\", link=\"link1\")\n        &gt;&gt;&gt; mimic = ET.SubElement(element, \"mimic\", joint=\"joint1\", multiplier=\"1.0\", offset=\"0.0\")\n        &gt;&gt;&gt; FloatingJoint.from_xml(element)\n\n        FloatingJoint(\n            name=\"joint1\",\n            parent=\"base_link\",\n            child=\"link1\",\n            origin=Origin(xyz=(0, 0, 0), rpy=(0, 0, 0)),\n            mimic=JointMimic(joint=\"joint1\", multiplier=1.0, offset=0.0)\n        )\n    \"\"\"\n\n    name = element.attrib[\"name\"]\n    parent_elem = element.find(\"parent\")\n    child_elem = element.find(\"child\")\n    origin_elem = element.find(\"origin\")\n\n    if parent_elem is None or child_elem is None or origin_elem is None:\n        raise ValueError(\"Missing required elements in joint XML\")\n\n    parent = parent_elem.attrib[\"link\"]\n    child = child_elem.attrib[\"link\"]\n    origin = Origin.from_xml(origin_elem)\n\n    mimic_element = element.find(\"mimic\")\n    mimic = JointMimic.from_xml(mimic_element) if mimic_element is not None else None\n\n    return cls(name, parent, child, origin, mimic)\n</code></pre>"},{"location":"api/joint/#onshape_robotics_toolkit.models.joint.FloatingJoint.to_xml","title":"<code>to_xml(root=None)</code>","text":"<p>Convert the floating joint to an XML element.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>Optional[_Element]</code> <p>The root element to append the floating joint to.</p> <code>None</code> <p>Returns:</p> Type Description <code>_Element</code> <p>The XML element representing the floating joint.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n&gt;&gt;&gt; mimic = JointMimic(joint=\"joint1\", multiplier=1.0, offset=0.0)\n&gt;&gt;&gt; joint = FloatingJoint(\n...     name=\"joint1\",\n...     parent=\"base_link\",\n...     child=\"link1\",\n...     origin=origin,\n...     mimic=mimic,\n... )\n&gt;&gt;&gt; joint.to_xml()\n&lt;Element 'joint' at 0x7f8b3c0b4c70&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/joint.py</code> <pre><code>def to_xml(self, root: Optional[_Element] = None) -&gt; _Element:\n    \"\"\"\n    Convert the floating joint to an XML element.\n\n    Args:\n        root: The root element to append the floating joint to.\n\n    Returns:\n        The XML element representing the floating joint.\n\n    Examples:\n        &gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n        &gt;&gt;&gt; mimic = JointMimic(joint=\"joint1\", multiplier=1.0, offset=0.0)\n        &gt;&gt;&gt; joint = FloatingJoint(\n        ...     name=\"joint1\",\n        ...     parent=\"base_link\",\n        ...     child=\"link1\",\n        ...     origin=origin,\n        ...     mimic=mimic,\n        ... )\n        &gt;&gt;&gt; joint.to_xml()\n        &lt;Element 'joint' at 0x7f8b3c0b4c70&gt;\n    \"\"\"\n\n    joint = super().to_xml(root)\n    if self.mimic is not None:\n        self.mimic.to_xml(joint)\n    return joint\n</code></pre>"},{"location":"api/joint/#onshape_robotics_toolkit.models.joint.JointDynamics","title":"<code>JointDynamics</code>  <code>dataclass</code>","text":"<p>Represents the dynamics information for a joint.</p> <p>Attributes:</p> Name Type Description <code>damping</code> <code>float</code> <p>The damping coefficient of the joint.</p> <code>friction</code> <code>float</code> <p>The friction coefficient of the joint.</p> <p>Methods:</p> Name Description <code>to_xml</code> <p>Converts the dynamics information to an XML element.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dynamics = JointDynamics(damping=0.0, friction=0.0)\n&gt;&gt;&gt; dynamics.to_xml()\n&lt;Element 'dynamics' at 0x7f8b3c0b4c70&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/joint.py</code> <pre><code>@dataclass\nclass JointDynamics:\n    \"\"\"\n    Represents the dynamics information for a joint.\n\n    Attributes:\n        damping (float): The damping coefficient of the joint.\n        friction (float): The friction coefficient of the joint.\n\n    Methods:\n        to_xml: Converts the dynamics information to an XML element.\n\n    Examples:\n        &gt;&gt;&gt; dynamics = JointDynamics(damping=0.0, friction=0.0)\n        &gt;&gt;&gt; dynamics.to_xml()\n        &lt;Element 'dynamics' at 0x7f8b3c0b4c70&gt;\n    \"\"\"\n\n    damping: float\n    friction: float\n\n    def to_xml(self, root: Optional[_Element] = None) -&gt; _Element:\n        \"\"\"\n        Convert the dynamics information to an XML element.\n\n        Args:\n            root: The root element to append the dynamics information to.\n\n        Returns:\n            The XML element representing the dynamics information.\n\n        Examples:\n            &gt;&gt;&gt; dynamics = JointDynamics(damping=0.0, friction=0.0)\n            &gt;&gt;&gt; dynamics.to_xml()\n            &lt;Element 'dynamics' at 0x7f8b3c0b4c70&gt;\n        \"\"\"\n\n        joint = ETreeElement(\"dynamics\") if root is None else SubElement(root, \"dynamics\")\n        joint.set(\"damping\", format_number(self.damping))\n        joint.set(\"friction\", format_number(self.friction))\n        return joint\n\n    @classmethod\n    def from_xml(cls, element: _Element) -&gt; \"JointDynamics\":\n        \"\"\"\n        Create joint dynamics from an XML element.\n\n        Args:\n            element: The XML element to create the joint dynamics from.\n\n        Returns:\n            The joint dynamics created from the XML element.\n\n        Examples:\n            &gt;&gt;&gt; element = ET.Element(\"dynamics\")\n            &gt;&gt;&gt; element.set(\"damping\", \"0.0\")\n            &gt;&gt;&gt; element.set(\"friction\", \"0.0\")\n            &gt;&gt;&gt; JointDynamics.from_xml(element)\n            JointDynamics(damping=0.0, friction=0.0)\n        \"\"\"\n\n        damping = float(element.attrib.get(\"damping\", 0))\n        friction = float(element.attrib.get(\"friction\", 0))\n        return cls(damping, friction)\n</code></pre>"},{"location":"api/joint/#onshape_robotics_toolkit.models.joint.JointDynamics.from_xml","title":"<code>from_xml(element)</code>  <code>classmethod</code>","text":"<p>Create joint dynamics from an XML element.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>_Element</code> <p>The XML element to create the joint dynamics from.</p> required <p>Returns:</p> Type Description <code>JointDynamics</code> <p>The joint dynamics created from the XML element.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; element = ET.Element(\"dynamics\")\n&gt;&gt;&gt; element.set(\"damping\", \"0.0\")\n&gt;&gt;&gt; element.set(\"friction\", \"0.0\")\n&gt;&gt;&gt; JointDynamics.from_xml(element)\nJointDynamics(damping=0.0, friction=0.0)\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/joint.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: _Element) -&gt; \"JointDynamics\":\n    \"\"\"\n    Create joint dynamics from an XML element.\n\n    Args:\n        element: The XML element to create the joint dynamics from.\n\n    Returns:\n        The joint dynamics created from the XML element.\n\n    Examples:\n        &gt;&gt;&gt; element = ET.Element(\"dynamics\")\n        &gt;&gt;&gt; element.set(\"damping\", \"0.0\")\n        &gt;&gt;&gt; element.set(\"friction\", \"0.0\")\n        &gt;&gt;&gt; JointDynamics.from_xml(element)\n        JointDynamics(damping=0.0, friction=0.0)\n    \"\"\"\n\n    damping = float(element.attrib.get(\"damping\", 0))\n    friction = float(element.attrib.get(\"friction\", 0))\n    return cls(damping, friction)\n</code></pre>"},{"location":"api/joint/#onshape_robotics_toolkit.models.joint.JointDynamics.to_xml","title":"<code>to_xml(root=None)</code>","text":"<p>Convert the dynamics information to an XML element.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>Optional[_Element]</code> <p>The root element to append the dynamics information to.</p> <code>None</code> <p>Returns:</p> Type Description <code>_Element</code> <p>The XML element representing the dynamics information.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dynamics = JointDynamics(damping=0.0, friction=0.0)\n&gt;&gt;&gt; dynamics.to_xml()\n&lt;Element 'dynamics' at 0x7f8b3c0b4c70&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/joint.py</code> <pre><code>def to_xml(self, root: Optional[_Element] = None) -&gt; _Element:\n    \"\"\"\n    Convert the dynamics information to an XML element.\n\n    Args:\n        root: The root element to append the dynamics information to.\n\n    Returns:\n        The XML element representing the dynamics information.\n\n    Examples:\n        &gt;&gt;&gt; dynamics = JointDynamics(damping=0.0, friction=0.0)\n        &gt;&gt;&gt; dynamics.to_xml()\n        &lt;Element 'dynamics' at 0x7f8b3c0b4c70&gt;\n    \"\"\"\n\n    joint = ETreeElement(\"dynamics\") if root is None else SubElement(root, \"dynamics\")\n    joint.set(\"damping\", format_number(self.damping))\n    joint.set(\"friction\", format_number(self.friction))\n    return joint\n</code></pre>"},{"location":"api/joint/#onshape_robotics_toolkit.models.joint.JointLimits","title":"<code>JointLimits</code>  <code>dataclass</code>","text":"<p>Represents the limits of a joint.</p> <p>Attributes:</p> Name Type Description <code>effort</code> <code>float</code> <p>The effort limit of the joint.</p> <code>velocity</code> <code>float</code> <p>The velocity limit of the joint.</p> <code>lower</code> <code>float</code> <p>The lower limit of the joint.</p> <code>upper</code> <code>float</code> <p>The upper limit of the joint.</p> <p>Methods:</p> Name Description <code>to_xml</code> <p>Converts the joint limits to an XML element.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; limits = JointLimits(effort=10.0, velocity=1.0, lower=-1.0, upper=1.0)\n&gt;&gt;&gt; limits.to_xml()\n&lt;Element 'limit' at 0x7f8b3c0b4c70&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/joint.py</code> <pre><code>@dataclass\nclass JointLimits:\n    \"\"\"\n    Represents the limits of a joint.\n\n    Attributes:\n        effort (float): The effort limit of the joint.\n        velocity (float): The velocity limit of the joint.\n        lower (float): The lower limit of the joint.\n        upper (float): The upper limit of the joint.\n\n    Methods:\n        to_xml: Converts the joint limits to an XML element.\n\n    Examples:\n        &gt;&gt;&gt; limits = JointLimits(effort=10.0, velocity=1.0, lower=-1.0, upper=1.0)\n        &gt;&gt;&gt; limits.to_xml()\n        &lt;Element 'limit' at 0x7f8b3c0b4c70&gt;\n    \"\"\"\n\n    effort: float\n    velocity: float\n    lower: float\n    upper: float\n\n    def to_xml(self, root: Optional[_Element] = None) -&gt; _Element:\n        \"\"\"\n        Convert the joint limits to an XML element.\n\n        Args:\n            root: The root element to append the joint limits to.\n\n        Returns:\n            The XML element representing the joint limits.\n\n        Examples:\n            &gt;&gt;&gt; limits = JointLimits(effort=10.0, velocity=1.0, lower=-1.0, upper=1.0)\n            &gt;&gt;&gt; limits.to_xml()\n            &lt;Element 'limit' at 0x7f8b3c0b4c70&gt;\n        \"\"\"\n\n        limit = ETreeElement(\"limit\") if root is None else SubElement(root, \"limit\")\n        limit.set(\"effort\", format_number(self.effort))\n        limit.set(\"velocity\", format_number(self.velocity))\n        limit.set(\"lower\", format_number(self.lower))\n        limit.set(\"upper\", format_number(self.upper))\n        return limit\n</code></pre>"},{"location":"api/joint/#onshape_robotics_toolkit.models.joint.JointLimits.to_xml","title":"<code>to_xml(root=None)</code>","text":"<p>Convert the joint limits to an XML element.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>Optional[_Element]</code> <p>The root element to append the joint limits to.</p> <code>None</code> <p>Returns:</p> Type Description <code>_Element</code> <p>The XML element representing the joint limits.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; limits = JointLimits(effort=10.0, velocity=1.0, lower=-1.0, upper=1.0)\n&gt;&gt;&gt; limits.to_xml()\n&lt;Element 'limit' at 0x7f8b3c0b4c70&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/joint.py</code> <pre><code>def to_xml(self, root: Optional[_Element] = None) -&gt; _Element:\n    \"\"\"\n    Convert the joint limits to an XML element.\n\n    Args:\n        root: The root element to append the joint limits to.\n\n    Returns:\n        The XML element representing the joint limits.\n\n    Examples:\n        &gt;&gt;&gt; limits = JointLimits(effort=10.0, velocity=1.0, lower=-1.0, upper=1.0)\n        &gt;&gt;&gt; limits.to_xml()\n        &lt;Element 'limit' at 0x7f8b3c0b4c70&gt;\n    \"\"\"\n\n    limit = ETreeElement(\"limit\") if root is None else SubElement(root, \"limit\")\n    limit.set(\"effort\", format_number(self.effort))\n    limit.set(\"velocity\", format_number(self.velocity))\n    limit.set(\"lower\", format_number(self.lower))\n    limit.set(\"upper\", format_number(self.upper))\n    return limit\n</code></pre>"},{"location":"api/joint/#onshape_robotics_toolkit.models.joint.JointMimic","title":"<code>JointMimic</code>  <code>dataclass</code>","text":"<p>Represents the mimic information for a joint.</p> <p>Attributes:</p> Name Type Description <code>joint</code> <code>str</code> <p>The joint to mimic.</p> <code>multiplier</code> <code>float</code> <p>The multiplier for the mimic.</p> <code>offset</code> <code>float</code> <p>The offset for the mimic.</p> <p>Methods:</p> Name Description <code>to_xml</code> <p>Converts the mimic information to an XML element.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; mimic = JointMimic(joint=\"joint1\", multiplier=1.0, offset=0.0)\n&gt;&gt;&gt; mimic.to_xml()\n&lt;Element 'mimic' at 0x7f8b3c0b4c70&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/joint.py</code> <pre><code>@dataclass\nclass JointMimic:\n    \"\"\"\n    Represents the mimic information for a joint.\n\n    Attributes:\n        joint (str): The joint to mimic.\n        multiplier (float): The multiplier for the mimic.\n        offset (float): The offset for the mimic.\n\n    Methods:\n        to_xml: Converts the mimic information to an XML element.\n\n    Examples:\n        &gt;&gt;&gt; mimic = JointMimic(joint=\"joint1\", multiplier=1.0, offset=0.0)\n        &gt;&gt;&gt; mimic.to_xml()\n        &lt;Element 'mimic' at 0x7f8b3c0b4c70&gt;\n    \"\"\"\n\n    joint: str\n    multiplier: float = 1.0\n    offset: float = 0.0\n\n    def to_xml(self, root: Optional[_Element] = None) -&gt; _Element:\n        \"\"\"\n        Convert the mimic information to an XML element.\n\n        Args:\n            root: The root element to append the mimic information to.\n\n        Returns:\n            The XML element representing the mimic information.\n\n        Examples:\n            &gt;&gt;&gt; mimic = JointMimic(joint=\"joint1\", multiplier=1.0, offset=0.0)\n            &gt;&gt;&gt; mimic.to_xml()\n            &lt;Element 'mimic' at 0x7f8b3c0b4c70&gt;\n        \"\"\"\n\n        mimic = ETreeElement(\"mimic\") if root is None else SubElement(root, \"mimic\")\n        mimic.set(\"joint\", self.joint)\n        mimic.set(\"multiplier\", format_number(self.multiplier))\n        mimic.set(\"offset\", format_number(self.offset))\n        return mimic\n\n    @classmethod\n    def from_xml(cls, element: _Element) -&gt; \"JointMimic\":\n        \"\"\"\n        Create a joint mimic from an XML element.\n\n        Args:\n            element: The XML element to create the joint mimic from.\n\n        Returns:\n            The joint mimic created from the XML element.\n\n        Examples:\n            &gt;&gt;&gt; element = ET.Element(\"mimic\")\n            &gt;&gt;&gt; element.set(\"joint\", \"joint1\")\n            &gt;&gt;&gt; element.set(\"multiplier\", \"1.0\")\n            &gt;&gt;&gt; element.set(\"offset\", \"0.0\")\n            &gt;&gt;&gt; JointMimic.from_xml(element)\n            JointMimic(joint=\"joint1\", multiplier=1.0, offset=0.0)\n        \"\"\"\n\n        joint = element.attrib[\"joint\"]\n        multiplier = float(element.attrib.get(\"multiplier\", 1.0))\n        offset = float(element.attrib.get(\"offset\", 0.0))\n        return cls(joint, multiplier, offset)\n</code></pre>"},{"location":"api/joint/#onshape_robotics_toolkit.models.joint.JointMimic.from_xml","title":"<code>from_xml(element)</code>  <code>classmethod</code>","text":"<p>Create a joint mimic from an XML element.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>_Element</code> <p>The XML element to create the joint mimic from.</p> required <p>Returns:</p> Type Description <code>JointMimic</code> <p>The joint mimic created from the XML element.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; element = ET.Element(\"mimic\")\n&gt;&gt;&gt; element.set(\"joint\", \"joint1\")\n&gt;&gt;&gt; element.set(\"multiplier\", \"1.0\")\n&gt;&gt;&gt; element.set(\"offset\", \"0.0\")\n&gt;&gt;&gt; JointMimic.from_xml(element)\nJointMimic(joint=\"joint1\", multiplier=1.0, offset=0.0)\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/joint.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: _Element) -&gt; \"JointMimic\":\n    \"\"\"\n    Create a joint mimic from an XML element.\n\n    Args:\n        element: The XML element to create the joint mimic from.\n\n    Returns:\n        The joint mimic created from the XML element.\n\n    Examples:\n        &gt;&gt;&gt; element = ET.Element(\"mimic\")\n        &gt;&gt;&gt; element.set(\"joint\", \"joint1\")\n        &gt;&gt;&gt; element.set(\"multiplier\", \"1.0\")\n        &gt;&gt;&gt; element.set(\"offset\", \"0.0\")\n        &gt;&gt;&gt; JointMimic.from_xml(element)\n        JointMimic(joint=\"joint1\", multiplier=1.0, offset=0.0)\n    \"\"\"\n\n    joint = element.attrib[\"joint\"]\n    multiplier = float(element.attrib.get(\"multiplier\", 1.0))\n    offset = float(element.attrib.get(\"offset\", 0.0))\n    return cls(joint, multiplier, offset)\n</code></pre>"},{"location":"api/joint/#onshape_robotics_toolkit.models.joint.JointMimic.to_xml","title":"<code>to_xml(root=None)</code>","text":"<p>Convert the mimic information to an XML element.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>Optional[_Element]</code> <p>The root element to append the mimic information to.</p> <code>None</code> <p>Returns:</p> Type Description <code>_Element</code> <p>The XML element representing the mimic information.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; mimic = JointMimic(joint=\"joint1\", multiplier=1.0, offset=0.0)\n&gt;&gt;&gt; mimic.to_xml()\n&lt;Element 'mimic' at 0x7f8b3c0b4c70&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/joint.py</code> <pre><code>def to_xml(self, root: Optional[_Element] = None) -&gt; _Element:\n    \"\"\"\n    Convert the mimic information to an XML element.\n\n    Args:\n        root: The root element to append the mimic information to.\n\n    Returns:\n        The XML element representing the mimic information.\n\n    Examples:\n        &gt;&gt;&gt; mimic = JointMimic(joint=\"joint1\", multiplier=1.0, offset=0.0)\n        &gt;&gt;&gt; mimic.to_xml()\n        &lt;Element 'mimic' at 0x7f8b3c0b4c70&gt;\n    \"\"\"\n\n    mimic = ETreeElement(\"mimic\") if root is None else SubElement(root, \"mimic\")\n    mimic.set(\"joint\", self.joint)\n    mimic.set(\"multiplier\", format_number(self.multiplier))\n    mimic.set(\"offset\", format_number(self.offset))\n    return mimic\n</code></pre>"},{"location":"api/joint/#onshape_robotics_toolkit.models.joint.JointType","title":"<code>JointType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enumerates the possible joint types in Onshape</p> <p>Attributes:</p> Name Type Description <code>REVOLUTE</code> <code>str</code> <p>Revolute joint</p> <code>CONTINUOUS</code> <code>str</code> <p>Continuous joint</p> <code>PRISMATIC</code> <code>str</code> <p>Prismatic joint</p> <code>FIXED</code> <code>str</code> <p>Fixed joint</p> <code>FLOATING</code> <code>str</code> <p>Floating joint</p> <code>PLANAR</code> <code>str</code> <p>Planar joint</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; JointType.REVOLUTE\n'revolute'\n&gt;&gt;&gt; JointType.CONTINUOUS\n'continuous'\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/joint.py</code> <pre><code>class JointType(str, Enum):\n    \"\"\"\n    Enumerates the possible joint types in Onshape\n\n    Attributes:\n        REVOLUTE (str): Revolute joint\n        CONTINUOUS (str): Continuous joint\n        PRISMATIC (str): Prismatic joint\n        FIXED (str): Fixed joint\n        FLOATING (str): Floating joint\n        PLANAR (str): Planar joint\n\n    Examples:\n        &gt;&gt;&gt; JointType.REVOLUTE\n        'revolute'\n        &gt;&gt;&gt; JointType.CONTINUOUS\n        'continuous'\n    \"\"\"\n\n    REVOLUTE = \"revolute\"\n    CONTINUOUS = \"continuous\"\n    PRISMATIC = \"prismatic\"\n    FIXED = \"fixed\"\n    FLOATING = \"floating\"\n    PLANAR = \"planar\"\n</code></pre>"},{"location":"api/joint/#onshape_robotics_toolkit.models.joint.PlanarJoint","title":"<code>PlanarJoint</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseJoint</code></p> <p>Represents a planar joint.</p> <p>Attributes:</p> Name Type Description <code>limits</code> <code>JointLimits</code> <p>The limits of the joint.</p> <code>axis</code> <code>Axis</code> <p>The axis of the joint.</p> <code>mimic</code> <code>JointMimic</code> <p>The mimic information for the joint.</p> <p>Methods:</p> Name Description <code>to_xml</code> <p>Converts the planar joint to an XML element.</p> Properties <p>joint_type: The type of the joint.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n&gt;&gt;&gt; limits = JointLimits(effort=10.0, velocity=1.0, lower=-1.0, upper=1.0)\n&gt;&gt;&gt; axis = Axis(xyz=(0, 0, 1))\n&gt;&gt;&gt; mimic = JointMimic(joint=\"joint1\", multiplier=1.0, offset=0.0)\n&gt;&gt;&gt; joint = PlanarJoint(\n...     name=\"joint1\",\n...     parent=\"base_link\",\n...     child=\"link1\",\n...     origin=origin,\n...     limits=limits,\n...     axis=axis,\n...     mimic=mimic,\n... )\n&gt;&gt;&gt; joint.to_xml()\n&lt;Element 'joint' at 0x7f8b3c0b4c70&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/joint.py</code> <pre><code>@dataclass\nclass PlanarJoint(BaseJoint):\n    \"\"\"\n    Represents a planar joint.\n\n    Attributes:\n        limits (JointLimits): The limits of the joint.\n        axis (Axis): The axis of the joint.\n        mimic (JointMimic): The mimic information for the joint.\n\n    Methods:\n        to_xml: Converts the planar joint to an XML element.\n\n    Properties:\n        joint_type: The type of the joint.\n\n    Examples:\n        &gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n        &gt;&gt;&gt; limits = JointLimits(effort=10.0, velocity=1.0, lower=-1.0, upper=1.0)\n        &gt;&gt;&gt; axis = Axis(xyz=(0, 0, 1))\n        &gt;&gt;&gt; mimic = JointMimic(joint=\"joint1\", multiplier=1.0, offset=0.0)\n        &gt;&gt;&gt; joint = PlanarJoint(\n        ...     name=\"joint1\",\n        ...     parent=\"base_link\",\n        ...     child=\"link1\",\n        ...     origin=origin,\n        ...     limits=limits,\n        ...     axis=axis,\n        ...     mimic=mimic,\n        ... )\n        &gt;&gt;&gt; joint.to_xml()\n        &lt;Element 'joint' at 0x7f8b3c0b4c70&gt;\n    \"\"\"\n\n    limits: JointLimits\n    axis: Axis\n    mimic: JointMimic | None = None\n\n    def to_xml(self, root: Optional[_Element] = None) -&gt; _Element:\n        \"\"\"\n        Convert the planar joint to an XML element.\n\n        Args:\n            root: The root element to append the planar joint to.\n\n        Returns:\n            The XML element representing the planar joint.\n\n        Examples:\n            &gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n            &gt;&gt;&gt; limits = JointLimits(effort=10.0, velocity=1.0, lower=-1.0, upper=1.0)\n            &gt;&gt;&gt; axis = Axis(xyz=(0, 0, 1))\n            &gt;&gt;&gt; mimic = JointMimic(joint=\"joint1\", multiplier=1.0, offset=0.0)\n            &gt;&gt;&gt; joint = PlanarJoint(\n            ...     name=\"joint1\",\n            ...     parent=\"base_link\",\n            ...     child=\"link1\",\n            ...     origin=origin,\n            ...     limits=limits,\n            ...     axis=axis,\n            ...     mimic=mimic,\n            ... )\n            &gt;&gt;&gt; joint.to_xml()\n            &lt;Element 'joint' at 0x7f8b3c0b4c70&gt;\n        \"\"\"\n\n        joint = super().to_xml(root)\n        self.axis.to_xml(joint)\n        if self.limits is not None:\n            self.limits.to_xml(joint)\n        if self.mimic is not None:\n            self.mimic.to_xml(joint)\n        return joint\n\n    @classmethod\n    def from_xml(cls, element: _Element) -&gt; \"PlanarJoint\":\n        \"\"\"\n        Create a planar joint from an XML element.\n\n        Args:\n            element: The XML element to create the planar joint from.\n\n        Returns:\n            The planar joint created from the XML element.\n\n        Examples:\n            &gt;&gt;&gt; element = ET.Element(\"joint\")\n            &gt;&gt;&gt; element.set(\"name\", \"joint1\")\n            &gt;&gt;&gt; element.set(\"type\", \"planar\")\n            &gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n            &gt;&gt;&gt; ET.SubElement(element, \"origin\", xyz=\"0 0 0\", rpy=\"0 0 0\")\n            &gt;&gt;&gt; ET.SubElement(element, \"parent\", link=\"base_link\")\n            &gt;&gt;&gt; ET.SubElement(element, \"child\", link=\"link1\")\n            &gt;&gt;&gt; limits = ET.SubElement(element, \"limit\", effort=\"10.0\", velocity=\"1.0\", lower=\"-1.0\", upper=\"1.0\")\n            &gt;&gt;&gt; axis = ET.SubElement(element, \"axis\", xyz=\"0 0 1\")\n            &gt;&gt;&gt; mimic = ET.SubElement(element, \"mimic\", joint=\"joint1\", multiplier=\"1.0\", offset=\"0.0\")\n            &gt;&gt;&gt; PlanarJoint.from_xml(element)\n\n            PlanarJoint(\n                name=\"joint1\",\n                parent=\"base_link\",\n                child=\"link1\",\n                origin=Origin(xyz=(0, 0, 0), rpy=(0, 0, 0)),\n                limits=JointLimits(effort=10.0, velocity=1.0, lower=-1.0, upper=1.0),\n                axis=Axis(xyz=(0, 0, 1)),\n                mimic=JointMimic(joint=\"joint1\", multiplier=1.0, offset=0.0)\n            )\n        \"\"\"\n\n        name = element.attrib[\"name\"]\n        parent_elem = element.find(\"parent\")\n        child_elem = element.find(\"child\")\n        origin_elem = element.find(\"origin\")\n\n        if parent_elem is None or child_elem is None or origin_elem is None:\n            raise ValueError(\"Missing required elements in joint XML\")\n\n        parent = parent_elem.attrib[\"link\"]\n        child = child_elem.attrib[\"link\"]\n        origin = Origin.from_xml(origin_elem)\n\n        limit_element = element.find(\"limit\")\n        if limit_element is not None:\n            limits = JointLimits(\n                effort=float(limit_element.attrib.get(\"effort\", 0)),\n                velocity=float(limit_element.attrib.get(\"velocity\", 0)),\n                lower=float(limit_element.attrib.get(\"lower\", 0)),\n                upper=float(limit_element.attrib.get(\"upper\", 0)),\n            )\n        else:\n            raise ValueError(\"PlanarJoint requires limit element\")\n\n        axis = Axis.from_xml(element.find(\"axis\"))\n\n        mimic_element = element.find(\"mimic\")\n        mimic = JointMimic.from_xml(mimic_element) if mimic_element is not None else None\n\n        return cls(name, parent, child, origin, limits, axis, mimic)\n\n    @property\n    def joint_type(self) -&gt; str:\n        \"\"\"\n        The type of the joint.\n\n        Returns:\n            The type of the joint: \"planar\".\n        \"\"\"\n\n        return JointType.PLANAR\n</code></pre>"},{"location":"api/joint/#onshape_robotics_toolkit.models.joint.PlanarJoint.joint_type","title":"<code>joint_type</code>  <code>property</code>","text":"<p>The type of the joint.</p> <p>Returns:</p> Type Description <code>str</code> <p>The type of the joint: \"planar\".</p>"},{"location":"api/joint/#onshape_robotics_toolkit.models.joint.PlanarJoint.from_xml","title":"<code>from_xml(element)</code>  <code>classmethod</code>","text":"<p>Create a planar joint from an XML element.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>_Element</code> <p>The XML element to create the planar joint from.</p> required <p>Returns:</p> Type Description <code>PlanarJoint</code> <p>The planar joint created from the XML element.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; element = ET.Element(\"joint\")\n&gt;&gt;&gt; element.set(\"name\", \"joint1\")\n&gt;&gt;&gt; element.set(\"type\", \"planar\")\n&gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n&gt;&gt;&gt; ET.SubElement(element, \"origin\", xyz=\"0 0 0\", rpy=\"0 0 0\")\n&gt;&gt;&gt; ET.SubElement(element, \"parent\", link=\"base_link\")\n&gt;&gt;&gt; ET.SubElement(element, \"child\", link=\"link1\")\n&gt;&gt;&gt; limits = ET.SubElement(element, \"limit\", effort=\"10.0\", velocity=\"1.0\", lower=\"-1.0\", upper=\"1.0\")\n&gt;&gt;&gt; axis = ET.SubElement(element, \"axis\", xyz=\"0 0 1\")\n&gt;&gt;&gt; mimic = ET.SubElement(element, \"mimic\", joint=\"joint1\", multiplier=\"1.0\", offset=\"0.0\")\n&gt;&gt;&gt; PlanarJoint.from_xml(element)\n</code></pre> <p>PlanarJoint(     name=\"joint1\",     parent=\"base_link\",     child=\"link1\",     origin=Origin(xyz=(0, 0, 0), rpy=(0, 0, 0)),     limits=JointLimits(effort=10.0, velocity=1.0, lower=-1.0, upper=1.0),     axis=Axis(xyz=(0, 0, 1)),     mimic=JointMimic(joint=\"joint1\", multiplier=1.0, offset=0.0) )</p> Source code in <code>onshape_robotics_toolkit/models/joint.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: _Element) -&gt; \"PlanarJoint\":\n    \"\"\"\n    Create a planar joint from an XML element.\n\n    Args:\n        element: The XML element to create the planar joint from.\n\n    Returns:\n        The planar joint created from the XML element.\n\n    Examples:\n        &gt;&gt;&gt; element = ET.Element(\"joint\")\n        &gt;&gt;&gt; element.set(\"name\", \"joint1\")\n        &gt;&gt;&gt; element.set(\"type\", \"planar\")\n        &gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n        &gt;&gt;&gt; ET.SubElement(element, \"origin\", xyz=\"0 0 0\", rpy=\"0 0 0\")\n        &gt;&gt;&gt; ET.SubElement(element, \"parent\", link=\"base_link\")\n        &gt;&gt;&gt; ET.SubElement(element, \"child\", link=\"link1\")\n        &gt;&gt;&gt; limits = ET.SubElement(element, \"limit\", effort=\"10.0\", velocity=\"1.0\", lower=\"-1.0\", upper=\"1.0\")\n        &gt;&gt;&gt; axis = ET.SubElement(element, \"axis\", xyz=\"0 0 1\")\n        &gt;&gt;&gt; mimic = ET.SubElement(element, \"mimic\", joint=\"joint1\", multiplier=\"1.0\", offset=\"0.0\")\n        &gt;&gt;&gt; PlanarJoint.from_xml(element)\n\n        PlanarJoint(\n            name=\"joint1\",\n            parent=\"base_link\",\n            child=\"link1\",\n            origin=Origin(xyz=(0, 0, 0), rpy=(0, 0, 0)),\n            limits=JointLimits(effort=10.0, velocity=1.0, lower=-1.0, upper=1.0),\n            axis=Axis(xyz=(0, 0, 1)),\n            mimic=JointMimic(joint=\"joint1\", multiplier=1.0, offset=0.0)\n        )\n    \"\"\"\n\n    name = element.attrib[\"name\"]\n    parent_elem = element.find(\"parent\")\n    child_elem = element.find(\"child\")\n    origin_elem = element.find(\"origin\")\n\n    if parent_elem is None or child_elem is None or origin_elem is None:\n        raise ValueError(\"Missing required elements in joint XML\")\n\n    parent = parent_elem.attrib[\"link\"]\n    child = child_elem.attrib[\"link\"]\n    origin = Origin.from_xml(origin_elem)\n\n    limit_element = element.find(\"limit\")\n    if limit_element is not None:\n        limits = JointLimits(\n            effort=float(limit_element.attrib.get(\"effort\", 0)),\n            velocity=float(limit_element.attrib.get(\"velocity\", 0)),\n            lower=float(limit_element.attrib.get(\"lower\", 0)),\n            upper=float(limit_element.attrib.get(\"upper\", 0)),\n        )\n    else:\n        raise ValueError(\"PlanarJoint requires limit element\")\n\n    axis = Axis.from_xml(element.find(\"axis\"))\n\n    mimic_element = element.find(\"mimic\")\n    mimic = JointMimic.from_xml(mimic_element) if mimic_element is not None else None\n\n    return cls(name, parent, child, origin, limits, axis, mimic)\n</code></pre>"},{"location":"api/joint/#onshape_robotics_toolkit.models.joint.PlanarJoint.to_xml","title":"<code>to_xml(root=None)</code>","text":"<p>Convert the planar joint to an XML element.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>Optional[_Element]</code> <p>The root element to append the planar joint to.</p> <code>None</code> <p>Returns:</p> Type Description <code>_Element</code> <p>The XML element representing the planar joint.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n&gt;&gt;&gt; limits = JointLimits(effort=10.0, velocity=1.0, lower=-1.0, upper=1.0)\n&gt;&gt;&gt; axis = Axis(xyz=(0, 0, 1))\n&gt;&gt;&gt; mimic = JointMimic(joint=\"joint1\", multiplier=1.0, offset=0.0)\n&gt;&gt;&gt; joint = PlanarJoint(\n...     name=\"joint1\",\n...     parent=\"base_link\",\n...     child=\"link1\",\n...     origin=origin,\n...     limits=limits,\n...     axis=axis,\n...     mimic=mimic,\n... )\n&gt;&gt;&gt; joint.to_xml()\n&lt;Element 'joint' at 0x7f8b3c0b4c70&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/joint.py</code> <pre><code>def to_xml(self, root: Optional[_Element] = None) -&gt; _Element:\n    \"\"\"\n    Convert the planar joint to an XML element.\n\n    Args:\n        root: The root element to append the planar joint to.\n\n    Returns:\n        The XML element representing the planar joint.\n\n    Examples:\n        &gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n        &gt;&gt;&gt; limits = JointLimits(effort=10.0, velocity=1.0, lower=-1.0, upper=1.0)\n        &gt;&gt;&gt; axis = Axis(xyz=(0, 0, 1))\n        &gt;&gt;&gt; mimic = JointMimic(joint=\"joint1\", multiplier=1.0, offset=0.0)\n        &gt;&gt;&gt; joint = PlanarJoint(\n        ...     name=\"joint1\",\n        ...     parent=\"base_link\",\n        ...     child=\"link1\",\n        ...     origin=origin,\n        ...     limits=limits,\n        ...     axis=axis,\n        ...     mimic=mimic,\n        ... )\n        &gt;&gt;&gt; joint.to_xml()\n        &lt;Element 'joint' at 0x7f8b3c0b4c70&gt;\n    \"\"\"\n\n    joint = super().to_xml(root)\n    self.axis.to_xml(joint)\n    if self.limits is not None:\n        self.limits.to_xml(joint)\n    if self.mimic is not None:\n        self.mimic.to_xml(joint)\n    return joint\n</code></pre>"},{"location":"api/joint/#onshape_robotics_toolkit.models.joint.PrismaticJoint","title":"<code>PrismaticJoint</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseJoint</code></p> <p>Represents a prismatic joint.</p> <p>Attributes:</p> Name Type Description <code>limits</code> <code>JointLimits</code> <p>The limits of the joint.</p> <code>axis</code> <code>Axis</code> <p>The axis of the joint.</p> <code>dynamics</code> <code>JointDynamics</code> <p>The dynamics of the joint.</p> <code>mimic</code> <code>JointMimic</code> <p>The mimic information for the joint.</p> <p>Methods:</p> Name Description <code>to_xml</code> <p>Converts the prismatic joint to an XML element.</p> Properties <p>joint_type: The type of the joint.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n&gt;&gt;&gt; limits = JointLimits(effort=10.0, velocity=1.0, lower=-1.0, upper=1.0)\n&gt;&gt;&gt; axis = Axis(xyz=(0, 0, 1))\n&gt;&gt;&gt; dynamics = JointDynamics(damping=0.0, friction=0.0)\n&gt;&gt;&gt; mimic = JointMimic(joint=\"joint1\", multiplier=1.0, offset=0.0)\n&gt;&gt;&gt; joint = PrismaticJoint(\n...     name=\"joint1\",\n...     parent=\"base_link\",\n...     child=\"link1\",\n...     origin=origin,\n...     limits=limits,\n...     axis=axis,\n...     dynamics=dynamics,\n...     mimic=mimic,\n... )\n&gt;&gt;&gt; joint.to_xml()\n&lt;Element 'joint' at 0x7f8b3c0b4c70&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/joint.py</code> <pre><code>@dataclass\nclass PrismaticJoint(BaseJoint):\n    \"\"\"\n    Represents a prismatic joint.\n\n    Attributes:\n        limits (JointLimits): The limits of the joint.\n        axis (Axis): The axis of the joint.\n        dynamics (JointDynamics): The dynamics of the joint.\n        mimic (JointMimic): The mimic information for the joint.\n\n    Methods:\n        to_xml: Converts the prismatic joint to an XML element.\n\n    Properties:\n        joint_type: The type of the joint.\n\n    Examples:\n        &gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n        &gt;&gt;&gt; limits = JointLimits(effort=10.0, velocity=1.0, lower=-1.0, upper=1.0)\n        &gt;&gt;&gt; axis = Axis(xyz=(0, 0, 1))\n        &gt;&gt;&gt; dynamics = JointDynamics(damping=0.0, friction=0.0)\n        &gt;&gt;&gt; mimic = JointMimic(joint=\"joint1\", multiplier=1.0, offset=0.0)\n        &gt;&gt;&gt; joint = PrismaticJoint(\n        ...     name=\"joint1\",\n        ...     parent=\"base_link\",\n        ...     child=\"link1\",\n        ...     origin=origin,\n        ...     limits=limits,\n        ...     axis=axis,\n        ...     dynamics=dynamics,\n        ...     mimic=mimic,\n        ... )\n        &gt;&gt;&gt; joint.to_xml()\n        &lt;Element 'joint' at 0x7f8b3c0b4c70&gt;\n    \"\"\"\n\n    limits: JointLimits\n    axis: Axis\n    dynamics: JointDynamics | None = None\n    mimic: JointMimic | None = None\n\n    def to_xml(self, root: Optional[_Element] = None) -&gt; _Element:\n        \"\"\"\n        Convert the prismatic joint to an XML element.\n\n        Args:\n            root: The root element to append the prismatic joint to.\n\n        Returns:\n            The XML element representing the prismatic joint\n\n        Examples:\n            &gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n            &gt;&gt;&gt; limits = JointLimits(effort=10.0, velocity=1.0, lower=-1.0, upper=1.0)\n            &gt;&gt;&gt; axis = Axis(xyz=(0, 0, 1))\n            &gt;&gt;&gt; dynamics = JointDynamics(damping=0.0, friction=0.0)\n            &gt;&gt;&gt; mimic = JointMimic(joint=\"joint1\", multiplier=1.0, offset=0.0)\n            &gt;&gt;&gt; joint = PrismaticJoint(\n            ...     name=\"joint1\",\n            ...     parent=\"base_link\",\n            ...     child=\"link1\",\n            ...     origin=origin,\n            ...     limits=limits,\n            ...     axis=axis,\n            ...     dynamics=dynamics,\n            ...     mimic=mimic,\n            ... )\n            &gt;&gt;&gt; joint.to_xml()\n            &lt;Element 'joint' at 0x7f8b3c0b4c70&gt;\n        \"\"\"\n\n        joint = super().to_xml(root)\n        self.axis.to_xml(joint)\n        if self.limits is not None:\n            self.limits.to_xml(joint)\n        if self.dynamics is not None:\n            self.dynamics.to_xml(joint)\n        if self.mimic is not None:\n            self.mimic.to_xml(joint)\n        return joint\n\n    @classmethod\n    def from_xml(cls, element: _Element) -&gt; \"PrismaticJoint\":\n        \"\"\"\n        Create a prismatic joint from an XML element.\n\n        Args:\n            element: The XML element to create the prismatic joint from.\n\n        Returns:\n            The prismatic joint created from the XML element.\n\n        Examples:\n            &gt;&gt;&gt; element = ET.Element(\"joint\")\n            &gt;&gt;&gt; element.set(\"name\", \"joint1\")\n            &gt;&gt;&gt; element.set(\"type\", \"prismatic\")\n            &gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n            &gt;&gt;&gt; ET.SubElement(element, \"origin\", xyz=\"0 0 0\", rpy=\"0 0 0\")\n            &gt;&gt;&gt; ET.SubElement(element, \"parent\", link=\"base_link\")\n            &gt;&gt;&gt; ET.SubElement(element, \"child\", link=\"link1\")\n            &gt;&gt;&gt; limits = ET.SubElement(element, \"limit\", effort=\"10.0\", velocity=\"1.0\", lower=\"-1.0\", upper=\"1.0\")\n            &gt;&gt;&gt; axis = ET.SubElement(element, \"axis\", xyz=\"0 0 1\")\n            &gt;&gt;&gt; dynamics = ET.SubElement(element, \"dynamics\", damping=\"0.0\", friction=\"0.0\")\n            &gt;&gt;&gt; mimic = ET.SubElement(element, \"mimic\", joint=\"joint1\", multiplier=\"1.0\", offset=\"0.0\")\n            &gt;&gt;&gt; PrismaticJoint.from_xml(element)\n\n            PrismaticJoint(\n                name=\"joint1\",\n                parent=\"base_link\",\n                child=\"link1\",\n                origin=Origin(xyz=(0, 0, 0), rpy=(0, 0, 0)),\n                limits=JointLimits(effort=10.0, velocity=1.0, lower=-1.0, upper=1.0),\n                axis=Axis(xyz=(0, 0, 1)),\n                dynamics=JointDynamics(damping=0.0, friction=0.0),\n                mimic=JointMimic(joint=\"joint1\", multiplier=1.0, offset=0.0)\n            )\n        \"\"\"\n\n        name = element.attrib[\"name\"]\n        parent_elem = element.find(\"parent\")\n        child_elem = element.find(\"child\")\n        origin_elem = element.find(\"origin\")\n\n        if parent_elem is None or child_elem is None or origin_elem is None:\n            raise ValueError(\"Missing required elements in joint XML\")\n\n        parent = parent_elem.attrib[\"link\"]\n        child = child_elem.attrib[\"link\"]\n        origin = Origin.from_xml(origin_elem)\n\n        limit_element = element.find(\"limit\")\n        if limit_element is not None:\n            limits = JointLimits(\n                effort=float(limit_element.attrib.get(\"effort\", 0)),\n                velocity=float(limit_element.attrib.get(\"velocity\", 0)),\n                lower=float(limit_element.attrib.get(\"lower\", 0)),\n                upper=float(limit_element.attrib.get(\"upper\", 0)),\n            )\n        else:\n            raise ValueError(\"PrismaticJoint requires limit element\")\n\n        axis = Axis.from_xml(element.find(\"axis\"))\n\n        dynamics_element = element.find(\"dynamics\")\n        if dynamics_element is not None:\n            dynamics = JointDynamics(\n                damping=float(dynamics_element.attrib.get(\"damping\", 0)),\n                friction=float(dynamics_element.attrib.get(\"friction\", 0)),\n            )\n        else:\n            dynamics = None\n\n        mimic_element = element.find(\"mimic\")\n        mimic = JointMimic.from_xml(mimic_element) if mimic_element is not None else None\n\n        return cls(name, parent, child, origin, limits, axis, dynamics, mimic)\n\n    @property\n    def joint_type(self) -&gt; str:\n        \"\"\"\n        The type of the joint.\n\n        Returns:\n            The type of the joint: \"prismatic\".\n        \"\"\"\n\n        return JointType.PRISMATIC\n</code></pre>"},{"location":"api/joint/#onshape_robotics_toolkit.models.joint.PrismaticJoint.joint_type","title":"<code>joint_type</code>  <code>property</code>","text":"<p>The type of the joint.</p> <p>Returns:</p> Type Description <code>str</code> <p>The type of the joint: \"prismatic\".</p>"},{"location":"api/joint/#onshape_robotics_toolkit.models.joint.PrismaticJoint.from_xml","title":"<code>from_xml(element)</code>  <code>classmethod</code>","text":"<p>Create a prismatic joint from an XML element.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>_Element</code> <p>The XML element to create the prismatic joint from.</p> required <p>Returns:</p> Type Description <code>PrismaticJoint</code> <p>The prismatic joint created from the XML element.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; element = ET.Element(\"joint\")\n&gt;&gt;&gt; element.set(\"name\", \"joint1\")\n&gt;&gt;&gt; element.set(\"type\", \"prismatic\")\n&gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n&gt;&gt;&gt; ET.SubElement(element, \"origin\", xyz=\"0 0 0\", rpy=\"0 0 0\")\n&gt;&gt;&gt; ET.SubElement(element, \"parent\", link=\"base_link\")\n&gt;&gt;&gt; ET.SubElement(element, \"child\", link=\"link1\")\n&gt;&gt;&gt; limits = ET.SubElement(element, \"limit\", effort=\"10.0\", velocity=\"1.0\", lower=\"-1.0\", upper=\"1.0\")\n&gt;&gt;&gt; axis = ET.SubElement(element, \"axis\", xyz=\"0 0 1\")\n&gt;&gt;&gt; dynamics = ET.SubElement(element, \"dynamics\", damping=\"0.0\", friction=\"0.0\")\n&gt;&gt;&gt; mimic = ET.SubElement(element, \"mimic\", joint=\"joint1\", multiplier=\"1.0\", offset=\"0.0\")\n&gt;&gt;&gt; PrismaticJoint.from_xml(element)\n</code></pre> <p>PrismaticJoint(     name=\"joint1\",     parent=\"base_link\",     child=\"link1\",     origin=Origin(xyz=(0, 0, 0), rpy=(0, 0, 0)),     limits=JointLimits(effort=10.0, velocity=1.0, lower=-1.0, upper=1.0),     axis=Axis(xyz=(0, 0, 1)),     dynamics=JointDynamics(damping=0.0, friction=0.0),     mimic=JointMimic(joint=\"joint1\", multiplier=1.0, offset=0.0) )</p> Source code in <code>onshape_robotics_toolkit/models/joint.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: _Element) -&gt; \"PrismaticJoint\":\n    \"\"\"\n    Create a prismatic joint from an XML element.\n\n    Args:\n        element: The XML element to create the prismatic joint from.\n\n    Returns:\n        The prismatic joint created from the XML element.\n\n    Examples:\n        &gt;&gt;&gt; element = ET.Element(\"joint\")\n        &gt;&gt;&gt; element.set(\"name\", \"joint1\")\n        &gt;&gt;&gt; element.set(\"type\", \"prismatic\")\n        &gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n        &gt;&gt;&gt; ET.SubElement(element, \"origin\", xyz=\"0 0 0\", rpy=\"0 0 0\")\n        &gt;&gt;&gt; ET.SubElement(element, \"parent\", link=\"base_link\")\n        &gt;&gt;&gt; ET.SubElement(element, \"child\", link=\"link1\")\n        &gt;&gt;&gt; limits = ET.SubElement(element, \"limit\", effort=\"10.0\", velocity=\"1.0\", lower=\"-1.0\", upper=\"1.0\")\n        &gt;&gt;&gt; axis = ET.SubElement(element, \"axis\", xyz=\"0 0 1\")\n        &gt;&gt;&gt; dynamics = ET.SubElement(element, \"dynamics\", damping=\"0.0\", friction=\"0.0\")\n        &gt;&gt;&gt; mimic = ET.SubElement(element, \"mimic\", joint=\"joint1\", multiplier=\"1.0\", offset=\"0.0\")\n        &gt;&gt;&gt; PrismaticJoint.from_xml(element)\n\n        PrismaticJoint(\n            name=\"joint1\",\n            parent=\"base_link\",\n            child=\"link1\",\n            origin=Origin(xyz=(0, 0, 0), rpy=(0, 0, 0)),\n            limits=JointLimits(effort=10.0, velocity=1.0, lower=-1.0, upper=1.0),\n            axis=Axis(xyz=(0, 0, 1)),\n            dynamics=JointDynamics(damping=0.0, friction=0.0),\n            mimic=JointMimic(joint=\"joint1\", multiplier=1.0, offset=0.0)\n        )\n    \"\"\"\n\n    name = element.attrib[\"name\"]\n    parent_elem = element.find(\"parent\")\n    child_elem = element.find(\"child\")\n    origin_elem = element.find(\"origin\")\n\n    if parent_elem is None or child_elem is None or origin_elem is None:\n        raise ValueError(\"Missing required elements in joint XML\")\n\n    parent = parent_elem.attrib[\"link\"]\n    child = child_elem.attrib[\"link\"]\n    origin = Origin.from_xml(origin_elem)\n\n    limit_element = element.find(\"limit\")\n    if limit_element is not None:\n        limits = JointLimits(\n            effort=float(limit_element.attrib.get(\"effort\", 0)),\n            velocity=float(limit_element.attrib.get(\"velocity\", 0)),\n            lower=float(limit_element.attrib.get(\"lower\", 0)),\n            upper=float(limit_element.attrib.get(\"upper\", 0)),\n        )\n    else:\n        raise ValueError(\"PrismaticJoint requires limit element\")\n\n    axis = Axis.from_xml(element.find(\"axis\"))\n\n    dynamics_element = element.find(\"dynamics\")\n    if dynamics_element is not None:\n        dynamics = JointDynamics(\n            damping=float(dynamics_element.attrib.get(\"damping\", 0)),\n            friction=float(dynamics_element.attrib.get(\"friction\", 0)),\n        )\n    else:\n        dynamics = None\n\n    mimic_element = element.find(\"mimic\")\n    mimic = JointMimic.from_xml(mimic_element) if mimic_element is not None else None\n\n    return cls(name, parent, child, origin, limits, axis, dynamics, mimic)\n</code></pre>"},{"location":"api/joint/#onshape_robotics_toolkit.models.joint.PrismaticJoint.to_xml","title":"<code>to_xml(root=None)</code>","text":"<p>Convert the prismatic joint to an XML element.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>Optional[_Element]</code> <p>The root element to append the prismatic joint to.</p> <code>None</code> <p>Returns:</p> Type Description <code>_Element</code> <p>The XML element representing the prismatic joint</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n&gt;&gt;&gt; limits = JointLimits(effort=10.0, velocity=1.0, lower=-1.0, upper=1.0)\n&gt;&gt;&gt; axis = Axis(xyz=(0, 0, 1))\n&gt;&gt;&gt; dynamics = JointDynamics(damping=0.0, friction=0.0)\n&gt;&gt;&gt; mimic = JointMimic(joint=\"joint1\", multiplier=1.0, offset=0.0)\n&gt;&gt;&gt; joint = PrismaticJoint(\n...     name=\"joint1\",\n...     parent=\"base_link\",\n...     child=\"link1\",\n...     origin=origin,\n...     limits=limits,\n...     axis=axis,\n...     dynamics=dynamics,\n...     mimic=mimic,\n... )\n&gt;&gt;&gt; joint.to_xml()\n&lt;Element 'joint' at 0x7f8b3c0b4c70&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/joint.py</code> <pre><code>def to_xml(self, root: Optional[_Element] = None) -&gt; _Element:\n    \"\"\"\n    Convert the prismatic joint to an XML element.\n\n    Args:\n        root: The root element to append the prismatic joint to.\n\n    Returns:\n        The XML element representing the prismatic joint\n\n    Examples:\n        &gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n        &gt;&gt;&gt; limits = JointLimits(effort=10.0, velocity=1.0, lower=-1.0, upper=1.0)\n        &gt;&gt;&gt; axis = Axis(xyz=(0, 0, 1))\n        &gt;&gt;&gt; dynamics = JointDynamics(damping=0.0, friction=0.0)\n        &gt;&gt;&gt; mimic = JointMimic(joint=\"joint1\", multiplier=1.0, offset=0.0)\n        &gt;&gt;&gt; joint = PrismaticJoint(\n        ...     name=\"joint1\",\n        ...     parent=\"base_link\",\n        ...     child=\"link1\",\n        ...     origin=origin,\n        ...     limits=limits,\n        ...     axis=axis,\n        ...     dynamics=dynamics,\n        ...     mimic=mimic,\n        ... )\n        &gt;&gt;&gt; joint.to_xml()\n        &lt;Element 'joint' at 0x7f8b3c0b4c70&gt;\n    \"\"\"\n\n    joint = super().to_xml(root)\n    self.axis.to_xml(joint)\n    if self.limits is not None:\n        self.limits.to_xml(joint)\n    if self.dynamics is not None:\n        self.dynamics.to_xml(joint)\n    if self.mimic is not None:\n        self.mimic.to_xml(joint)\n    return joint\n</code></pre>"},{"location":"api/joint/#onshape_robotics_toolkit.models.joint.RevoluteJoint","title":"<code>RevoluteJoint</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseJoint</code></p> <p>Represents a revolute joint.</p> <p>Attributes:</p> Name Type Description <code>limits</code> <code>JointLimits</code> <p>The limits of the joint.</p> <code>axis</code> <code>Axis</code> <p>The axis of the joint.</p> <code>dynamics</code> <code>JointDynamics</code> <p>The dynamics of the joint.</p> <code>mimic</code> <code>JointMimic</code> <p>The mimic information for the joint.</p> <p>Methods:</p> Name Description <code>to_xml</code> <p>Converts the revolute joint to an XML element.</p> Properties <p>joint_type: The type of the joint.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n&gt;&gt;&gt; limits = JointLimits(effort=10.0, velocity=1.0, lower=-1.0, upper=1.0)\n&gt;&gt;&gt; axis = Axis(xyz=(0, 0, 1))\n&gt;&gt;&gt; dynamics = JointDynamics(damping=0.0, friction=0.0)\n&gt;&gt;&gt; mimic = JointMimic(joint=\"joint1\", multiplier=1.0, offset=0.0)\n&gt;&gt;&gt; joint = RevoluteJoint(\n...     name=\"joint1\",\n...     parent=\"base_link\",\n...     child=\"link1\",\n...     origin=origin,\n...     limits=limits,\n...     axis=axis,\n...     dynamics=dynamics,\n...     mimic=mimic,\n... )\n&gt;&gt;&gt; joint.to_xml()\n&lt;Element 'joint' at 0x7f8b3c0b4c70&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/joint.py</code> <pre><code>@dataclass\nclass RevoluteJoint(BaseJoint):\n    \"\"\"\n    Represents a revolute joint.\n\n    Attributes:\n        limits (JointLimits): The limits of the joint.\n        axis (Axis): The axis of the joint.\n        dynamics (JointDynamics): The dynamics of the joint.\n        mimic (JointMimic): The mimic information for the joint.\n\n    Methods:\n        to_xml: Converts the revolute joint to an XML element.\n\n    Properties:\n        joint_type: The type of the joint.\n\n    Examples:\n        &gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n        &gt;&gt;&gt; limits = JointLimits(effort=10.0, velocity=1.0, lower=-1.0, upper=1.0)\n        &gt;&gt;&gt; axis = Axis(xyz=(0, 0, 1))\n        &gt;&gt;&gt; dynamics = JointDynamics(damping=0.0, friction=0.0)\n        &gt;&gt;&gt; mimic = JointMimic(joint=\"joint1\", multiplier=1.0, offset=0.0)\n        &gt;&gt;&gt; joint = RevoluteJoint(\n        ...     name=\"joint1\",\n        ...     parent=\"base_link\",\n        ...     child=\"link1\",\n        ...     origin=origin,\n        ...     limits=limits,\n        ...     axis=axis,\n        ...     dynamics=dynamics,\n        ...     mimic=mimic,\n        ... )\n        &gt;&gt;&gt; joint.to_xml()\n        &lt;Element 'joint' at 0x7f8b3c0b4c70&gt;\n    \"\"\"\n\n    axis: Axis\n    limits: JointLimits | None = None\n    dynamics: JointDynamics | None = None\n    mimic: JointMimic | None = None\n\n    def to_xml(self, root: Optional[_Element] = None) -&gt; _Element:\n        \"\"\"\n        Convert the revolute joint to an XML element.\n\n        Args:\n            root: The root element to append the revolute joint to.\n\n        Returns:\n            The XML element representing the revolute joint.\n\n        Examples:\n            &gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n            &gt;&gt;&gt; limits = JointLimits(effort=10.0, velocity=1.0, lower=-1.0, upper=1.0)\n            &gt;&gt;&gt; axis = Axis(xyz=(0, 0, 1))\n            &gt;&gt;&gt; dynamics = JointDynamics(damping=0.0, friction=0.0)\n            &gt;&gt;&gt; mimic = JointMimic(joint=\"joint1\", multiplier=1.0, offset=0.0)\n            &gt;&gt;&gt; joint = RevoluteJoint(\n            ...     name=\"joint1\",\n            ...     parent=\"base_link\",\n            ...     child=\"link1\",\n            ...     origin=origin,\n            ...     limits=limits,\n            ...     axis=axis,\n            ...     dynamics=dynamics,\n            ...     mimic=mimic,\n            ... )\n            &gt;&gt;&gt; joint.to_xml()\n            &lt;Element 'joint' at 0x7f8b3c0b4c70&gt;\n        \"\"\"\n\n        joint = super().to_xml(root)\n        self.axis.to_xml(joint)\n        if self.limits is not None:\n            self.limits.to_xml(joint)\n        if self.dynamics is not None:\n            self.dynamics.to_xml(joint)\n        if self.mimic is not None:\n            self.mimic.to_xml(joint)\n        return joint\n\n    def to_mjcf(self, root: _Element) -&gt; None:\n        \"\"\"\n        Converts the revolute joint to an XML element and appends it to the given root element.\n\n        Args:\n            root: The root element to append the revolute joint to.\n        \"\"\"\n\n        joint: _Element = SubElement(root, \"joint\", name=self.name, type=MJCF_JOINT_MAP[JointType(self.joint_type)])\n        joint.set(\"pos\", \" \".join(map(str, self.origin.xyz)))\n\n        self.axis.to_mjcf(joint)\n        if self.limits:\n            joint.set(\"range\", \" \".join(map(str, [self.limits.lower, self.limits.upper])))\n\n        if self.dynamics:\n            joint.set(\"damping\", str(self.dynamics.damping))\n            joint.set(\"frictionloss\", str(self.dynamics.friction))\n\n    @classmethod\n    def from_xml(cls, element: _Element) -&gt; \"RevoluteJoint\":\n        \"\"\"\n        Create a revolute joint from an XML element.\n\n        Args:\n            element: The XML element to create the revolute joint from.\n\n        Returns:\n            The revolute joint created from the XML element.\n\n        Examples:\n            &gt;&gt;&gt; element = ET.Element(\"joint\")\n            &gt;&gt;&gt; element.set(\"name\", \"joint1\")\n            &gt;&gt;&gt; element.set(\"type\", \"revolute\")\n            &gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n            &gt;&gt;&gt; ET.SubElement(element, \"origin\", xyz=\"0 0 0\", rpy=\"0 0 0\")\n            &gt;&gt;&gt; ET.SubElement(element, \"parent\", link=\"base_link\")\n            &gt;&gt;&gt; ET.SubElement(element, \"child\", link=\"link1\")\n            &gt;&gt;&gt; limits = ET.SubElement(element, \"limit\", effort=\"10.0\", velocity=\"1.0\", lower=\"-1.0\", upper=\"1.0\")\n            &gt;&gt;&gt; axis = ET.SubElement(element, \"axis\", xyz=\"0 0 1\")\n            &gt;&gt;&gt; dynamics = ET.SubElement(element, \"dynamics\", damping=\"0.0\", friction=\"0.0\")\n            &gt;&gt;&gt; mimic = ET.SubElement(element, \"mimic\", joint=\"joint1\", multiplier=\"1.0\", offset=\"0.0\")\n            &gt;&gt;&gt; RevoluteJoint.from_xml(element)\n\n            RevoluteJoint(\n                name=\"joint1\",\n                parent=\"base_link\",\n                child=\"link1\",\n                origin=Origin(xyz=(0, 0, 0), rpy=(0, 0, 0)),\n                limits=JointLimits(effort=10.0, velocity=1.0, lower=-1.0, upper=1.0),\n                axis=Axis(xyz=(0, 0, 1)),\n                dynamics=JointDynamics(damping=0.0, friction=0.0),\n                mimic=JointMimic(joint=\"joint1\", multiplier=1.0, offset=0.0)\n            )\n        \"\"\"\n\n        name = element.attrib[\"name\"]\n        parent_elem = element.find(\"parent\")\n        child_elem = element.find(\"child\")\n        origin_elem = element.find(\"origin\")\n\n        if parent_elem is None or child_elem is None or origin_elem is None:\n            raise ValueError(\"Missing required elements in joint XML\")\n\n        parent = parent_elem.attrib[\"link\"]\n        child = child_elem.attrib[\"link\"]\n        origin = Origin.from_xml(origin_elem)\n        # Handle limits\n        limit_element = element.find(\"limit\")\n        if limit_element is not None:\n            limits = JointLimits(\n                effort=float(limit_element.attrib.get(\"effort\", 0)),\n                velocity=float(limit_element.attrib.get(\"velocity\", 0)),\n                lower=float(limit_element.attrib.get(\"lower\", 0)),\n                upper=float(limit_element.attrib.get(\"upper\", 0)),\n            )\n        else:\n            limits = None\n\n        # Handle axis\n        axis = Axis.from_xml(element.find(\"axis\"))\n\n        # Handle dynamics\n        dynamics_element = element.find(\"dynamics\")\n        if dynamics_element is not None:\n            dynamics = JointDynamics(\n                damping=float(dynamics_element.attrib.get(\"damping\", 0)),\n                friction=float(dynamics_element.attrib.get(\"friction\", 0)),\n            )\n        else:\n            dynamics = None\n\n        # Handle mimic\n        mimic_element = element.find(\"mimic\")\n        mimic = JointMimic.from_xml(mimic_element) if mimic_element is not None else None\n\n        return cls(\n            name=name,\n            parent=parent,\n            child=child,\n            origin=origin,\n            axis=axis,\n            limits=limits,\n            dynamics=dynamics,\n            mimic=mimic,\n        )\n\n    @property\n    def joint_type(self) -&gt; str:\n        \"\"\"\n        The type of the joint.\n\n        Returns:\n            The type of the joint: \"revolute\".\n        \"\"\"\n\n        return JointType.REVOLUTE\n</code></pre>"},{"location":"api/joint/#onshape_robotics_toolkit.models.joint.RevoluteJoint.joint_type","title":"<code>joint_type</code>  <code>property</code>","text":"<p>The type of the joint.</p> <p>Returns:</p> Type Description <code>str</code> <p>The type of the joint: \"revolute\".</p>"},{"location":"api/joint/#onshape_robotics_toolkit.models.joint.RevoluteJoint.from_xml","title":"<code>from_xml(element)</code>  <code>classmethod</code>","text":"<p>Create a revolute joint from an XML element.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>_Element</code> <p>The XML element to create the revolute joint from.</p> required <p>Returns:</p> Type Description <code>RevoluteJoint</code> <p>The revolute joint created from the XML element.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; element = ET.Element(\"joint\")\n&gt;&gt;&gt; element.set(\"name\", \"joint1\")\n&gt;&gt;&gt; element.set(\"type\", \"revolute\")\n&gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n&gt;&gt;&gt; ET.SubElement(element, \"origin\", xyz=\"0 0 0\", rpy=\"0 0 0\")\n&gt;&gt;&gt; ET.SubElement(element, \"parent\", link=\"base_link\")\n&gt;&gt;&gt; ET.SubElement(element, \"child\", link=\"link1\")\n&gt;&gt;&gt; limits = ET.SubElement(element, \"limit\", effort=\"10.0\", velocity=\"1.0\", lower=\"-1.0\", upper=\"1.0\")\n&gt;&gt;&gt; axis = ET.SubElement(element, \"axis\", xyz=\"0 0 1\")\n&gt;&gt;&gt; dynamics = ET.SubElement(element, \"dynamics\", damping=\"0.0\", friction=\"0.0\")\n&gt;&gt;&gt; mimic = ET.SubElement(element, \"mimic\", joint=\"joint1\", multiplier=\"1.0\", offset=\"0.0\")\n&gt;&gt;&gt; RevoluteJoint.from_xml(element)\n</code></pre> <p>RevoluteJoint(     name=\"joint1\",     parent=\"base_link\",     child=\"link1\",     origin=Origin(xyz=(0, 0, 0), rpy=(0, 0, 0)),     limits=JointLimits(effort=10.0, velocity=1.0, lower=-1.0, upper=1.0),     axis=Axis(xyz=(0, 0, 1)),     dynamics=JointDynamics(damping=0.0, friction=0.0),     mimic=JointMimic(joint=\"joint1\", multiplier=1.0, offset=0.0) )</p> Source code in <code>onshape_robotics_toolkit/models/joint.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: _Element) -&gt; \"RevoluteJoint\":\n    \"\"\"\n    Create a revolute joint from an XML element.\n\n    Args:\n        element: The XML element to create the revolute joint from.\n\n    Returns:\n        The revolute joint created from the XML element.\n\n    Examples:\n        &gt;&gt;&gt; element = ET.Element(\"joint\")\n        &gt;&gt;&gt; element.set(\"name\", \"joint1\")\n        &gt;&gt;&gt; element.set(\"type\", \"revolute\")\n        &gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n        &gt;&gt;&gt; ET.SubElement(element, \"origin\", xyz=\"0 0 0\", rpy=\"0 0 0\")\n        &gt;&gt;&gt; ET.SubElement(element, \"parent\", link=\"base_link\")\n        &gt;&gt;&gt; ET.SubElement(element, \"child\", link=\"link1\")\n        &gt;&gt;&gt; limits = ET.SubElement(element, \"limit\", effort=\"10.0\", velocity=\"1.0\", lower=\"-1.0\", upper=\"1.0\")\n        &gt;&gt;&gt; axis = ET.SubElement(element, \"axis\", xyz=\"0 0 1\")\n        &gt;&gt;&gt; dynamics = ET.SubElement(element, \"dynamics\", damping=\"0.0\", friction=\"0.0\")\n        &gt;&gt;&gt; mimic = ET.SubElement(element, \"mimic\", joint=\"joint1\", multiplier=\"1.0\", offset=\"0.0\")\n        &gt;&gt;&gt; RevoluteJoint.from_xml(element)\n\n        RevoluteJoint(\n            name=\"joint1\",\n            parent=\"base_link\",\n            child=\"link1\",\n            origin=Origin(xyz=(0, 0, 0), rpy=(0, 0, 0)),\n            limits=JointLimits(effort=10.0, velocity=1.0, lower=-1.0, upper=1.0),\n            axis=Axis(xyz=(0, 0, 1)),\n            dynamics=JointDynamics(damping=0.0, friction=0.0),\n            mimic=JointMimic(joint=\"joint1\", multiplier=1.0, offset=0.0)\n        )\n    \"\"\"\n\n    name = element.attrib[\"name\"]\n    parent_elem = element.find(\"parent\")\n    child_elem = element.find(\"child\")\n    origin_elem = element.find(\"origin\")\n\n    if parent_elem is None or child_elem is None or origin_elem is None:\n        raise ValueError(\"Missing required elements in joint XML\")\n\n    parent = parent_elem.attrib[\"link\"]\n    child = child_elem.attrib[\"link\"]\n    origin = Origin.from_xml(origin_elem)\n    # Handle limits\n    limit_element = element.find(\"limit\")\n    if limit_element is not None:\n        limits = JointLimits(\n            effort=float(limit_element.attrib.get(\"effort\", 0)),\n            velocity=float(limit_element.attrib.get(\"velocity\", 0)),\n            lower=float(limit_element.attrib.get(\"lower\", 0)),\n            upper=float(limit_element.attrib.get(\"upper\", 0)),\n        )\n    else:\n        limits = None\n\n    # Handle axis\n    axis = Axis.from_xml(element.find(\"axis\"))\n\n    # Handle dynamics\n    dynamics_element = element.find(\"dynamics\")\n    if dynamics_element is not None:\n        dynamics = JointDynamics(\n            damping=float(dynamics_element.attrib.get(\"damping\", 0)),\n            friction=float(dynamics_element.attrib.get(\"friction\", 0)),\n        )\n    else:\n        dynamics = None\n\n    # Handle mimic\n    mimic_element = element.find(\"mimic\")\n    mimic = JointMimic.from_xml(mimic_element) if mimic_element is not None else None\n\n    return cls(\n        name=name,\n        parent=parent,\n        child=child,\n        origin=origin,\n        axis=axis,\n        limits=limits,\n        dynamics=dynamics,\n        mimic=mimic,\n    )\n</code></pre>"},{"location":"api/joint/#onshape_robotics_toolkit.models.joint.RevoluteJoint.to_mjcf","title":"<code>to_mjcf(root)</code>","text":"<p>Converts the revolute joint to an XML element and appends it to the given root element.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>_Element</code> <p>The root element to append the revolute joint to.</p> required Source code in <code>onshape_robotics_toolkit/models/joint.py</code> <pre><code>def to_mjcf(self, root: _Element) -&gt; None:\n    \"\"\"\n    Converts the revolute joint to an XML element and appends it to the given root element.\n\n    Args:\n        root: The root element to append the revolute joint to.\n    \"\"\"\n\n    joint: _Element = SubElement(root, \"joint\", name=self.name, type=MJCF_JOINT_MAP[JointType(self.joint_type)])\n    joint.set(\"pos\", \" \".join(map(str, self.origin.xyz)))\n\n    self.axis.to_mjcf(joint)\n    if self.limits:\n        joint.set(\"range\", \" \".join(map(str, [self.limits.lower, self.limits.upper])))\n\n    if self.dynamics:\n        joint.set(\"damping\", str(self.dynamics.damping))\n        joint.set(\"frictionloss\", str(self.dynamics.friction))\n</code></pre>"},{"location":"api/joint/#onshape_robotics_toolkit.models.joint.RevoluteJoint.to_xml","title":"<code>to_xml(root=None)</code>","text":"<p>Convert the revolute joint to an XML element.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>Optional[_Element]</code> <p>The root element to append the revolute joint to.</p> <code>None</code> <p>Returns:</p> Type Description <code>_Element</code> <p>The XML element representing the revolute joint.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n&gt;&gt;&gt; limits = JointLimits(effort=10.0, velocity=1.0, lower=-1.0, upper=1.0)\n&gt;&gt;&gt; axis = Axis(xyz=(0, 0, 1))\n&gt;&gt;&gt; dynamics = JointDynamics(damping=0.0, friction=0.0)\n&gt;&gt;&gt; mimic = JointMimic(joint=\"joint1\", multiplier=1.0, offset=0.0)\n&gt;&gt;&gt; joint = RevoluteJoint(\n...     name=\"joint1\",\n...     parent=\"base_link\",\n...     child=\"link1\",\n...     origin=origin,\n...     limits=limits,\n...     axis=axis,\n...     dynamics=dynamics,\n...     mimic=mimic,\n... )\n&gt;&gt;&gt; joint.to_xml()\n&lt;Element 'joint' at 0x7f8b3c0b4c70&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/joint.py</code> <pre><code>def to_xml(self, root: Optional[_Element] = None) -&gt; _Element:\n    \"\"\"\n    Convert the revolute joint to an XML element.\n\n    Args:\n        root: The root element to append the revolute joint to.\n\n    Returns:\n        The XML element representing the revolute joint.\n\n    Examples:\n        &gt;&gt;&gt; origin = Origin(xyz=(0, 0, 0), rpy=(0, 0, 0))\n        &gt;&gt;&gt; limits = JointLimits(effort=10.0, velocity=1.0, lower=-1.0, upper=1.0)\n        &gt;&gt;&gt; axis = Axis(xyz=(0, 0, 1))\n        &gt;&gt;&gt; dynamics = JointDynamics(damping=0.0, friction=0.0)\n        &gt;&gt;&gt; mimic = JointMimic(joint=\"joint1\", multiplier=1.0, offset=0.0)\n        &gt;&gt;&gt; joint = RevoluteJoint(\n        ...     name=\"joint1\",\n        ...     parent=\"base_link\",\n        ...     child=\"link1\",\n        ...     origin=origin,\n        ...     limits=limits,\n        ...     axis=axis,\n        ...     dynamics=dynamics,\n        ...     mimic=mimic,\n        ... )\n        &gt;&gt;&gt; joint.to_xml()\n        &lt;Element 'joint' at 0x7f8b3c0b4c70&gt;\n    \"\"\"\n\n    joint = super().to_xml(root)\n    self.axis.to_xml(joint)\n    if self.limits is not None:\n        self.limits.to_xml(joint)\n    if self.dynamics is not None:\n        self.dynamics.to_xml(joint)\n    if self.mimic is not None:\n        self.mimic.to_xml(joint)\n    return joint\n</code></pre>"},{"location":"api/link/","title":"Link","text":"<p>This module contains dataclasses for creating a link in a URDF robot model.</p> Dataclass <ul> <li>Origin: Represents the origin of a link in the robot model.</li> <li>Axis: Represents the axis of a link in the robot model.</li> <li>Inertia: Represents the inertia properties of a link in the robot model.</li> <li>Material: Represents the material properties of a link in the robot model.</li> <li>InertialLink: Represents the inertial properties of a link in the robot model.</li> <li>VisualLink: Represents the visual properties of a link in the robot model.</li> <li>CollisionLink: Represents the collision properties of a link in the robot model.</li> <li>Link: Represents a link in the robot model.</li> </ul> Enum <ul> <li>Colors: Enumerates the possible colors for a link in the robot model.</li> </ul>"},{"location":"api/link/#onshape_robotics_toolkit.models.link.Axis","title":"<code>Axis</code>  <code>dataclass</code>","text":"<p>Represents the axis of rotation or translation for a joint in the robot model.</p> <p>Attributes:</p> Name Type Description <code>xyz</code> <code>tuple[float, float, float]</code> <p>The direction vector of the axis. Should be a unit vector (normalized).</p> <p>Methods:</p> Name Description <code>to_xml</code> <p>Converts the axis to an XML element.</p> <code>to_mjcf</code> <p>Converts the axis to a MuJoCo compatible XML element.</p> Class Methods <p>from_xml: Creates an axis from an XML element.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; axis = Axis(xyz=(1.0, 0.0, 0.0))  # X-axis rotation\n&gt;&gt;&gt; axis.to_xml()\n&lt;Element 'axis' at 0x...&gt;\n</code></pre> <pre><code>&gt;&gt;&gt; xml_str = '&lt;axis xyz=\"0 1 0\"/&gt;'\n&gt;&gt;&gt; xml_element = ET.fromstring(xml_str)\n&gt;&gt;&gt; axis = Axis.from_xml(xml_element)\n&gt;&gt;&gt; axis.xyz\n(0.0, 1.0, 0.0)\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/link.py</code> <pre><code>@dataclass\nclass Axis:\n    \"\"\"\n    Represents the axis of rotation or translation for a joint in the robot model.\n\n    Attributes:\n        xyz (tuple[float, float, float]): The direction vector of the axis.\n            Should be a unit vector (normalized).\n\n    Methods:\n        to_xml: Converts the axis to an XML element.\n        to_mjcf: Converts the axis to a MuJoCo compatible XML element.\n\n    Class Methods:\n        from_xml: Creates an axis from an XML element.\n\n    Examples:\n        &gt;&gt;&gt; axis = Axis(xyz=(1.0, 0.0, 0.0))  # X-axis rotation\n        &gt;&gt;&gt; axis.to_xml()\n        &lt;Element 'axis' at 0x...&gt;\n\n        &gt;&gt;&gt; xml_str = '&lt;axis xyz=\"0 1 0\"/&gt;'\n        &gt;&gt;&gt; xml_element = ET.fromstring(xml_str)\n        &gt;&gt;&gt; axis = Axis.from_xml(xml_element)\n        &gt;&gt;&gt; axis.xyz\n        (0.0, 1.0, 0.0)\n    \"\"\"\n\n    xyz: tuple[float, float, float]\n\n    def to_xml(self, root: Optional[_Element] = None) -&gt; _Element:\n        \"\"\"\n        Convert the axis to an XML element.\n\n        Args:\n            root: The root element to append the axis to.\n\n        Returns:\n            The XML element representing the axis.\n\n        Examples:\n            &gt;&gt;&gt; axis = Axis(xyz=(1.0, 0.0, 0.0))\n            &gt;&gt;&gt; axis.to_xml()\n            &lt;Element 'axis' at 0x7f8b3c0b4c70&gt;\n        \"\"\"\n\n        axis: _Element = ET.Element(\"axis\") if root is None else ET.SubElement(root, \"axis\")\n        axis.set(\"xyz\", \" \".join(format_number(v) for v in self.xyz))\n        return axis\n\n    def to_mjcf(self, root: _Element) -&gt; None:\n        \"\"\"\n        Convert the axis to an MuJoCo compatible XML element.\n\n        Args:\n            root: The root element to append the axis to.\n\n        Returns:\n            The XML element representing the axis.\n\n        Examples:\n            &gt;&gt;&gt; axis = Axis(xyz=(1.0, 0.0, 0.0))\n            &gt;&gt;&gt; axis.to_mjcf()\n            &lt;Element 'axis' at 0x7f8b3c0b4c70&gt;\n        \"\"\"\n        root.set(\"axis\", \" \".join(format_number(v) for v in self.xyz))\n\n    @classmethod\n    def from_xml(cls, xml: Optional[_Element]) -&gt; \"Axis\":\n        \"\"\"\n        Create an axis from an XML element.\n\n        Args:\n            xml: The XML element to create the axis from.\n\n        Returns:\n            The axis created from the XML element.\n\n        Examples:\n            &gt;&gt;&gt; xml = ET.Element('axis')\n            &gt;&gt;&gt; Axis.from_xml(xml)\n            Axis(xyz=(0.0, 0.0, 0.0))\n        \"\"\"\n        if xml is None:\n            raise ValueError(\"XML element for axis is None\")\n\n        xyz_str = xml.get(\"xyz\")\n\n        if xyz_str is None:\n            raise ValueError(\"Missing xyz attribute in axis XML\")\n\n        xyz_values = tuple(map(float, xyz_str.split()))\n\n        if len(xyz_values) != 3:\n            raise ValueError(\"xyz must have exactly 3 values\")\n\n        xyz = (xyz_values[0], xyz_values[1], xyz_values[2])\n        return cls(xyz)\n</code></pre>"},{"location":"api/link/#onshape_robotics_toolkit.models.link.Axis.from_xml","title":"<code>from_xml(xml)</code>  <code>classmethod</code>","text":"<p>Create an axis from an XML element.</p> <p>Parameters:</p> Name Type Description Default <code>xml</code> <code>Optional[_Element]</code> <p>The XML element to create the axis from.</p> required <p>Returns:</p> Type Description <code>Axis</code> <p>The axis created from the XML element.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; xml = ET.Element('axis')\n&gt;&gt;&gt; Axis.from_xml(xml)\nAxis(xyz=(0.0, 0.0, 0.0))\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/link.py</code> <pre><code>@classmethod\ndef from_xml(cls, xml: Optional[_Element]) -&gt; \"Axis\":\n    \"\"\"\n    Create an axis from an XML element.\n\n    Args:\n        xml: The XML element to create the axis from.\n\n    Returns:\n        The axis created from the XML element.\n\n    Examples:\n        &gt;&gt;&gt; xml = ET.Element('axis')\n        &gt;&gt;&gt; Axis.from_xml(xml)\n        Axis(xyz=(0.0, 0.0, 0.0))\n    \"\"\"\n    if xml is None:\n        raise ValueError(\"XML element for axis is None\")\n\n    xyz_str = xml.get(\"xyz\")\n\n    if xyz_str is None:\n        raise ValueError(\"Missing xyz attribute in axis XML\")\n\n    xyz_values = tuple(map(float, xyz_str.split()))\n\n    if len(xyz_values) != 3:\n        raise ValueError(\"xyz must have exactly 3 values\")\n\n    xyz = (xyz_values[0], xyz_values[1], xyz_values[2])\n    return cls(xyz)\n</code></pre>"},{"location":"api/link/#onshape_robotics_toolkit.models.link.Axis.to_mjcf","title":"<code>to_mjcf(root)</code>","text":"<p>Convert the axis to an MuJoCo compatible XML element.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>_Element</code> <p>The root element to append the axis to.</p> required <p>Returns:</p> Type Description <code>None</code> <p>The XML element representing the axis.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; axis = Axis(xyz=(1.0, 0.0, 0.0))\n&gt;&gt;&gt; axis.to_mjcf()\n&lt;Element 'axis' at 0x7f8b3c0b4c70&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/link.py</code> <pre><code>def to_mjcf(self, root: _Element) -&gt; None:\n    \"\"\"\n    Convert the axis to an MuJoCo compatible XML element.\n\n    Args:\n        root: The root element to append the axis to.\n\n    Returns:\n        The XML element representing the axis.\n\n    Examples:\n        &gt;&gt;&gt; axis = Axis(xyz=(1.0, 0.0, 0.0))\n        &gt;&gt;&gt; axis.to_mjcf()\n        &lt;Element 'axis' at 0x7f8b3c0b4c70&gt;\n    \"\"\"\n    root.set(\"axis\", \" \".join(format_number(v) for v in self.xyz))\n</code></pre>"},{"location":"api/link/#onshape_robotics_toolkit.models.link.Axis.to_xml","title":"<code>to_xml(root=None)</code>","text":"<p>Convert the axis to an XML element.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>Optional[_Element]</code> <p>The root element to append the axis to.</p> <code>None</code> <p>Returns:</p> Type Description <code>_Element</code> <p>The XML element representing the axis.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; axis = Axis(xyz=(1.0, 0.0, 0.0))\n&gt;&gt;&gt; axis.to_xml()\n&lt;Element 'axis' at 0x7f8b3c0b4c70&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/link.py</code> <pre><code>def to_xml(self, root: Optional[_Element] = None) -&gt; _Element:\n    \"\"\"\n    Convert the axis to an XML element.\n\n    Args:\n        root: The root element to append the axis to.\n\n    Returns:\n        The XML element representing the axis.\n\n    Examples:\n        &gt;&gt;&gt; axis = Axis(xyz=(1.0, 0.0, 0.0))\n        &gt;&gt;&gt; axis.to_xml()\n        &lt;Element 'axis' at 0x7f8b3c0b4c70&gt;\n    \"\"\"\n\n    axis: _Element = ET.Element(\"axis\") if root is None else ET.SubElement(root, \"axis\")\n    axis.set(\"xyz\", \" \".join(format_number(v) for v in self.xyz))\n    return axis\n</code></pre>"},{"location":"api/link/#onshape_robotics_toolkit.models.link.CollisionLink","title":"<code>CollisionLink</code>  <code>dataclass</code>","text":"<p>Represents the collision properties of a link in the robot model.</p> <p>This class defines the geometry used for collision detection in physics simulations, which may be different from the visual geometry.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>Union[str, None]</code> <p>Optional name identifier for the collision element.</p> <code>origin</code> <code>Origin</code> <p>The position and orientation of the collision geometry.</p> <code>geometry</code> <code>BaseGeometry</code> <p>The shape used for collision detection.</p> <code>friction</code> <code>Optional[tuple[float, float, float]]</code> <p>Optional friction coefficients (static, dynamic, rolling).</p> <p>Methods:</p> Name Description <code>to_xml</code> <p>Converts the collision properties to an XML element.</p> <code>to_mjcf</code> <p>Converts the collision properties to a MuJoCo compatible XML element.</p> <code>transform</code> <p>Applies a transformation matrix to the collision geometry's origin.</p> Class Methods <p>from_xml: Creates a CollisionLink from an XML element.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; collision = CollisionLink(\n...     name=\"link_collision\",\n...     origin=Origin.zero_origin(),\n...     geometry=BoxGeometry(size=(1.0, 1.0, 1.0))\n... )\n&gt;&gt;&gt; collision.to_xml()\n&lt;Element 'collision' at 0x...&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/link.py</code> <pre><code>@dataclass\nclass CollisionLink:\n    \"\"\"\n    Represents the collision properties of a link in the robot model.\n\n    This class defines the geometry used for collision detection in physics\n    simulations, which may be different from the visual geometry.\n\n    Attributes:\n        name (Union[str, None]): Optional name identifier for the collision element.\n        origin (Origin): The position and orientation of the collision geometry.\n        geometry (BaseGeometry): The shape used for collision detection.\n        friction (Optional[tuple[float, float, float]]): Optional friction coefficients\n            (static, dynamic, rolling).\n\n    Methods:\n        to_xml: Converts the collision properties to an XML element.\n        to_mjcf: Converts the collision properties to a MuJoCo compatible XML element.\n        transform: Applies a transformation matrix to the collision geometry's origin.\n\n    Class Methods:\n        from_xml: Creates a CollisionLink from an XML element.\n\n    Examples:\n        &gt;&gt;&gt; collision = CollisionLink(\n        ...     name=\"link_collision\",\n        ...     origin=Origin.zero_origin(),\n        ...     geometry=BoxGeometry(size=(1.0, 1.0, 1.0))\n        ... )\n        &gt;&gt;&gt; collision.to_xml()\n        &lt;Element 'collision' at 0x...&gt;\n    \"\"\"\n\n    name: Union[str, None]\n    origin: Origin\n    geometry: BaseGeometry\n\n    friction: Optional[tuple[float, float, float]] = None\n\n    def transform(self, transformation_matrix: np.ndarray) -&gt; None:\n        \"\"\"\n        Apply a transformation to the visual link's origin.\n\n        Args:\n            transformation_matrix (np.ndarray): A 4x4 transformation matrix (homogeneous).\n        \"\"\"\n        # Apply translation and rotation to the origin position\n        pos = np.array([self.origin.xyz[0], self.origin.xyz[1], self.origin.xyz[2], 1])\n        new_pos = transformation_matrix @ pos\n        self.origin.xyz = (float(new_pos[0]), float(new_pos[1]), float(new_pos[2]))  # Update position\n\n        # Extract the rotation from the transformation matrix\n        rotation_matrix = transformation_matrix[:3, :3]\n        current_rotation = R.from_euler(\"xyz\", self.origin.rpy)\n        new_rotation = R.from_matrix(rotation_matrix @ current_rotation.as_matrix())\n        euler_angles = new_rotation.as_euler(\"xyz\")\n        self.origin.rpy = (float(euler_angles[0]), float(euler_angles[1]), float(euler_angles[2]))\n\n    def to_xml(self, root: Optional[_Element] = None) -&gt; _Element:\n        \"\"\"\n        Convert the collision properties to an XML element.\n\n        Args:\n            root: The root element to append the collision properties to.\n\n        Returns:\n            The XML element representing the collision properties.\n\n        Examples:\n            &gt;&gt;&gt; collision = CollisionLink(origin=Origin(...), geometry=BoxGeometry(...))\n            &gt;&gt;&gt; collision.to_xml()\n            &lt;Element 'collision' at 0x7f8b3c0b4c70&gt;\n        \"\"\"\n        collision: _Element = ET.Element(\"collision\") if root is None else ET.SubElement(root, \"collision\")\n        if self.name:\n            collision.set(\"name\", self.name)\n        self.origin.to_xml(collision)\n        self.geometry.to_xml(collision)\n        return collision\n\n    def to_mjcf(self, root: _Element) -&gt; None:\n        \"\"\"\n        Convert the collision properties to an MuJoCo compatible XML element.\n\n        Example XML:\n        ```xml\n              &lt;geom name=\"Assembly-2-1-SUB-Part-5-1-collision\"\n                    pos=\"0.0994445 -0.000366963 0.0171076\"\n                    quat=\"-0.92388 -4.28774e-08 0.382683 0\"\n                    type=\"mesh\"\n                    rgba=\"1 0.5 0 1\"\n                    mesh=\"Assembly-2-1-SUB-Part-5-1\"\n                    contype=\"1\"\n                    conaffinity=\"0\"\n                    density=\"0\"\n                    group=\"1\"/&gt;\n        ```\n        Args:\n            root: The root element to append the collision properties to.\n\n        Returns:\n            The XML element representing the collision properties.\n\n        Examples:\n            &gt;&gt;&gt; collision = CollisionLink(origin=Origin(...), geometry=BoxGeometry(...))\n            &gt;&gt;&gt; collision.to_mjcf()\n            &lt;Element 'collision' at 0x7f8b3c0b4c70&gt;\n        \"\"\"\n        collision = root if root.tag == \"geom\" else ET.SubElement(root, \"geom\")\n        if self.name:\n            collision.set(\"name\", self.name)\n        collision.set(\"contype\", \"1\")\n        collision.set(\"conaffinity\", \"1\")\n        self.origin.to_mjcf(collision)\n\n        if self.geometry:\n            self.geometry.to_mjcf(collision)\n\n        collision.set(\"group\", \"0\")\n\n        if self.friction:\n            collision.set(\"friction\", \" \".join(format_number(v) for v in self.friction))\n\n    @classmethod\n    def from_xml(cls, xml: _Element) -&gt; \"CollisionLink\":\n        \"\"\"\n        Create a collision link from an XML element.\n\n        Args:\n            xml: The XML element to create the collision link from.\n\n        Returns:\n            The collision link created from the XML element.\n\n        Examples:\n            &gt;&gt;&gt; xml = ET.Element('collision')\n            &gt;&gt;&gt; CollisionLink.from_xml(xml)\n            CollisionLink(name='collision', origin=None, geometry=None)\n        \"\"\"\n        name = xml.get(\"name\")\n\n        origin_element = xml.find(\"origin\")\n        geometry_element = xml.find(\"geometry\")\n\n        if origin_element is None or geometry_element is None:\n            raise ValueError(\"CollisionLink requires origin and geometry elements\")\n\n        origin = Origin.from_xml(origin_element)\n        geometry = set_geometry_from_xml(geometry_element)\n\n        if geometry is None:\n            raise ValueError(\"Failed to parse geometry element\")\n\n        return cls(name=name, origin=origin, geometry=geometry)\n</code></pre>"},{"location":"api/link/#onshape_robotics_toolkit.models.link.CollisionLink.from_xml","title":"<code>from_xml(xml)</code>  <code>classmethod</code>","text":"<p>Create a collision link from an XML element.</p> <p>Parameters:</p> Name Type Description Default <code>xml</code> <code>_Element</code> <p>The XML element to create the collision link from.</p> required <p>Returns:</p> Type Description <code>CollisionLink</code> <p>The collision link created from the XML element.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; xml = ET.Element('collision')\n&gt;&gt;&gt; CollisionLink.from_xml(xml)\nCollisionLink(name='collision', origin=None, geometry=None)\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/link.py</code> <pre><code>@classmethod\ndef from_xml(cls, xml: _Element) -&gt; \"CollisionLink\":\n    \"\"\"\n    Create a collision link from an XML element.\n\n    Args:\n        xml: The XML element to create the collision link from.\n\n    Returns:\n        The collision link created from the XML element.\n\n    Examples:\n        &gt;&gt;&gt; xml = ET.Element('collision')\n        &gt;&gt;&gt; CollisionLink.from_xml(xml)\n        CollisionLink(name='collision', origin=None, geometry=None)\n    \"\"\"\n    name = xml.get(\"name\")\n\n    origin_element = xml.find(\"origin\")\n    geometry_element = xml.find(\"geometry\")\n\n    if origin_element is None or geometry_element is None:\n        raise ValueError(\"CollisionLink requires origin and geometry elements\")\n\n    origin = Origin.from_xml(origin_element)\n    geometry = set_geometry_from_xml(geometry_element)\n\n    if geometry is None:\n        raise ValueError(\"Failed to parse geometry element\")\n\n    return cls(name=name, origin=origin, geometry=geometry)\n</code></pre>"},{"location":"api/link/#onshape_robotics_toolkit.models.link.CollisionLink.to_mjcf","title":"<code>to_mjcf(root)</code>","text":"<p>Convert the collision properties to an MuJoCo compatible XML element.</p> <p>Example XML: <pre><code>      &lt;geom name=\"Assembly-2-1-SUB-Part-5-1-collision\"\n            pos=\"0.0994445 -0.000366963 0.0171076\"\n            quat=\"-0.92388 -4.28774e-08 0.382683 0\"\n            type=\"mesh\"\n            rgba=\"1 0.5 0 1\"\n            mesh=\"Assembly-2-1-SUB-Part-5-1\"\n            contype=\"1\"\n            conaffinity=\"0\"\n            density=\"0\"\n            group=\"1\"/&gt;\n</code></pre> Args:     root: The root element to append the collision properties to.</p> <p>Returns:</p> Type Description <code>None</code> <p>The XML element representing the collision properties.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; collision = CollisionLink(origin=Origin(...), geometry=BoxGeometry(...))\n&gt;&gt;&gt; collision.to_mjcf()\n&lt;Element 'collision' at 0x7f8b3c0b4c70&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/link.py</code> <pre><code>def to_mjcf(self, root: _Element) -&gt; None:\n    \"\"\"\n    Convert the collision properties to an MuJoCo compatible XML element.\n\n    Example XML:\n    ```xml\n          &lt;geom name=\"Assembly-2-1-SUB-Part-5-1-collision\"\n                pos=\"0.0994445 -0.000366963 0.0171076\"\n                quat=\"-0.92388 -4.28774e-08 0.382683 0\"\n                type=\"mesh\"\n                rgba=\"1 0.5 0 1\"\n                mesh=\"Assembly-2-1-SUB-Part-5-1\"\n                contype=\"1\"\n                conaffinity=\"0\"\n                density=\"0\"\n                group=\"1\"/&gt;\n    ```\n    Args:\n        root: The root element to append the collision properties to.\n\n    Returns:\n        The XML element representing the collision properties.\n\n    Examples:\n        &gt;&gt;&gt; collision = CollisionLink(origin=Origin(...), geometry=BoxGeometry(...))\n        &gt;&gt;&gt; collision.to_mjcf()\n        &lt;Element 'collision' at 0x7f8b3c0b4c70&gt;\n    \"\"\"\n    collision = root if root.tag == \"geom\" else ET.SubElement(root, \"geom\")\n    if self.name:\n        collision.set(\"name\", self.name)\n    collision.set(\"contype\", \"1\")\n    collision.set(\"conaffinity\", \"1\")\n    self.origin.to_mjcf(collision)\n\n    if self.geometry:\n        self.geometry.to_mjcf(collision)\n\n    collision.set(\"group\", \"0\")\n\n    if self.friction:\n        collision.set(\"friction\", \" \".join(format_number(v) for v in self.friction))\n</code></pre>"},{"location":"api/link/#onshape_robotics_toolkit.models.link.CollisionLink.to_xml","title":"<code>to_xml(root=None)</code>","text":"<p>Convert the collision properties to an XML element.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>Optional[_Element]</code> <p>The root element to append the collision properties to.</p> <code>None</code> <p>Returns:</p> Type Description <code>_Element</code> <p>The XML element representing the collision properties.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; collision = CollisionLink(origin=Origin(...), geometry=BoxGeometry(...))\n&gt;&gt;&gt; collision.to_xml()\n&lt;Element 'collision' at 0x7f8b3c0b4c70&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/link.py</code> <pre><code>def to_xml(self, root: Optional[_Element] = None) -&gt; _Element:\n    \"\"\"\n    Convert the collision properties to an XML element.\n\n    Args:\n        root: The root element to append the collision properties to.\n\n    Returns:\n        The XML element representing the collision properties.\n\n    Examples:\n        &gt;&gt;&gt; collision = CollisionLink(origin=Origin(...), geometry=BoxGeometry(...))\n        &gt;&gt;&gt; collision.to_xml()\n        &lt;Element 'collision' at 0x7f8b3c0b4c70&gt;\n    \"\"\"\n    collision: _Element = ET.Element(\"collision\") if root is None else ET.SubElement(root, \"collision\")\n    if self.name:\n        collision.set(\"name\", self.name)\n    self.origin.to_xml(collision)\n    self.geometry.to_xml(collision)\n    return collision\n</code></pre>"},{"location":"api/link/#onshape_robotics_toolkit.models.link.CollisionLink.transform","title":"<code>transform(transformation_matrix)</code>","text":"<p>Apply a transformation to the visual link's origin.</p> <p>Parameters:</p> Name Type Description Default <code>transformation_matrix</code> <code>ndarray</code> <p>A 4x4 transformation matrix (homogeneous).</p> required Source code in <code>onshape_robotics_toolkit/models/link.py</code> <pre><code>def transform(self, transformation_matrix: np.ndarray) -&gt; None:\n    \"\"\"\n    Apply a transformation to the visual link's origin.\n\n    Args:\n        transformation_matrix (np.ndarray): A 4x4 transformation matrix (homogeneous).\n    \"\"\"\n    # Apply translation and rotation to the origin position\n    pos = np.array([self.origin.xyz[0], self.origin.xyz[1], self.origin.xyz[2], 1])\n    new_pos = transformation_matrix @ pos\n    self.origin.xyz = (float(new_pos[0]), float(new_pos[1]), float(new_pos[2]))  # Update position\n\n    # Extract the rotation from the transformation matrix\n    rotation_matrix = transformation_matrix[:3, :3]\n    current_rotation = R.from_euler(\"xyz\", self.origin.rpy)\n    new_rotation = R.from_matrix(rotation_matrix @ current_rotation.as_matrix())\n    euler_angles = new_rotation.as_euler(\"xyz\")\n    self.origin.rpy = (float(euler_angles[0]), float(euler_angles[1]), float(euler_angles[2]))\n</code></pre>"},{"location":"api/link/#onshape_robotics_toolkit.models.link.Colors","title":"<code>Colors</code>","text":"<p>               Bases: <code>tuple[float, float, float, float]</code>, <code>Enum</code></p> <p>Enumerates the possible colors in RGBA format for a link in the robot model.</p> <p>Each color is represented as a tuple of four float values (r, g, b, a), where each component ranges from 0.0 to 1.0.</p> <p>Attributes:</p> Name Type Description <code>RED</code> <code>tuple[float, float, float, float]</code> <p>Color red (1, 0, 0, 1).</p> <code>GREEN</code> <code>tuple[float, float, float, float]</code> <p>Color green (0, 1, 0, 1).</p> <code>BLUE</code> <code>tuple[float, float, float, float]</code> <p>Color blue (0, 0, 1, 1).</p> <code>YELLOW</code> <code>tuple[float, float, float, float]</code> <p>Color yellow (1, 1, 0, 1).</p> <code>CYAN</code> <code>tuple[float, float, float, float]</code> <p>Color cyan (0, 1, 1, 1).</p> <code>MAGENTA</code> <code>tuple[float, float, float, float]</code> <p>Color magenta (1, 0, 1, 1).</p> <code>WHITE</code> <code>tuple[float, float, float, float]</code> <p>Color white (1, 1, 1, 1).</p> <code>BLACK</code> <code>tuple[float, float, float, float]</code> <p>Color black (0, 0, 0, 1).</p> <code>ORANGE</code> <code>tuple[float, float, float, float]</code> <p>Color orange (1, 0.5, 0, 1).</p> <code>PINK</code> <code>tuple[float, float, float, float]</code> <p>Color pink (1, 0, 0.5, 1).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Colors.RED\n&lt;Colors.RED: (1.0, 0.0, 0.0, 1.0)&gt;\n&gt;&gt;&gt; Colors.BLUE.value\n(0.0, 0.0, 1.0, 1.0)\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/link.py</code> <pre><code>class Colors(tuple[float, float, float, float], Enum):\n    \"\"\"\n    Enumerates the possible colors in RGBA format for a link in the robot model.\n\n    Each color is represented as a tuple of four float values (r, g, b, a),\n    where each component ranges from 0.0 to 1.0.\n\n    Attributes:\n        RED (tuple[float, float, float, float]): Color red (1, 0, 0, 1).\n        GREEN (tuple[float, float, float, float]): Color green (0, 1, 0, 1).\n        BLUE (tuple[float, float, float, float]): Color blue (0, 0, 1, 1).\n        YELLOW (tuple[float, float, float, float]): Color yellow (1, 1, 0, 1).\n        CYAN (tuple[float, float, float, float]): Color cyan (0, 1, 1, 1).\n        MAGENTA (tuple[float, float, float, float]): Color magenta (1, 0, 1, 1).\n        WHITE (tuple[float, float, float, float]): Color white (1, 1, 1, 1).\n        BLACK (tuple[float, float, float, float]): Color black (0, 0, 0, 1).\n        ORANGE (tuple[float, float, float, float]): Color orange (1, 0.5, 0, 1).\n        PINK (tuple[float, float, float, float]): Color pink (1, 0, 0.5, 1).\n\n    Examples:\n        &gt;&gt;&gt; Colors.RED\n        &lt;Colors.RED: (1.0, 0.0, 0.0, 1.0)&gt;\n        &gt;&gt;&gt; Colors.BLUE.value\n        (0.0, 0.0, 1.0, 1.0)\n    \"\"\"\n\n    RED = (1.0, 0.0, 0.0, 1.0)\n    GREEN = (0.0, 1.0, 0.0, 1.0)\n    BLUE = (0.0, 0.0, 1.0, 1.0)\n    YELLOW = (1.0, 1.0, 0.0, 1.0)\n    CYAN = (0.0, 1.0, 1.0, 1.0)\n    MAGENTA = (1.0, 0.0, 1.0, 1.0)\n    WHITE = (1.0, 1.0, 1.0, 1.0)\n    BLACK = (0.0, 0.0, 0.0, 1.0)\n    ORANGE = (1.0, 0.5, 0.0, 1.0)\n    PINK = (1.0, 0.0, 0.5, 1.0)\n</code></pre>"},{"location":"api/link/#onshape_robotics_toolkit.models.link.Inertia","title":"<code>Inertia</code>  <code>dataclass</code>","text":"<p>Represents the inertia tensor of a link in the robot model.</p> <p>The inertia tensor is a 3x3 symmetric matrix that describes how the body's mass is distributed relative to its center of mass.</p> <p>Attributes:</p> Name Type Description <code>ixx</code> <code>float</code> <p>Moment of inertia about the x-axis.</p> <code>iyy</code> <code>float</code> <p>Moment of inertia about the y-axis.</p> <code>izz</code> <code>float</code> <p>Moment of inertia about the z-axis.</p> <code>ixy</code> <code>float</code> <p>Product of inertia about the xy-plane.</p> <code>ixz</code> <code>float</code> <p>Product of inertia about the xz-plane.</p> <code>iyz</code> <code>float</code> <p>Product of inertia about the yz-plane.</p> <p>Methods:</p> Name Description <code>to_xml</code> <p>Converts the inertia tensor to an XML element.</p> <code>to_mjcf</code> <p>Converts the inertia tensor to a MuJoCo compatible XML element.</p> <code>to_matrix</code> <p>Returns the inertia tensor as a 3x3 numpy array.</p> Class Methods <p>from_xml: Creates an inertia tensor from an XML element. zero_inertia: Creates an inertia tensor with all zero values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; inertia = Inertia(ixx=1.0, iyy=1.0, izz=1.0, ixy=0.0, ixz=0.0, iyz=0.0)\n&gt;&gt;&gt; inertia.to_matrix\narray([[1., 0., 0.],\n       [0., 1., 0.],\n       [0., 0., 1.]])\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/link.py</code> <pre><code>@dataclass\nclass Inertia:\n    \"\"\"\n    Represents the inertia tensor of a link in the robot model.\n\n    The inertia tensor is a 3x3 symmetric matrix that describes how the body's mass\n    is distributed relative to its center of mass.\n\n    Attributes:\n        ixx (float): Moment of inertia about the x-axis.\n        iyy (float): Moment of inertia about the y-axis.\n        izz (float): Moment of inertia about the z-axis.\n        ixy (float): Product of inertia about the xy-plane.\n        ixz (float): Product of inertia about the xz-plane.\n        iyz (float): Product of inertia about the yz-plane.\n\n    Methods:\n        to_xml: Converts the inertia tensor to an XML element.\n        to_mjcf: Converts the inertia tensor to a MuJoCo compatible XML element.\n        to_matrix: Returns the inertia tensor as a 3x3 numpy array.\n\n    Class Methods:\n        from_xml: Creates an inertia tensor from an XML element.\n        zero_inertia: Creates an inertia tensor with all zero values.\n\n    Examples:\n        &gt;&gt;&gt; inertia = Inertia(ixx=1.0, iyy=1.0, izz=1.0, ixy=0.0, ixz=0.0, iyz=0.0)\n        &gt;&gt;&gt; inertia.to_matrix\n        array([[1., 0., 0.],\n               [0., 1., 0.],\n               [0., 0., 1.]])\n    \"\"\"\n\n    ixx: float\n    iyy: float\n    izz: float\n    ixy: float\n    ixz: float\n    iyz: float\n\n    def to_xml(self, root: Optional[_Element] = None) -&gt; _Element:\n        \"\"\"\n        Convert the inertia tensor to an XML element.\n\n        Args:\n            root: The root element to append the inertia tensor to.\n\n        Returns:\n            The XML element representing the inertia tensor.\n\n        Examples:\n            &gt;&gt;&gt; inertia = Inertia(ixx=1.0, iyy=2.0, izz=3.0, ixy=0.0, ixz=0.0, iyz=0.0)\n            &gt;&gt;&gt; inertia.to_xml()\n            &lt;Element 'inertia' at 0x7f8b3c0b4c70&gt;\n        \"\"\"\n\n        inertia: _Element = ET.Element(\"inertia\") if root is None else ET.SubElement(root, \"inertia\")\n        inertia.set(\"ixx\", format_number(self.ixx))\n        inertia.set(\"iyy\", format_number(self.iyy))\n        inertia.set(\"izz\", format_number(self.izz))\n        inertia.set(\"ixy\", format_number(self.ixy))\n        inertia.set(\"ixz\", format_number(self.ixz))\n        inertia.set(\"iyz\", format_number(self.iyz))\n        return inertia\n\n    def to_mjcf(self, root: _Element) -&gt; None:\n        \"\"\"\n        Convert the inertia tensor to an MuJoCo compatible XML element.\n\n        Args:\n            root: The root element to append the inertia tensor to.\n\n        Returns:\n            The XML element representing the inertia tensor.\n\n        Examples:\n            &gt;&gt;&gt; inertia = Inertia(ixx=1.0, iyy=2.0, izz=3.0, ixy=0.0, ixz=0.0, iyz=0.0)\n            &gt;&gt;&gt; inertia.to_mjcf()\n            &lt;Element 'inertia' at 0x7f8b3c0b4c70&gt;\n        \"\"\"\n        inertial = root if root.tag == \"inertial\" else ET.SubElement(root, \"inertial\")\n        inertial.set(\"diaginertia\", \" \".join(format_number(v) for v in [self.ixx, self.iyy, self.izz]))\n\n    @classmethod\n    def from_xml(cls, xml: _Element) -&gt; \"Inertia\":\n        \"\"\"\n        Create an inertia tensor from an XML element.\n\n        Args:\n            xml: The XML element to create the inertia tensor from.\n\n        Returns:\n            The inertia tensor created from the XML element.\n\n        Examples:\n            &gt;&gt;&gt; xml = ET.Element('inertia')\n            &gt;&gt;&gt; Inertia.from_xml(xml)\n            Inertia(ixx=0.0, iyy=0.0, izz=0.0, ixy=0.0, ixz=0.0, iyz=0.0)\n        \"\"\"\n        ixx = float(xml.get(\"ixx\", \"0.0\"))\n        iyy = float(xml.get(\"iyy\", \"0.0\"))\n        izz = float(xml.get(\"izz\", \"0.0\"))\n        ixy = float(xml.get(\"ixy\", \"0.0\"))\n        ixz = float(xml.get(\"ixz\", \"0.0\"))\n        iyz = float(xml.get(\"iyz\", \"0.0\"))\n        return cls(ixx, iyy, izz, ixy, ixz, iyz)\n\n    @classmethod\n    def zero_inertia(cls) -&gt; \"Inertia\":\n        \"\"\"\n        Create an inertia tensor with zero values.\n\n        Returns:\n            The inertia tensor with zero values.\n\n        Examples:\n            &gt;&gt;&gt; Inertia.zero_inertia()\n            Inertia(ixx=0.0, iyy=0.0, izz=0.0, ixy=0.0, ixz=0.0, iyz=0.0)\n        \"\"\"\n        return cls(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)\n\n    @property\n    def to_matrix(self) -&gt; np.ndarray:\n        \"\"\"\n        Returns the inertia tensor as a 3x3 numpy array.\n\n        Returns:\n            The inertia tensor as a 3x3 numpy array.\n        \"\"\"\n        return np.array([\n            [self.ixx, self.ixy, self.ixz],\n            [self.ixy, self.iyy, self.iyz],\n            [self.ixz, self.iyz, self.izz],\n        ])\n</code></pre>"},{"location":"api/link/#onshape_robotics_toolkit.models.link.Inertia.to_matrix","title":"<code>to_matrix</code>  <code>property</code>","text":"<p>Returns the inertia tensor as a 3x3 numpy array.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>The inertia tensor as a 3x3 numpy array.</p>"},{"location":"api/link/#onshape_robotics_toolkit.models.link.Inertia.from_xml","title":"<code>from_xml(xml)</code>  <code>classmethod</code>","text":"<p>Create an inertia tensor from an XML element.</p> <p>Parameters:</p> Name Type Description Default <code>xml</code> <code>_Element</code> <p>The XML element to create the inertia tensor from.</p> required <p>Returns:</p> Type Description <code>Inertia</code> <p>The inertia tensor created from the XML element.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; xml = ET.Element('inertia')\n&gt;&gt;&gt; Inertia.from_xml(xml)\nInertia(ixx=0.0, iyy=0.0, izz=0.0, ixy=0.0, ixz=0.0, iyz=0.0)\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/link.py</code> <pre><code>@classmethod\ndef from_xml(cls, xml: _Element) -&gt; \"Inertia\":\n    \"\"\"\n    Create an inertia tensor from an XML element.\n\n    Args:\n        xml: The XML element to create the inertia tensor from.\n\n    Returns:\n        The inertia tensor created from the XML element.\n\n    Examples:\n        &gt;&gt;&gt; xml = ET.Element('inertia')\n        &gt;&gt;&gt; Inertia.from_xml(xml)\n        Inertia(ixx=0.0, iyy=0.0, izz=0.0, ixy=0.0, ixz=0.0, iyz=0.0)\n    \"\"\"\n    ixx = float(xml.get(\"ixx\", \"0.0\"))\n    iyy = float(xml.get(\"iyy\", \"0.0\"))\n    izz = float(xml.get(\"izz\", \"0.0\"))\n    ixy = float(xml.get(\"ixy\", \"0.0\"))\n    ixz = float(xml.get(\"ixz\", \"0.0\"))\n    iyz = float(xml.get(\"iyz\", \"0.0\"))\n    return cls(ixx, iyy, izz, ixy, ixz, iyz)\n</code></pre>"},{"location":"api/link/#onshape_robotics_toolkit.models.link.Inertia.to_mjcf","title":"<code>to_mjcf(root)</code>","text":"<p>Convert the inertia tensor to an MuJoCo compatible XML element.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>_Element</code> <p>The root element to append the inertia tensor to.</p> required <p>Returns:</p> Type Description <code>None</code> <p>The XML element representing the inertia tensor.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; inertia = Inertia(ixx=1.0, iyy=2.0, izz=3.0, ixy=0.0, ixz=0.0, iyz=0.0)\n&gt;&gt;&gt; inertia.to_mjcf()\n&lt;Element 'inertia' at 0x7f8b3c0b4c70&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/link.py</code> <pre><code>def to_mjcf(self, root: _Element) -&gt; None:\n    \"\"\"\n    Convert the inertia tensor to an MuJoCo compatible XML element.\n\n    Args:\n        root: The root element to append the inertia tensor to.\n\n    Returns:\n        The XML element representing the inertia tensor.\n\n    Examples:\n        &gt;&gt;&gt; inertia = Inertia(ixx=1.0, iyy=2.0, izz=3.0, ixy=0.0, ixz=0.0, iyz=0.0)\n        &gt;&gt;&gt; inertia.to_mjcf()\n        &lt;Element 'inertia' at 0x7f8b3c0b4c70&gt;\n    \"\"\"\n    inertial = root if root.tag == \"inertial\" else ET.SubElement(root, \"inertial\")\n    inertial.set(\"diaginertia\", \" \".join(format_number(v) for v in [self.ixx, self.iyy, self.izz]))\n</code></pre>"},{"location":"api/link/#onshape_robotics_toolkit.models.link.Inertia.to_xml","title":"<code>to_xml(root=None)</code>","text":"<p>Convert the inertia tensor to an XML element.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>Optional[_Element]</code> <p>The root element to append the inertia tensor to.</p> <code>None</code> <p>Returns:</p> Type Description <code>_Element</code> <p>The XML element representing the inertia tensor.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; inertia = Inertia(ixx=1.0, iyy=2.0, izz=3.0, ixy=0.0, ixz=0.0, iyz=0.0)\n&gt;&gt;&gt; inertia.to_xml()\n&lt;Element 'inertia' at 0x7f8b3c0b4c70&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/link.py</code> <pre><code>def to_xml(self, root: Optional[_Element] = None) -&gt; _Element:\n    \"\"\"\n    Convert the inertia tensor to an XML element.\n\n    Args:\n        root: The root element to append the inertia tensor to.\n\n    Returns:\n        The XML element representing the inertia tensor.\n\n    Examples:\n        &gt;&gt;&gt; inertia = Inertia(ixx=1.0, iyy=2.0, izz=3.0, ixy=0.0, ixz=0.0, iyz=0.0)\n        &gt;&gt;&gt; inertia.to_xml()\n        &lt;Element 'inertia' at 0x7f8b3c0b4c70&gt;\n    \"\"\"\n\n    inertia: _Element = ET.Element(\"inertia\") if root is None else ET.SubElement(root, \"inertia\")\n    inertia.set(\"ixx\", format_number(self.ixx))\n    inertia.set(\"iyy\", format_number(self.iyy))\n    inertia.set(\"izz\", format_number(self.izz))\n    inertia.set(\"ixy\", format_number(self.ixy))\n    inertia.set(\"ixz\", format_number(self.ixz))\n    inertia.set(\"iyz\", format_number(self.iyz))\n    return inertia\n</code></pre>"},{"location":"api/link/#onshape_robotics_toolkit.models.link.Inertia.zero_inertia","title":"<code>zero_inertia()</code>  <code>classmethod</code>","text":"<p>Create an inertia tensor with zero values.</p> <p>Returns:</p> Type Description <code>Inertia</code> <p>The inertia tensor with zero values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Inertia.zero_inertia()\nInertia(ixx=0.0, iyy=0.0, izz=0.0, ixy=0.0, ixz=0.0, iyz=0.0)\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/link.py</code> <pre><code>@classmethod\ndef zero_inertia(cls) -&gt; \"Inertia\":\n    \"\"\"\n    Create an inertia tensor with zero values.\n\n    Returns:\n        The inertia tensor with zero values.\n\n    Examples:\n        &gt;&gt;&gt; Inertia.zero_inertia()\n        Inertia(ixx=0.0, iyy=0.0, izz=0.0, ixy=0.0, ixz=0.0, iyz=0.0)\n    \"\"\"\n    return cls(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)\n</code></pre>"},{"location":"api/link/#onshape_robotics_toolkit.models.link.InertialLink","title":"<code>InertialLink</code>  <code>dataclass</code>","text":"<p>Represents the inertial properties of a link in the robot model.</p> <p>This class combines mass, center of mass (via origin), and inertia tensor properties to fully describe a link's inertial characteristics.</p> <p>Attributes:</p> Name Type Description <code>mass</code> <code>float</code> <p>The mass of the link in kilograms.</p> <code>inertia</code> <code>Inertia</code> <p>The inertia tensor of the link.</p> <code>origin</code> <code>Origin</code> <p>The center of mass position and orientation.</p> <p>Methods:</p> Name Description <code>to_xml</code> <p>Converts the inertial properties to an XML element.</p> <code>to_mjcf</code> <p>Converts the inertial properties to a MuJoCo compatible XML element.</p> <code>transform</code> <p>Applies a transformation matrix to the inertial properties.</p> Class Methods <p>from_xml: Creates an InertialLink from an XML element.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; inertial = InertialLink(\n...     mass=1.0,\n...     inertia=Inertia(1.0, 1.0, 1.0, 0.0, 0.0, 0.0),\n...     origin=Origin.zero_origin()\n... )\n&gt;&gt;&gt; inertial.to_xml()\n&lt;Element 'inertial' at 0x...&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/link.py</code> <pre><code>@dataclass\nclass InertialLink:\n    \"\"\"\n    Represents the inertial properties of a link in the robot model.\n\n    This class combines mass, center of mass (via origin), and inertia tensor\n    properties to fully describe a link's inertial characteristics.\n\n    Attributes:\n        mass (float): The mass of the link in kilograms.\n        inertia (Inertia): The inertia tensor of the link.\n        origin (Origin): The center of mass position and orientation.\n\n    Methods:\n        to_xml: Converts the inertial properties to an XML element.\n        to_mjcf: Converts the inertial properties to a MuJoCo compatible XML element.\n        transform: Applies a transformation matrix to the inertial properties.\n\n    Class Methods:\n        from_xml: Creates an InertialLink from an XML element.\n\n    Examples:\n        &gt;&gt;&gt; inertial = InertialLink(\n        ...     mass=1.0,\n        ...     inertia=Inertia(1.0, 1.0, 1.0, 0.0, 0.0, 0.0),\n        ...     origin=Origin.zero_origin()\n        ... )\n        &gt;&gt;&gt; inertial.to_xml()\n        &lt;Element 'inertial' at 0x...&gt;\n    \"\"\"\n\n    mass: float\n    inertia: Inertia\n    origin: Origin\n\n    def to_xml(self, root: Optional[_Element] = None) -&gt; _Element:\n        \"\"\"\n        Convert the inertial properties to an XML element.\n\n        Args:\n            root: The root element to append the inertial properties to.\n\n        Returns:\n            The XML element representing the inertial properties.\n\n        Examples:\n            &gt;&gt;&gt; inertial = InertialLink(\n            ...     mass=1.0,\n            ...     inertia=Inertia(1.0, 1.0, 1.0, 0.0, 0.0, 0.0),\n            ...     origin=Origin.zero_origin()\n            ... )\n            &gt;&gt;&gt; inertial.to_xml()\n            &lt;Element 'inertial' at 0x...&gt;\n        \"\"\"\n        inertial: _Element = ET.Element(\"inertial\") if root is None else ET.SubElement(root, \"inertial\")\n        ET.SubElement(inertial, \"mass\", value=format_number(self.mass))\n        self.inertia.to_xml(inertial)\n        self.origin.to_xml(inertial)\n        return inertial\n\n    def to_mjcf(self, root: _Element) -&gt; None:\n        \"\"\"\n        Convert the inertial properties to an MuJoCo compatible XML element.\n\n        Example XML:\n        ```xml\n        &lt;inertial pos=\"0 0 -0.0075\" euler=\"0.5 0.5 -0.5\" mass=\"0.624\"\n                  diaginertia=\"0.073541512 0.07356916 0.073543931\" /&gt;\n        ```\n        Args:\n            root: The root element to append the inertial properties to.\n        \"\"\"\n        inertial = root if root.tag == \"inertial\" else ET.SubElement(root, \"inertial\")\n        inertial.set(\"mass\", format_number(self.mass))\n        self.origin.to_mjcf(inertial)\n        self.inertia.to_mjcf(inertial)\n\n    def transform(self, tf_matrix: np.matrix, inplace: bool = False) -&gt; Union[\"InertialLink\", None]:\n        \"\"\"\n        Apply a transformation matrix to the Inertial Properties of the a link.\n\n        Args:\n            tf_matrix: The transformation matrix to apply to the origin.\n            inplace: Whether to apply the transformation in place.\n\n        Returns:\n            An updated Inertial Link with the transformation applied to both:\n            * the inertia tensor (giving a transformed \"inertia tensor prime\" = [ixx', iyy', izz', ixy', ixz', iyz'])\n            * AND to the origin too (via the Origin class's transform logic [~line 100])\n\n        Examples {@}:\n            &gt;&gt;&gt; origin = Origin(xyz=(1.0, 2.0, 3.0), rpy=(0.0, 0.0, 0.0))\n            &gt;&gt;&gt; matrix = np.eye(4)\n            &gt;&gt;&gt; inertial.transform(matrix)\n\n        Analysis and References:\n            The essence is to convert the Inertia tensor to a matrix and then transform the matrix via the equation\n            I_prime = R\u00b7I\u00b7Transpose[R] + m(||d||^2\u00b7I - d\u00b7Transpose[d])\n            Then we put the components into the resultant Inertial Link\n            An analysis (on 100k runs) suggests that this is 3 x faster than a direct approach on the tensor elements\n            likely because numpy's libraries are optimized for matrix operations.\n            (https://chatgpt.com/share/6781b6ac-772c-8006-b1a9-7f2dc3e3ef4d)\n            Ref: https://chatgpt.com/share/6781b6ac-772c-8006-b1a9-7f2dc3e3ef4d\n        \"\"\"\n\n        R = tf_matrix[:3, :3]  # Top-left 3x3 block is the rotation matrix\n        p = tf_matrix[:3, 3]  # Top-right 3x1 block is the translation vector\n\n        inertia_matrix = self.inertia.to_matrix\n        I_rot = R @ inertia_matrix @ R.T\n\n        # Compute the parallel axis theorem adjustment\n        parallel_axis_adjustment = self.mass * (np.dot(p, p) * np.eye(3) - np.outer(p, p))\n\n        # Final transformed inertia matrix\n        I_transformed = I_rot + parallel_axis_adjustment\n\n        ixx_prime = I_transformed[0, 0]\n        iyy_prime = I_transformed[1, 1]\n        izz_prime = I_transformed[2, 2]\n        ixy_prime = I_transformed[0, 1]\n        ixz_prime = I_transformed[0, 2]\n        iyz_prime = I_transformed[1, 2]\n\n        # Transform the Origin (Don't replace the original in case the user keeps the inplace flag false)\n        Origin_prime = self.origin.transform(tf_matrix, inplace=False)\n        if Origin_prime is None:\n            raise RuntimeError(\"Origin transformation failed when inplace=False\")\n\n        # Update values and (if requested) put the extracted values into a new_InertialLink\n        if inplace:\n            # mass stays the same :-) ==&gt; self.mass = new_InertialLink.mass\n            self.inertia.ixx = ixx_prime\n            self.inertia.iyy = iyy_prime\n            self.inertia.izz = izz_prime\n            self.inertia.ixy = ixy_prime\n            self.inertia.ixz = ixz_prime\n            self.inertia.iyz = iyz_prime\n            self.origin = Origin_prime\n            return None\n        else:\n            new_InertialLink = InertialLink(\n                mass=self.mass,\n                inertia=Inertia(ixx_prime, iyy_prime, izz_prime, ixy_prime, ixz_prime, iyz_prime),\n                origin=Origin_prime,\n            )\n            return new_InertialLink\n\n    @classmethod\n    def from_xml(cls, xml: _Element) -&gt; \"InertialLink\":\n        \"\"\"\n        Create inertial properties from an XML element.\n\n        Args:\n            xml: The XML element to create the inertial properties from.\n\n        Returns:\n            The inertial properties created from the XML element.\n\n        Examples:\n            &gt;&gt;&gt; xml = ET.Element('inertial')\n            &gt;&gt;&gt; InertialLink.from_xml(xml)\n            InertialLink(mass=0.0, inertia=None, origin=None)\n        \"\"\"\n        mass_element = xml.find(\"mass\")\n        if mass_element is None:\n            raise ValueError(\"Missing mass element in inertial XML\")\n\n        mass_value = mass_element.get(\"value\")\n        if mass_value is None:\n            raise ValueError(\"Missing value attribute in mass element\")\n\n        mass = float(mass_value)\n\n        inertia_element = xml.find(\"inertia\")\n        inertia = Inertia.from_xml(inertia_element) if inertia_element is not None else Inertia.zero_inertia()\n\n        origin_element = xml.find(\"origin\")\n        origin = Origin.from_xml(origin_element) if origin_element is not None else Origin.zero_origin()\n\n        return cls(mass=mass, inertia=inertia, origin=origin)\n</code></pre>"},{"location":"api/link/#onshape_robotics_toolkit.models.link.InertialLink.from_xml","title":"<code>from_xml(xml)</code>  <code>classmethod</code>","text":"<p>Create inertial properties from an XML element.</p> <p>Parameters:</p> Name Type Description Default <code>xml</code> <code>_Element</code> <p>The XML element to create the inertial properties from.</p> required <p>Returns:</p> Type Description <code>InertialLink</code> <p>The inertial properties created from the XML element.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; xml = ET.Element('inertial')\n&gt;&gt;&gt; InertialLink.from_xml(xml)\nInertialLink(mass=0.0, inertia=None, origin=None)\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/link.py</code> <pre><code>@classmethod\ndef from_xml(cls, xml: _Element) -&gt; \"InertialLink\":\n    \"\"\"\n    Create inertial properties from an XML element.\n\n    Args:\n        xml: The XML element to create the inertial properties from.\n\n    Returns:\n        The inertial properties created from the XML element.\n\n    Examples:\n        &gt;&gt;&gt; xml = ET.Element('inertial')\n        &gt;&gt;&gt; InertialLink.from_xml(xml)\n        InertialLink(mass=0.0, inertia=None, origin=None)\n    \"\"\"\n    mass_element = xml.find(\"mass\")\n    if mass_element is None:\n        raise ValueError(\"Missing mass element in inertial XML\")\n\n    mass_value = mass_element.get(\"value\")\n    if mass_value is None:\n        raise ValueError(\"Missing value attribute in mass element\")\n\n    mass = float(mass_value)\n\n    inertia_element = xml.find(\"inertia\")\n    inertia = Inertia.from_xml(inertia_element) if inertia_element is not None else Inertia.zero_inertia()\n\n    origin_element = xml.find(\"origin\")\n    origin = Origin.from_xml(origin_element) if origin_element is not None else Origin.zero_origin()\n\n    return cls(mass=mass, inertia=inertia, origin=origin)\n</code></pre>"},{"location":"api/link/#onshape_robotics_toolkit.models.link.InertialLink.to_mjcf","title":"<code>to_mjcf(root)</code>","text":"<p>Convert the inertial properties to an MuJoCo compatible XML element.</p> <p>Example XML: <pre><code>&lt;inertial pos=\"0 0 -0.0075\" euler=\"0.5 0.5 -0.5\" mass=\"0.624\"\n          diaginertia=\"0.073541512 0.07356916 0.073543931\" /&gt;\n</code></pre> Args:     root: The root element to append the inertial properties to.</p> Source code in <code>onshape_robotics_toolkit/models/link.py</code> <pre><code>def to_mjcf(self, root: _Element) -&gt; None:\n    \"\"\"\n    Convert the inertial properties to an MuJoCo compatible XML element.\n\n    Example XML:\n    ```xml\n    &lt;inertial pos=\"0 0 -0.0075\" euler=\"0.5 0.5 -0.5\" mass=\"0.624\"\n              diaginertia=\"0.073541512 0.07356916 0.073543931\" /&gt;\n    ```\n    Args:\n        root: The root element to append the inertial properties to.\n    \"\"\"\n    inertial = root if root.tag == \"inertial\" else ET.SubElement(root, \"inertial\")\n    inertial.set(\"mass\", format_number(self.mass))\n    self.origin.to_mjcf(inertial)\n    self.inertia.to_mjcf(inertial)\n</code></pre>"},{"location":"api/link/#onshape_robotics_toolkit.models.link.InertialLink.to_xml","title":"<code>to_xml(root=None)</code>","text":"<p>Convert the inertial properties to an XML element.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>Optional[_Element]</code> <p>The root element to append the inertial properties to.</p> <code>None</code> <p>Returns:</p> Type Description <code>_Element</code> <p>The XML element representing the inertial properties.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; inertial = InertialLink(\n...     mass=1.0,\n...     inertia=Inertia(1.0, 1.0, 1.0, 0.0, 0.0, 0.0),\n...     origin=Origin.zero_origin()\n... )\n&gt;&gt;&gt; inertial.to_xml()\n&lt;Element 'inertial' at 0x...&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/link.py</code> <pre><code>def to_xml(self, root: Optional[_Element] = None) -&gt; _Element:\n    \"\"\"\n    Convert the inertial properties to an XML element.\n\n    Args:\n        root: The root element to append the inertial properties to.\n\n    Returns:\n        The XML element representing the inertial properties.\n\n    Examples:\n        &gt;&gt;&gt; inertial = InertialLink(\n        ...     mass=1.0,\n        ...     inertia=Inertia(1.0, 1.0, 1.0, 0.0, 0.0, 0.0),\n        ...     origin=Origin.zero_origin()\n        ... )\n        &gt;&gt;&gt; inertial.to_xml()\n        &lt;Element 'inertial' at 0x...&gt;\n    \"\"\"\n    inertial: _Element = ET.Element(\"inertial\") if root is None else ET.SubElement(root, \"inertial\")\n    ET.SubElement(inertial, \"mass\", value=format_number(self.mass))\n    self.inertia.to_xml(inertial)\n    self.origin.to_xml(inertial)\n    return inertial\n</code></pre>"},{"location":"api/link/#onshape_robotics_toolkit.models.link.InertialLink.transform","title":"<code>transform(tf_matrix, inplace=False)</code>","text":"<p>Apply a transformation matrix to the Inertial Properties of the a link.</p> <p>Parameters:</p> Name Type Description Default <code>tf_matrix</code> <code>matrix</code> <p>The transformation matrix to apply to the origin.</p> required <code>inplace</code> <code>bool</code> <p>Whether to apply the transformation in place.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[InertialLink, None]</code> <p>An updated Inertial Link with the transformation applied to both:</p> <code>Union[InertialLink, None]</code> <ul> <li>the inertia tensor (giving a transformed \"inertia tensor prime\" = [ixx', iyy', izz', ixy', ixz', iyz'])</li> </ul> <code>Union[InertialLink, None]</code> <ul> <li>AND to the origin too (via the Origin class's transform logic [~line 100])</li> </ul> <p>Examples {@}:     &gt;&gt;&gt; origin = Origin(xyz=(1.0, 2.0, 3.0), rpy=(0.0, 0.0, 0.0))     &gt;&gt;&gt; matrix = np.eye(4)     &gt;&gt;&gt; inertial.transform(matrix)</p> Analysis and References <p>The essence is to convert the Inertia tensor to a matrix and then transform the matrix via the equation I_prime = R\u00b7I\u00b7Transpose[R] + m(||d||^2\u00b7I - d\u00b7Transpose[d]) Then we put the components into the resultant Inertial Link An analysis (on 100k runs) suggests that this is 3 x faster than a direct approach on the tensor elements likely because numpy's libraries are optimized for matrix operations. (https://chatgpt.com/share/6781b6ac-772c-8006-b1a9-7f2dc3e3ef4d) Ref: https://chatgpt.com/share/6781b6ac-772c-8006-b1a9-7f2dc3e3ef4d</p> Source code in <code>onshape_robotics_toolkit/models/link.py</code> <pre><code>def transform(self, tf_matrix: np.matrix, inplace: bool = False) -&gt; Union[\"InertialLink\", None]:\n    \"\"\"\n    Apply a transformation matrix to the Inertial Properties of the a link.\n\n    Args:\n        tf_matrix: The transformation matrix to apply to the origin.\n        inplace: Whether to apply the transformation in place.\n\n    Returns:\n        An updated Inertial Link with the transformation applied to both:\n        * the inertia tensor (giving a transformed \"inertia tensor prime\" = [ixx', iyy', izz', ixy', ixz', iyz'])\n        * AND to the origin too (via the Origin class's transform logic [~line 100])\n\n    Examples {@}:\n        &gt;&gt;&gt; origin = Origin(xyz=(1.0, 2.0, 3.0), rpy=(0.0, 0.0, 0.0))\n        &gt;&gt;&gt; matrix = np.eye(4)\n        &gt;&gt;&gt; inertial.transform(matrix)\n\n    Analysis and References:\n        The essence is to convert the Inertia tensor to a matrix and then transform the matrix via the equation\n        I_prime = R\u00b7I\u00b7Transpose[R] + m(||d||^2\u00b7I - d\u00b7Transpose[d])\n        Then we put the components into the resultant Inertial Link\n        An analysis (on 100k runs) suggests that this is 3 x faster than a direct approach on the tensor elements\n        likely because numpy's libraries are optimized for matrix operations.\n        (https://chatgpt.com/share/6781b6ac-772c-8006-b1a9-7f2dc3e3ef4d)\n        Ref: https://chatgpt.com/share/6781b6ac-772c-8006-b1a9-7f2dc3e3ef4d\n    \"\"\"\n\n    R = tf_matrix[:3, :3]  # Top-left 3x3 block is the rotation matrix\n    p = tf_matrix[:3, 3]  # Top-right 3x1 block is the translation vector\n\n    inertia_matrix = self.inertia.to_matrix\n    I_rot = R @ inertia_matrix @ R.T\n\n    # Compute the parallel axis theorem adjustment\n    parallel_axis_adjustment = self.mass * (np.dot(p, p) * np.eye(3) - np.outer(p, p))\n\n    # Final transformed inertia matrix\n    I_transformed = I_rot + parallel_axis_adjustment\n\n    ixx_prime = I_transformed[0, 0]\n    iyy_prime = I_transformed[1, 1]\n    izz_prime = I_transformed[2, 2]\n    ixy_prime = I_transformed[0, 1]\n    ixz_prime = I_transformed[0, 2]\n    iyz_prime = I_transformed[1, 2]\n\n    # Transform the Origin (Don't replace the original in case the user keeps the inplace flag false)\n    Origin_prime = self.origin.transform(tf_matrix, inplace=False)\n    if Origin_prime is None:\n        raise RuntimeError(\"Origin transformation failed when inplace=False\")\n\n    # Update values and (if requested) put the extracted values into a new_InertialLink\n    if inplace:\n        # mass stays the same :-) ==&gt; self.mass = new_InertialLink.mass\n        self.inertia.ixx = ixx_prime\n        self.inertia.iyy = iyy_prime\n        self.inertia.izz = izz_prime\n        self.inertia.ixy = ixy_prime\n        self.inertia.ixz = ixz_prime\n        self.inertia.iyz = iyz_prime\n        self.origin = Origin_prime\n        return None\n    else:\n        new_InertialLink = InertialLink(\n            mass=self.mass,\n            inertia=Inertia(ixx_prime, iyy_prime, izz_prime, ixy_prime, ixz_prime, iyz_prime),\n            origin=Origin_prime,\n        )\n        return new_InertialLink\n</code></pre>"},{"location":"api/link/#onshape_robotics_toolkit.models.link.Link","title":"<code>Link</code>  <code>dataclass</code>","text":"<p>Represents a complete link in the robot model.</p> <p>A link is a rigid body in the robot model that can contain visual, collision, and inertial properties. Links are connected by joints to form the complete robot structure.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The unique identifier for the link.</p> <code>visual</code> <code>VisualLink | None</code> <p>Optional visual properties for rendering.</p> <code>collision</code> <code>CollisionLink | None</code> <p>Optional collision properties for physics simulation.</p> <code>inertial</code> <code>InertialLink | None</code> <p>Optional inertial properties for dynamics.</p> <p>Methods:</p> Name Description <code>to_xml</code> <p>Converts the link to an XML element.</p> <code>to_mjcf</code> <p>Converts the link to a MuJoCo compatible XML element.</p> Class Methods <p>from_xml: Creates a Link from an XML element.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; link = Link(\n...     name=\"base_link\",\n...     visual=VisualLink(...),\n...     collision=CollisionLink(...),\n...     inertial=InertialLink(...)\n... )\n&gt;&gt;&gt; link.to_xml()\n&lt;Element 'link' at 0x...&gt;\n</code></pre> <pre><code>&gt;&gt;&gt; xml_str = '''\n...     &lt;link name=\"base_link\"&gt;\n...         &lt;visual&gt;...&lt;/visual&gt;\n...         &lt;collision&gt;...&lt;/collision&gt;\n...         &lt;inertial&gt;...&lt;/inertial&gt;\n...     &lt;/link&gt;\n... '''\n&gt;&gt;&gt; xml_element = ET.fromstring(xml_str)\n&gt;&gt;&gt; link = Link.from_xml(xml_element)\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/link.py</code> <pre><code>@dataclass\nclass Link:\n    \"\"\"\n    Represents a complete link in the robot model.\n\n    A link is a rigid body in the robot model that can contain visual, collision,\n    and inertial properties. Links are connected by joints to form the complete\n    robot structure.\n\n    Attributes:\n        name (str): The unique identifier for the link.\n        visual (VisualLink | None): Optional visual properties for rendering.\n        collision (CollisionLink | None): Optional collision properties for physics simulation.\n        inertial (InertialLink | None): Optional inertial properties for dynamics.\n\n    Methods:\n        to_xml: Converts the link to an XML element.\n        to_mjcf: Converts the link to a MuJoCo compatible XML element.\n\n    Class Methods:\n        from_xml: Creates a Link from an XML element.\n\n    Examples:\n        &gt;&gt;&gt; link = Link(\n        ...     name=\"base_link\",\n        ...     visual=VisualLink(...),\n        ...     collision=CollisionLink(...),\n        ...     inertial=InertialLink(...)\n        ... )\n        &gt;&gt;&gt; link.to_xml()\n        &lt;Element 'link' at 0x...&gt;\n\n        &gt;&gt;&gt; xml_str = '''\n        ...     &lt;link name=\"base_link\"&gt;\n        ...         &lt;visual&gt;...&lt;/visual&gt;\n        ...         &lt;collision&gt;...&lt;/collision&gt;\n        ...         &lt;inertial&gt;...&lt;/inertial&gt;\n        ...     &lt;/link&gt;\n        ... '''\n        &gt;&gt;&gt; xml_element = ET.fromstring(xml_str)\n        &gt;&gt;&gt; link = Link.from_xml(xml_element)\n    \"\"\"\n\n    name: str\n    visual: VisualLink | None = None\n    collision: CollisionLink | None = None\n    inertial: InertialLink | None = None\n\n    def to_xml(self, root: Optional[_Element] = None) -&gt; _Element:\n        \"\"\"\n        Convert the link to an XML element.\n\n        Args:\n            root: The root element to append the link to.\n\n        Returns:\n            The XML element representing the link.\n\n        Examples:\n            &gt;&gt;&gt; link = Link(\n            ...     name=\"base_link\",\n            ...     visual=VisualLink(...),\n            ...     collision=CollisionLink(...),\n            ...     inertial=InertialLink(...)\n            ... )\n            &gt;&gt;&gt; link.to_xml()\n            &lt;Element 'link' at 0x...&gt;\n        \"\"\"\n        link: _Element = ET.Element(\"link\") if root is None else ET.SubElement(root, \"link\")\n        link.set(\"name\", self.name)\n        if self.visual is not None:\n            self.visual.to_xml(link)\n        if self.collision is not None:\n            self.collision.to_xml(link)\n        if self.inertial is not None:\n            self.inertial.to_xml(link)\n        return link\n\n    def to_mjcf(self, root: Optional[_Element] = None) -&gt; _Element:\n        \"\"\"\n        Convert the link to an MuJoCo compatible XML element.\n\n        Args:\n            root: The root element to append the link to.\n\n        Returns:\n            The XML element representing the link.\n\n        Examples:\n            &gt;&gt;&gt; link = Link(\n            ...     name=\"base_link\",\n            ...     visual=VisualLink(...),\n            ...     collision=CollisionLink(...),\n            ...     inertial=InertialLink(...)\n            ... )\n            &gt;&gt;&gt; link.to_mjcf()\n            &lt;Element 'link' at 0x...&gt;\n        \"\"\"\n        link: _Element = ET.Element(\"body\") if root is None else ET.SubElement(root, \"body\")\n        link.set(\"name\", self.name)\n\n        if self.visual:\n            link.set(\"pos\", \" \".join(map(str, self.visual.origin.xyz)))\n            link.set(\"euler\", \" \".join(map(str, self.visual.origin.rpy)))\n\n        if self.collision:\n            self.collision.to_mjcf(link)\n\n        if self.visual:\n            self.visual.to_mjcf(link)\n\n        if self.inertial:\n            self.inertial.to_mjcf(link)\n\n        return link\n\n    @classmethod\n    def from_xml(cls, xml: _Element) -&gt; \"Link\":\n        \"\"\"\n        Create a link from an XML element.\n\n        Args:\n            xml: The XML element to create the link from.\n\n        Returns:\n            The link created from the XML element.\n\n        Examples:\n            &gt;&gt;&gt; xml = ET.Element('link')\n            &gt;&gt;&gt; Link.from_xml(xml)\n            Link(name='link', visual=None, collision=None, inertial=None)\n        \"\"\"\n        name = xml.get(\"name\")\n\n        visual_element = xml.find(\"visual\")\n        visual = VisualLink.from_xml(visual_element) if visual_element is not None else None\n\n        collision_element = xml.find(\"collision\")\n        collision = CollisionLink.from_xml(collision_element) if collision_element is not None else None\n\n        inertial_element = xml.find(\"inertial\")\n        inertial = InertialLink.from_xml(inertial_element) if inertial_element is not None else None\n\n        return cls(name=name or \"unnamed_link\", visual=visual, collision=collision, inertial=inertial)\n</code></pre>"},{"location":"api/link/#onshape_robotics_toolkit.models.link.Link.from_xml","title":"<code>from_xml(xml)</code>  <code>classmethod</code>","text":"<p>Create a link from an XML element.</p> <p>Parameters:</p> Name Type Description Default <code>xml</code> <code>_Element</code> <p>The XML element to create the link from.</p> required <p>Returns:</p> Type Description <code>Link</code> <p>The link created from the XML element.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; xml = ET.Element('link')\n&gt;&gt;&gt; Link.from_xml(xml)\nLink(name='link', visual=None, collision=None, inertial=None)\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/link.py</code> <pre><code>@classmethod\ndef from_xml(cls, xml: _Element) -&gt; \"Link\":\n    \"\"\"\n    Create a link from an XML element.\n\n    Args:\n        xml: The XML element to create the link from.\n\n    Returns:\n        The link created from the XML element.\n\n    Examples:\n        &gt;&gt;&gt; xml = ET.Element('link')\n        &gt;&gt;&gt; Link.from_xml(xml)\n        Link(name='link', visual=None, collision=None, inertial=None)\n    \"\"\"\n    name = xml.get(\"name\")\n\n    visual_element = xml.find(\"visual\")\n    visual = VisualLink.from_xml(visual_element) if visual_element is not None else None\n\n    collision_element = xml.find(\"collision\")\n    collision = CollisionLink.from_xml(collision_element) if collision_element is not None else None\n\n    inertial_element = xml.find(\"inertial\")\n    inertial = InertialLink.from_xml(inertial_element) if inertial_element is not None else None\n\n    return cls(name=name or \"unnamed_link\", visual=visual, collision=collision, inertial=inertial)\n</code></pre>"},{"location":"api/link/#onshape_robotics_toolkit.models.link.Link.to_mjcf","title":"<code>to_mjcf(root=None)</code>","text":"<p>Convert the link to an MuJoCo compatible XML element.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>Optional[_Element]</code> <p>The root element to append the link to.</p> <code>None</code> <p>Returns:</p> Type Description <code>_Element</code> <p>The XML element representing the link.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; link = Link(\n...     name=\"base_link\",\n...     visual=VisualLink(...),\n...     collision=CollisionLink(...),\n...     inertial=InertialLink(...)\n... )\n&gt;&gt;&gt; link.to_mjcf()\n&lt;Element 'link' at 0x...&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/link.py</code> <pre><code>def to_mjcf(self, root: Optional[_Element] = None) -&gt; _Element:\n    \"\"\"\n    Convert the link to an MuJoCo compatible XML element.\n\n    Args:\n        root: The root element to append the link to.\n\n    Returns:\n        The XML element representing the link.\n\n    Examples:\n        &gt;&gt;&gt; link = Link(\n        ...     name=\"base_link\",\n        ...     visual=VisualLink(...),\n        ...     collision=CollisionLink(...),\n        ...     inertial=InertialLink(...)\n        ... )\n        &gt;&gt;&gt; link.to_mjcf()\n        &lt;Element 'link' at 0x...&gt;\n    \"\"\"\n    link: _Element = ET.Element(\"body\") if root is None else ET.SubElement(root, \"body\")\n    link.set(\"name\", self.name)\n\n    if self.visual:\n        link.set(\"pos\", \" \".join(map(str, self.visual.origin.xyz)))\n        link.set(\"euler\", \" \".join(map(str, self.visual.origin.rpy)))\n\n    if self.collision:\n        self.collision.to_mjcf(link)\n\n    if self.visual:\n        self.visual.to_mjcf(link)\n\n    if self.inertial:\n        self.inertial.to_mjcf(link)\n\n    return link\n</code></pre>"},{"location":"api/link/#onshape_robotics_toolkit.models.link.Link.to_xml","title":"<code>to_xml(root=None)</code>","text":"<p>Convert the link to an XML element.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>Optional[_Element]</code> <p>The root element to append the link to.</p> <code>None</code> <p>Returns:</p> Type Description <code>_Element</code> <p>The XML element representing the link.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; link = Link(\n...     name=\"base_link\",\n...     visual=VisualLink(...),\n...     collision=CollisionLink(...),\n...     inertial=InertialLink(...)\n... )\n&gt;&gt;&gt; link.to_xml()\n&lt;Element 'link' at 0x...&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/link.py</code> <pre><code>def to_xml(self, root: Optional[_Element] = None) -&gt; _Element:\n    \"\"\"\n    Convert the link to an XML element.\n\n    Args:\n        root: The root element to append the link to.\n\n    Returns:\n        The XML element representing the link.\n\n    Examples:\n        &gt;&gt;&gt; link = Link(\n        ...     name=\"base_link\",\n        ...     visual=VisualLink(...),\n        ...     collision=CollisionLink(...),\n        ...     inertial=InertialLink(...)\n        ... )\n        &gt;&gt;&gt; link.to_xml()\n        &lt;Element 'link' at 0x...&gt;\n    \"\"\"\n    link: _Element = ET.Element(\"link\") if root is None else ET.SubElement(root, \"link\")\n    link.set(\"name\", self.name)\n    if self.visual is not None:\n        self.visual.to_xml(link)\n    if self.collision is not None:\n        self.collision.to_xml(link)\n    if self.inertial is not None:\n        self.inertial.to_xml(link)\n    return link\n</code></pre>"},{"location":"api/link/#onshape_robotics_toolkit.models.link.Material","title":"<code>Material</code>  <code>dataclass</code>","text":"<p>Represents the material properties of a link in the robot model.</p> <p>Materials define the visual appearance of links in the robot model, primarily through their color properties.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name identifier for the material.</p> <code>color</code> <code>tuple[float, float, float, float]</code> <p>The RGBA color values, each component in range [0.0, 1.0].</p> <p>Methods:</p> Name Description <code>to_xml</code> <p>Converts the material properties to an XML element.</p> <code>to_mjcf</code> <p>Converts the material to a MuJoCo compatible XML element.</p> Class Methods <p>from_xml: Creates a material from an XML element. from_color: Creates a material from a predefined Colors enum value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; material = Material(name=\"red_material\", color=(1.0, 0.0, 0.0, 1.0))\n&gt;&gt;&gt; material.to_xml()\n&lt;Element 'material' at 0x...&gt;\n</code></pre> <pre><code>&gt;&gt;&gt; material = Material.from_color(\"steel_material\", Colors.BLUE)\n&gt;&gt;&gt; material.color\n(0.0, 0.0, 1.0, 1.0)\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/link.py</code> <pre><code>@dataclass\nclass Material:\n    \"\"\"\n    Represents the material properties of a link in the robot model.\n\n    Materials define the visual appearance of links in the robot model,\n    primarily through their color properties.\n\n    Attributes:\n        name (str): The name identifier for the material.\n        color (tuple[float, float, float, float]): The RGBA color values,\n            each component in range [0.0, 1.0].\n\n    Methods:\n        to_xml: Converts the material properties to an XML element.\n        to_mjcf: Converts the material to a MuJoCo compatible XML element.\n\n    Class Methods:\n        from_xml: Creates a material from an XML element.\n        from_color: Creates a material from a predefined Colors enum value.\n\n    Examples:\n        &gt;&gt;&gt; material = Material(name=\"red_material\", color=(1.0, 0.0, 0.0, 1.0))\n        &gt;&gt;&gt; material.to_xml()\n        &lt;Element 'material' at 0x...&gt;\n\n        &gt;&gt;&gt; material = Material.from_color(\"steel_material\", Colors.BLUE)\n        &gt;&gt;&gt; material.color\n        (0.0, 0.0, 1.0, 1.0)\n    \"\"\"\n\n    name: str\n    color: tuple[float, float, float, float]\n\n    def to_xml(self, root: Optional[_Element] = None) -&gt; _Element:\n        \"\"\"\n        Convert the material properties to an XML element.\n\n        Args:\n            root: The root element to append the material properties to.\n\n        Returns:\n            The XML element representing the material properties.\n\n        Examples:\n            &gt;&gt;&gt; material = Material(name=\"material\", color=(1.0, 0.0, 0.0, 1.0))\n            &gt;&gt;&gt; material.to_xml()\n            &lt;Element 'material' at 0x7f8b3c0b4c70&gt;\n        \"\"\"\n\n        material: _Element = ET.Element(\"material\") if root is None else ET.SubElement(root, \"material\")\n        material.set(\"name\", self.name)\n        ET.SubElement(material, \"color\", rgba=\" \".join(format_number(v) for v in self.color))\n        return material\n\n    def to_mjcf(self, root: _Element) -&gt; None:\n        \"\"\"\n        Convert the material properties to an MuJoCo compatible XML element.\n\n        Args:\n            root: The root element to append the material properties to.\n\n        Returns:\n            The XML element representing the material properties.\n\n        Examples:\n            &gt;&gt;&gt; material = Material(name=\"material\", color=(1.0, 0.0, 0.0, 1.0))\n            &gt;&gt;&gt; material.to_mjcf()\n            &lt;Element 'material' at 0x7f8b3c0b4c70&gt;\n        \"\"\"\n        geom = root if root is not None and root.tag == \"geom\" else ET.SubElement(root, \"geom\")\n        geom.set(\"rgba\", \" \".join(format_number(v) for v in self.color))\n\n    @classmethod\n    def from_xml(cls, xml: _Element) -&gt; \"Material\":\n        \"\"\"\n        Create a material from an XML element.\n\n        Args:\n            xml: The XML element to create the material from.\n\n        Returns:\n            The material created from the XML element.\n\n        Examples:\n            &gt;&gt;&gt; xml = ET.Element('material')\n            &gt;&gt;&gt; Material.from_xml(xml)\n            Material(name='material', color=(1.0, 0.0, 0.0, 1.0))\n        \"\"\"\n\n        name = xml.get(\"name\")\n        color_elem = xml.find(\"color\")\n\n        if color_elem is None:\n            raise ValueError(\"Missing color element in material XML\")\n\n        rgba_str = color_elem.get(\"rgba\")\n        if rgba_str is None:\n            raise ValueError(\"Missing rgba attribute in color element\")\n\n        color_values = tuple(map(float, rgba_str.split()))\n\n        if len(color_values) != 4:\n            raise ValueError(\"rgba must have exactly 4 values\")\n\n        color = (color_values[0], color_values[1], color_values[2], color_values[3])\n        return cls(name or \"default\", color)\n\n    @classmethod\n    def from_color(cls, name: str, color: Colors) -&gt; \"Material\":\n        \"\"\"\n        Create a material from a color.\n\n        Args:\n            name: The name of the material.\n            color: The color of the material.\n\n        Returns:\n            The material created from the color.\n\n        Examples:\n            &gt;&gt;&gt; Material.from_color(name=\"material\", color=Colors.RED)\n            Material(name='material', color=(1.0, 0.0, 0.0, 1.0))\n        \"\"\"\n        return cls(name, color)\n</code></pre>"},{"location":"api/link/#onshape_robotics_toolkit.models.link.Material.from_color","title":"<code>from_color(name, color)</code>  <code>classmethod</code>","text":"<p>Create a material from a color.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the material.</p> required <code>color</code> <code>Colors</code> <p>The color of the material.</p> required <p>Returns:</p> Type Description <code>Material</code> <p>The material created from the color.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Material.from_color(name=\"material\", color=Colors.RED)\nMaterial(name='material', color=(1.0, 0.0, 0.0, 1.0))\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/link.py</code> <pre><code>@classmethod\ndef from_color(cls, name: str, color: Colors) -&gt; \"Material\":\n    \"\"\"\n    Create a material from a color.\n\n    Args:\n        name: The name of the material.\n        color: The color of the material.\n\n    Returns:\n        The material created from the color.\n\n    Examples:\n        &gt;&gt;&gt; Material.from_color(name=\"material\", color=Colors.RED)\n        Material(name='material', color=(1.0, 0.0, 0.0, 1.0))\n    \"\"\"\n    return cls(name, color)\n</code></pre>"},{"location":"api/link/#onshape_robotics_toolkit.models.link.Material.from_xml","title":"<code>from_xml(xml)</code>  <code>classmethod</code>","text":"<p>Create a material from an XML element.</p> <p>Parameters:</p> Name Type Description Default <code>xml</code> <code>_Element</code> <p>The XML element to create the material from.</p> required <p>Returns:</p> Type Description <code>Material</code> <p>The material created from the XML element.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; xml = ET.Element('material')\n&gt;&gt;&gt; Material.from_xml(xml)\nMaterial(name='material', color=(1.0, 0.0, 0.0, 1.0))\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/link.py</code> <pre><code>@classmethod\ndef from_xml(cls, xml: _Element) -&gt; \"Material\":\n    \"\"\"\n    Create a material from an XML element.\n\n    Args:\n        xml: The XML element to create the material from.\n\n    Returns:\n        The material created from the XML element.\n\n    Examples:\n        &gt;&gt;&gt; xml = ET.Element('material')\n        &gt;&gt;&gt; Material.from_xml(xml)\n        Material(name='material', color=(1.0, 0.0, 0.0, 1.0))\n    \"\"\"\n\n    name = xml.get(\"name\")\n    color_elem = xml.find(\"color\")\n\n    if color_elem is None:\n        raise ValueError(\"Missing color element in material XML\")\n\n    rgba_str = color_elem.get(\"rgba\")\n    if rgba_str is None:\n        raise ValueError(\"Missing rgba attribute in color element\")\n\n    color_values = tuple(map(float, rgba_str.split()))\n\n    if len(color_values) != 4:\n        raise ValueError(\"rgba must have exactly 4 values\")\n\n    color = (color_values[0], color_values[1], color_values[2], color_values[3])\n    return cls(name or \"default\", color)\n</code></pre>"},{"location":"api/link/#onshape_robotics_toolkit.models.link.Material.to_mjcf","title":"<code>to_mjcf(root)</code>","text":"<p>Convert the material properties to an MuJoCo compatible XML element.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>_Element</code> <p>The root element to append the material properties to.</p> required <p>Returns:</p> Type Description <code>None</code> <p>The XML element representing the material properties.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; material = Material(name=\"material\", color=(1.0, 0.0, 0.0, 1.0))\n&gt;&gt;&gt; material.to_mjcf()\n&lt;Element 'material' at 0x7f8b3c0b4c70&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/link.py</code> <pre><code>def to_mjcf(self, root: _Element) -&gt; None:\n    \"\"\"\n    Convert the material properties to an MuJoCo compatible XML element.\n\n    Args:\n        root: The root element to append the material properties to.\n\n    Returns:\n        The XML element representing the material properties.\n\n    Examples:\n        &gt;&gt;&gt; material = Material(name=\"material\", color=(1.0, 0.0, 0.0, 1.0))\n        &gt;&gt;&gt; material.to_mjcf()\n        &lt;Element 'material' at 0x7f8b3c0b4c70&gt;\n    \"\"\"\n    geom = root if root is not None and root.tag == \"geom\" else ET.SubElement(root, \"geom\")\n    geom.set(\"rgba\", \" \".join(format_number(v) for v in self.color))\n</code></pre>"},{"location":"api/link/#onshape_robotics_toolkit.models.link.Material.to_xml","title":"<code>to_xml(root=None)</code>","text":"<p>Convert the material properties to an XML element.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>Optional[_Element]</code> <p>The root element to append the material properties to.</p> <code>None</code> <p>Returns:</p> Type Description <code>_Element</code> <p>The XML element representing the material properties.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; material = Material(name=\"material\", color=(1.0, 0.0, 0.0, 1.0))\n&gt;&gt;&gt; material.to_xml()\n&lt;Element 'material' at 0x7f8b3c0b4c70&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/link.py</code> <pre><code>def to_xml(self, root: Optional[_Element] = None) -&gt; _Element:\n    \"\"\"\n    Convert the material properties to an XML element.\n\n    Args:\n        root: The root element to append the material properties to.\n\n    Returns:\n        The XML element representing the material properties.\n\n    Examples:\n        &gt;&gt;&gt; material = Material(name=\"material\", color=(1.0, 0.0, 0.0, 1.0))\n        &gt;&gt;&gt; material.to_xml()\n        &lt;Element 'material' at 0x7f8b3c0b4c70&gt;\n    \"\"\"\n\n    material: _Element = ET.Element(\"material\") if root is None else ET.SubElement(root, \"material\")\n    material.set(\"name\", self.name)\n    ET.SubElement(material, \"color\", rgba=\" \".join(format_number(v) for v in self.color))\n    return material\n</code></pre>"},{"location":"api/link/#onshape_robotics_toolkit.models.link.Origin","title":"<code>Origin</code>  <code>dataclass</code>","text":"<p>Represents the origin of a link in the robot model.</p> <p>Attributes:</p> Name Type Description <code>xyz</code> <code>tuple[float, float, float]</code> <p>The x, y, z coordinates of the origin.</p> <code>rpy</code> <code>tuple[float, float, float]</code> <p>The roll, pitch, yaw angles of the origin.</p> <p>Methods:</p> Name Description <code>transform</code> <p>Applies a transformation matrix to the origin.</p> <code>to_xml</code> <p>Converts the origin to an XML element.</p> <code>to_mjcf</code> <p>Converts the origin to a MuJoCo compatible XML element.</p> <code>quat</code> <p>Converts the origin's rotation to a quaternion.</p> Class Methods <p>from_xml: Creates an origin from an XML element. from_matrix: Creates an origin from a transformation matrix. zero_origin: Creates an origin at (0, 0, 0) with no rotation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; origin = Origin(xyz=(1.0, 2.0, 3.0), rpy=(0.0, 0.0, 0.0))\n&gt;&gt;&gt; origin.to_xml()\n&lt;Element 'origin' at 0x7f8b3c0b4c70&gt;\n</code></pre> <pre><code>&gt;&gt;&gt; matrix = np.matrix([\n...     [1, 0, 0, 0],\n...     [0, 1, 0, 0],\n...     [0, 0, 1, 0],\n...     [0, 0, 0, 1],\n... ])\n&gt;&gt;&gt; Origin.from_matrix(matrix)\nOrigin(xyz=(0.0, 0.0, 0.0), rpy=(0.0, 0.0, 0.0))\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/link.py</code> <pre><code>@dataclass\nclass Origin:\n    \"\"\"\n    Represents the origin of a link in the robot model.\n\n    Attributes:\n        xyz (tuple[float, float, float]): The x, y, z coordinates of the origin.\n        rpy (tuple[float, float, float]): The roll, pitch, yaw angles of the origin.\n\n    Methods:\n        transform: Applies a transformation matrix to the origin.\n        to_xml: Converts the origin to an XML element.\n        to_mjcf: Converts the origin to a MuJoCo compatible XML element.\n        quat: Converts the origin's rotation to a quaternion.\n\n    Class Methods:\n        from_xml: Creates an origin from an XML element.\n        from_matrix: Creates an origin from a transformation matrix.\n        zero_origin: Creates an origin at (0, 0, 0) with no rotation.\n\n    Examples:\n        &gt;&gt;&gt; origin = Origin(xyz=(1.0, 2.0, 3.0), rpy=(0.0, 0.0, 0.0))\n        &gt;&gt;&gt; origin.to_xml()\n        &lt;Element 'origin' at 0x7f8b3c0b4c70&gt;\n\n        &gt;&gt;&gt; matrix = np.matrix([\n        ...     [1, 0, 0, 0],\n        ...     [0, 1, 0, 0],\n        ...     [0, 0, 1, 0],\n        ...     [0, 0, 0, 1],\n        ... ])\n        &gt;&gt;&gt; Origin.from_matrix(matrix)\n        Origin(xyz=(0.0, 0.0, 0.0), rpy=(0.0, 0.0, 0.0))\n    \"\"\"\n\n    xyz: tuple[float, float, float]\n    rpy: tuple[float, float, float]\n\n    def transform(self, matrix: np.matrix, inplace: bool = False) -&gt; Union[\"Origin\", None]:\n        \"\"\"\n        Apply a transformation matrix to the origin.\n\n        Args:\n            matrix (np.matrix): The 4x4 transformation matrix to apply.\n            inplace (bool): If True, modifies the current origin. If False, returns a new Origin.\n\n        Returns:\n            Union[Origin, None]: If inplace is False, returns a new transformed Origin.\n                               If inplace is True, returns None and modifies current Origin.\n\n        Examples:\n            &gt;&gt;&gt; origin = Origin(xyz=(1.0, 2.0, 3.0), rpy=(0.0, 0.0, 0.0))\n            &gt;&gt;&gt; matrix = np.eye(4)\n            &gt;&gt;&gt; new_origin = origin.transform(matrix)  # Returns new Origin\n            &gt;&gt;&gt; origin.transform(matrix, inplace=True)  # Modifies origin in place\n        \"\"\"\n        new_xyz = np.dot(matrix[:3, :3], np.array(self.xyz)) + matrix[:3, 3]\n        current_rotation_matrix = Rotation.from_euler(\"xyz\", self.rpy).as_matrix()\n\n        new_rotation_matrix = np.dot(matrix[:3, :3], current_rotation_matrix)\n        new_rpy = Rotation.from_matrix(new_rotation_matrix).as_euler(\"xyz\")\n        if inplace:\n            self.xyz = (float(new_xyz[0]), float(new_xyz[1]), float(new_xyz[2]))\n            self.rpy = (float(new_rpy[0]), float(new_rpy[1]), float(new_rpy[2]))\n            return None\n\n        return Origin(\n            (float(new_xyz[0]), float(new_xyz[1]), float(new_xyz[2])),\n            (float(new_rpy[0]), float(new_rpy[1]), float(new_rpy[2])),\n        )\n\n    def to_xml(self, root: Optional[_Element] = None) -&gt; _Element:\n        \"\"\"\n        Convert the origin to an XML element.\n\n        Args:\n            root: The root element to append the origin to.\n\n        Returns:\n            The XML element representing the origin.\n\n        Examples:\n            &gt;&gt;&gt; origin = Origin(xyz=(1.0, 2.0, 3.0), rpy=(0.0, 0.0, 0.0))\n            &gt;&gt;&gt; origin.to_xml()\n            &lt;Element 'origin' at 0x7f8b3c0b4c70&gt;\n        \"\"\"\n\n        origin: _Element = ET.Element(\"origin\") if root is None else ET.SubElement(root, \"origin\")\n        origin.set(\"xyz\", \" \".join(format_number(v) for v in self.xyz))\n        origin.set(\"rpy\", \" \".join(format_number(v) for v in self.rpy))\n        return origin\n\n    def to_mjcf(self, root: _Element) -&gt; None:\n        \"\"\"\n        Convert the origin to a MuJoCo compatible XML element.\n\n        Args:\n            root (ET.Element): The root element to add the origin attributes to.\n                             Adds 'pos' and 'euler' attributes to this element.\n\n        Examples:\n            &gt;&gt;&gt; origin = Origin(xyz=(1.0, 2.0, 3.0), rpy=(0.0, 0.0, 0.0))\n            &gt;&gt;&gt; element = ET.Element('body')\n            &gt;&gt;&gt; origin.to_mjcf(element)\n            &gt;&gt;&gt; element.get('pos')\n            '1.0 2.0 3.0'\n            &gt;&gt;&gt; element.get('euler')\n            '0.0 0.0 0.0'\n        \"\"\"\n        root.set(\"pos\", \" \".join(format_number(v) for v in self.xyz))\n        root.set(\"euler\", \" \".join(format_number(v) for v in self.rpy))\n\n    @classmethod\n    def from_xml(cls, xml: _Element) -&gt; \"Origin\":\n        \"\"\"\n        Create an origin from an XML element.\n\n        Args:\n            xml: The XML element to create the origin from.\n\n        Returns:\n            The origin created from the XML element.\n\n        Examples:\n            &gt;&gt;&gt; xml = ET.Element('origin')\n            &gt;&gt;&gt; Origin.from_xml(xml)\n            Origin(xyz=(0.0, 0.0, 0.0), rpy=(0.0, 0.0, 0.0))\n        \"\"\"\n\n        xyz_str = xml.get(\"xyz\")\n        rpy_str = xml.get(\"rpy\")\n\n        if xyz_str is None or rpy_str is None:\n            raise ValueError(\"Missing xyz or rpy attributes in origin XML\")\n\n        xyz_values = tuple(map(float, xyz_str.split()))\n        rpy_values = tuple(map(float, rpy_str.split()))\n\n        if len(xyz_values) != 3 or len(rpy_values) != 3:\n            raise ValueError(\"xyz and rpy must have exactly 3 values\")\n\n        xyz = (xyz_values[0], xyz_values[1], xyz_values[2])\n        rpy = (rpy_values[0], rpy_values[1], rpy_values[2])\n        return cls(xyz, rpy)\n\n    def quat(self, sequence: str = \"xyz\") -&gt; np.ndarray:\n        \"\"\"\n        Convert the origin's rotation to a quaternion.\n\n        Args:\n            sequence (str): The sequence of rotations used for Euler angles. Defaults to \"xyz\".\n\n        Returns:\n            np.ndarray: A quaternion [x, y, z, w] representing the rotation.\n\n        Examples:\n            &gt;&gt;&gt; origin = Origin(xyz=(0.0, 0.0, 0.0), rpy=(np.pi/2, 0.0, 0.0))\n            &gt;&gt;&gt; origin.quat()\n            array([0.70710678, 0.        , 0.        , 0.70710678])\n        \"\"\"\n        return Rotation.from_euler(sequence, self.rpy).as_quat()\n\n    @classmethod\n    def from_matrix(cls, matrix: np.matrix) -&gt; \"Origin\":\n        \"\"\"\n        Create an origin from a transformation matrix.\n\n        Args:\n            matrix: The transformation matrix.\n\n        Returns:\n            The origin created from the transformation matrix.\n\n        Examples:\n            &gt;&gt;&gt; matrix = np.matrix([\n            ...     [1, 0, 0, 0],\n            ...     [0, 1, 0, 0],\n            ...     [0, 0, 1, 0],\n            ...     [0, 0, 0, 1],\n            ... ])\n            &gt;&gt;&gt; Origin.from_matrix(matrix)\n            Origin(xyz=(0.0, 0.0, 0.0), rpy=(0.0, 0.0, 0.0))\n        \"\"\"\n\n        x = float(matrix[0, 3])\n        y = float(matrix[1, 3])\n        z = float(matrix[2, 3])\n        euler_angles = Rotation.from_matrix(matrix[:3, :3]).as_euler(\"xyz\")\n        return cls((x, y, z), (float(euler_angles[0]), float(euler_angles[1]), float(euler_angles[2])))\n\n    @classmethod\n    def zero_origin(cls) -&gt; \"Origin\":\n        \"\"\"\n        Create an origin at the origin (0, 0, 0) with no rotation.\n\n        Returns:\n            The origin at the origin (0, 0, 0) with no rotation.\n\n        Examples:\n            &gt;&gt;&gt; Origin.zero_origin()\n            Origin(xyz=(0.0, 0.0, 0.0), rpy=(0.0, 0.0, 0.0))\n        \"\"\"\n\n        return cls((0.0, 0.0, 0.0), (0.0, 0.0, 0.0))\n</code></pre>"},{"location":"api/link/#onshape_robotics_toolkit.models.link.Origin.from_matrix","title":"<code>from_matrix(matrix)</code>  <code>classmethod</code>","text":"<p>Create an origin from a transformation matrix.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>matrix</code> <p>The transformation matrix.</p> required <p>Returns:</p> Type Description <code>Origin</code> <p>The origin created from the transformation matrix.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; matrix = np.matrix([\n...     [1, 0, 0, 0],\n...     [0, 1, 0, 0],\n...     [0, 0, 1, 0],\n...     [0, 0, 0, 1],\n... ])\n&gt;&gt;&gt; Origin.from_matrix(matrix)\nOrigin(xyz=(0.0, 0.0, 0.0), rpy=(0.0, 0.0, 0.0))\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/link.py</code> <pre><code>@classmethod\ndef from_matrix(cls, matrix: np.matrix) -&gt; \"Origin\":\n    \"\"\"\n    Create an origin from a transformation matrix.\n\n    Args:\n        matrix: The transformation matrix.\n\n    Returns:\n        The origin created from the transformation matrix.\n\n    Examples:\n        &gt;&gt;&gt; matrix = np.matrix([\n        ...     [1, 0, 0, 0],\n        ...     [0, 1, 0, 0],\n        ...     [0, 0, 1, 0],\n        ...     [0, 0, 0, 1],\n        ... ])\n        &gt;&gt;&gt; Origin.from_matrix(matrix)\n        Origin(xyz=(0.0, 0.0, 0.0), rpy=(0.0, 0.0, 0.0))\n    \"\"\"\n\n    x = float(matrix[0, 3])\n    y = float(matrix[1, 3])\n    z = float(matrix[2, 3])\n    euler_angles = Rotation.from_matrix(matrix[:3, :3]).as_euler(\"xyz\")\n    return cls((x, y, z), (float(euler_angles[0]), float(euler_angles[1]), float(euler_angles[2])))\n</code></pre>"},{"location":"api/link/#onshape_robotics_toolkit.models.link.Origin.from_xml","title":"<code>from_xml(xml)</code>  <code>classmethod</code>","text":"<p>Create an origin from an XML element.</p> <p>Parameters:</p> Name Type Description Default <code>xml</code> <code>_Element</code> <p>The XML element to create the origin from.</p> required <p>Returns:</p> Type Description <code>Origin</code> <p>The origin created from the XML element.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; xml = ET.Element('origin')\n&gt;&gt;&gt; Origin.from_xml(xml)\nOrigin(xyz=(0.0, 0.0, 0.0), rpy=(0.0, 0.0, 0.0))\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/link.py</code> <pre><code>@classmethod\ndef from_xml(cls, xml: _Element) -&gt; \"Origin\":\n    \"\"\"\n    Create an origin from an XML element.\n\n    Args:\n        xml: The XML element to create the origin from.\n\n    Returns:\n        The origin created from the XML element.\n\n    Examples:\n        &gt;&gt;&gt; xml = ET.Element('origin')\n        &gt;&gt;&gt; Origin.from_xml(xml)\n        Origin(xyz=(0.0, 0.0, 0.0), rpy=(0.0, 0.0, 0.0))\n    \"\"\"\n\n    xyz_str = xml.get(\"xyz\")\n    rpy_str = xml.get(\"rpy\")\n\n    if xyz_str is None or rpy_str is None:\n        raise ValueError(\"Missing xyz or rpy attributes in origin XML\")\n\n    xyz_values = tuple(map(float, xyz_str.split()))\n    rpy_values = tuple(map(float, rpy_str.split()))\n\n    if len(xyz_values) != 3 or len(rpy_values) != 3:\n        raise ValueError(\"xyz and rpy must have exactly 3 values\")\n\n    xyz = (xyz_values[0], xyz_values[1], xyz_values[2])\n    rpy = (rpy_values[0], rpy_values[1], rpy_values[2])\n    return cls(xyz, rpy)\n</code></pre>"},{"location":"api/link/#onshape_robotics_toolkit.models.link.Origin.quat","title":"<code>quat(sequence='xyz')</code>","text":"<p>Convert the origin's rotation to a quaternion.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>str</code> <p>The sequence of rotations used for Euler angles. Defaults to \"xyz\".</p> <code>'xyz'</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: A quaternion [x, y, z, w] representing the rotation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; origin = Origin(xyz=(0.0, 0.0, 0.0), rpy=(np.pi/2, 0.0, 0.0))\n&gt;&gt;&gt; origin.quat()\narray([0.70710678, 0.        , 0.        , 0.70710678])\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/link.py</code> <pre><code>def quat(self, sequence: str = \"xyz\") -&gt; np.ndarray:\n    \"\"\"\n    Convert the origin's rotation to a quaternion.\n\n    Args:\n        sequence (str): The sequence of rotations used for Euler angles. Defaults to \"xyz\".\n\n    Returns:\n        np.ndarray: A quaternion [x, y, z, w] representing the rotation.\n\n    Examples:\n        &gt;&gt;&gt; origin = Origin(xyz=(0.0, 0.0, 0.0), rpy=(np.pi/2, 0.0, 0.0))\n        &gt;&gt;&gt; origin.quat()\n        array([0.70710678, 0.        , 0.        , 0.70710678])\n    \"\"\"\n    return Rotation.from_euler(sequence, self.rpy).as_quat()\n</code></pre>"},{"location":"api/link/#onshape_robotics_toolkit.models.link.Origin.to_mjcf","title":"<code>to_mjcf(root)</code>","text":"<p>Convert the origin to a MuJoCo compatible XML element.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>Element</code> <p>The root element to add the origin attributes to.              Adds 'pos' and 'euler' attributes to this element.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; origin = Origin(xyz=(1.0, 2.0, 3.0), rpy=(0.0, 0.0, 0.0))\n&gt;&gt;&gt; element = ET.Element('body')\n&gt;&gt;&gt; origin.to_mjcf(element)\n&gt;&gt;&gt; element.get('pos')\n'1.0 2.0 3.0'\n&gt;&gt;&gt; element.get('euler')\n'0.0 0.0 0.0'\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/link.py</code> <pre><code>def to_mjcf(self, root: _Element) -&gt; None:\n    \"\"\"\n    Convert the origin to a MuJoCo compatible XML element.\n\n    Args:\n        root (ET.Element): The root element to add the origin attributes to.\n                         Adds 'pos' and 'euler' attributes to this element.\n\n    Examples:\n        &gt;&gt;&gt; origin = Origin(xyz=(1.0, 2.0, 3.0), rpy=(0.0, 0.0, 0.0))\n        &gt;&gt;&gt; element = ET.Element('body')\n        &gt;&gt;&gt; origin.to_mjcf(element)\n        &gt;&gt;&gt; element.get('pos')\n        '1.0 2.0 3.0'\n        &gt;&gt;&gt; element.get('euler')\n        '0.0 0.0 0.0'\n    \"\"\"\n    root.set(\"pos\", \" \".join(format_number(v) for v in self.xyz))\n    root.set(\"euler\", \" \".join(format_number(v) for v in self.rpy))\n</code></pre>"},{"location":"api/link/#onshape_robotics_toolkit.models.link.Origin.to_xml","title":"<code>to_xml(root=None)</code>","text":"<p>Convert the origin to an XML element.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>Optional[_Element]</code> <p>The root element to append the origin to.</p> <code>None</code> <p>Returns:</p> Type Description <code>_Element</code> <p>The XML element representing the origin.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; origin = Origin(xyz=(1.0, 2.0, 3.0), rpy=(0.0, 0.0, 0.0))\n&gt;&gt;&gt; origin.to_xml()\n&lt;Element 'origin' at 0x7f8b3c0b4c70&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/link.py</code> <pre><code>def to_xml(self, root: Optional[_Element] = None) -&gt; _Element:\n    \"\"\"\n    Convert the origin to an XML element.\n\n    Args:\n        root: The root element to append the origin to.\n\n    Returns:\n        The XML element representing the origin.\n\n    Examples:\n        &gt;&gt;&gt; origin = Origin(xyz=(1.0, 2.0, 3.0), rpy=(0.0, 0.0, 0.0))\n        &gt;&gt;&gt; origin.to_xml()\n        &lt;Element 'origin' at 0x7f8b3c0b4c70&gt;\n    \"\"\"\n\n    origin: _Element = ET.Element(\"origin\") if root is None else ET.SubElement(root, \"origin\")\n    origin.set(\"xyz\", \" \".join(format_number(v) for v in self.xyz))\n    origin.set(\"rpy\", \" \".join(format_number(v) for v in self.rpy))\n    return origin\n</code></pre>"},{"location":"api/link/#onshape_robotics_toolkit.models.link.Origin.transform","title":"<code>transform(matrix, inplace=False)</code>","text":"<p>Apply a transformation matrix to the origin.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>matrix</code> <p>The 4x4 transformation matrix to apply.</p> required <code>inplace</code> <code>bool</code> <p>If True, modifies the current origin. If False, returns a new Origin.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[Origin, None]</code> <p>Union[Origin, None]: If inplace is False, returns a new transformed Origin.                If inplace is True, returns None and modifies current Origin.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; origin = Origin(xyz=(1.0, 2.0, 3.0), rpy=(0.0, 0.0, 0.0))\n&gt;&gt;&gt; matrix = np.eye(4)\n&gt;&gt;&gt; new_origin = origin.transform(matrix)  # Returns new Origin\n&gt;&gt;&gt; origin.transform(matrix, inplace=True)  # Modifies origin in place\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/link.py</code> <pre><code>def transform(self, matrix: np.matrix, inplace: bool = False) -&gt; Union[\"Origin\", None]:\n    \"\"\"\n    Apply a transformation matrix to the origin.\n\n    Args:\n        matrix (np.matrix): The 4x4 transformation matrix to apply.\n        inplace (bool): If True, modifies the current origin. If False, returns a new Origin.\n\n    Returns:\n        Union[Origin, None]: If inplace is False, returns a new transformed Origin.\n                           If inplace is True, returns None and modifies current Origin.\n\n    Examples:\n        &gt;&gt;&gt; origin = Origin(xyz=(1.0, 2.0, 3.0), rpy=(0.0, 0.0, 0.0))\n        &gt;&gt;&gt; matrix = np.eye(4)\n        &gt;&gt;&gt; new_origin = origin.transform(matrix)  # Returns new Origin\n        &gt;&gt;&gt; origin.transform(matrix, inplace=True)  # Modifies origin in place\n    \"\"\"\n    new_xyz = np.dot(matrix[:3, :3], np.array(self.xyz)) + matrix[:3, 3]\n    current_rotation_matrix = Rotation.from_euler(\"xyz\", self.rpy).as_matrix()\n\n    new_rotation_matrix = np.dot(matrix[:3, :3], current_rotation_matrix)\n    new_rpy = Rotation.from_matrix(new_rotation_matrix).as_euler(\"xyz\")\n    if inplace:\n        self.xyz = (float(new_xyz[0]), float(new_xyz[1]), float(new_xyz[2]))\n        self.rpy = (float(new_rpy[0]), float(new_rpy[1]), float(new_rpy[2]))\n        return None\n\n    return Origin(\n        (float(new_xyz[0]), float(new_xyz[1]), float(new_xyz[2])),\n        (float(new_rpy[0]), float(new_rpy[1]), float(new_rpy[2])),\n    )\n</code></pre>"},{"location":"api/link/#onshape_robotics_toolkit.models.link.Origin.zero_origin","title":"<code>zero_origin()</code>  <code>classmethod</code>","text":"<p>Create an origin at the origin (0, 0, 0) with no rotation.</p> <p>Returns:</p> Type Description <code>Origin</code> <p>The origin at the origin (0, 0, 0) with no rotation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Origin.zero_origin()\nOrigin(xyz=(0.0, 0.0, 0.0), rpy=(0.0, 0.0, 0.0))\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/link.py</code> <pre><code>@classmethod\ndef zero_origin(cls) -&gt; \"Origin\":\n    \"\"\"\n    Create an origin at the origin (0, 0, 0) with no rotation.\n\n    Returns:\n        The origin at the origin (0, 0, 0) with no rotation.\n\n    Examples:\n        &gt;&gt;&gt; Origin.zero_origin()\n        Origin(xyz=(0.0, 0.0, 0.0), rpy=(0.0, 0.0, 0.0))\n    \"\"\"\n\n    return cls((0.0, 0.0, 0.0), (0.0, 0.0, 0.0))\n</code></pre>"},{"location":"api/link/#onshape_robotics_toolkit.models.link.VisualLink","title":"<code>VisualLink</code>  <code>dataclass</code>","text":"<p>Represents the visual properties of a link in the robot model.</p> <p>This class defines how a link appears in visualization tools and simulators, including its position, geometry, and material properties.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>Union[str, None]</code> <p>Optional name identifier for the visual element.</p> <code>origin</code> <code>Origin</code> <p>The position and orientation of the visual geometry.</p> <code>geometry</code> <code>BaseGeometry</code> <p>The shape of the visual element (box, cylinder, mesh, etc.).</p> <code>material</code> <code>Material</code> <p>The material properties (color, texture) of the visual element.</p> <p>Methods:</p> Name Description <code>to_xml</code> <p>Converts the visual properties to an XML element.</p> <code>to_mjcf</code> <p>Converts the visual properties to a MuJoCo compatible XML element.</p> <code>transform</code> <p>Applies a transformation matrix to the visual geometry's origin.</p> Class Methods <p>from_xml: Creates a VisualLink from an XML element.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; visual = VisualLink(\n...     name=\"link_visual\",\n...     origin=Origin.zero_origin(),\n...     geometry=BoxGeometry(size=(1.0, 1.0, 1.0)),\n...     material=Material.from_color(\"red\", Colors.RED)\n... )\n&gt;&gt;&gt; visual.to_xml()\n&lt;Element 'visual' at 0x...&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/link.py</code> <pre><code>@dataclass\nclass VisualLink:\n    \"\"\"\n    Represents the visual properties of a link in the robot model.\n\n    This class defines how a link appears in visualization tools and simulators,\n    including its position, geometry, and material properties.\n\n    Attributes:\n        name (Union[str, None]): Optional name identifier for the visual element.\n        origin (Origin): The position and orientation of the visual geometry.\n        geometry (BaseGeometry): The shape of the visual element (box, cylinder, mesh, etc.).\n        material (Material): The material properties (color, texture) of the visual element.\n\n    Methods:\n        to_xml: Converts the visual properties to an XML element.\n        to_mjcf: Converts the visual properties to a MuJoCo compatible XML element.\n        transform: Applies a transformation matrix to the visual geometry's origin.\n\n    Class Methods:\n        from_xml: Creates a VisualLink from an XML element.\n\n    Examples:\n        &gt;&gt;&gt; visual = VisualLink(\n        ...     name=\"link_visual\",\n        ...     origin=Origin.zero_origin(),\n        ...     geometry=BoxGeometry(size=(1.0, 1.0, 1.0)),\n        ...     material=Material.from_color(\"red\", Colors.RED)\n        ... )\n        &gt;&gt;&gt; visual.to_xml()\n        &lt;Element 'visual' at 0x...&gt;\n    \"\"\"\n\n    name: Union[str, None]\n    origin: Origin\n    geometry: BaseGeometry\n    material: Material\n\n    def transform(self, transformation_matrix: np.ndarray) -&gt; None:\n        \"\"\"\n        Apply a transformation to the visual link's origin.\n\n        Args:\n            transformation_matrix (np.ndarray): A 4x4 transformation matrix (homogeneous).\n        \"\"\"\n        # Apply translation and rotation to the origin position\n        pos = np.array([self.origin.xyz[0], self.origin.xyz[1], self.origin.xyz[2], 1])\n        new_pos = transformation_matrix @ pos\n        self.origin.xyz = (float(new_pos[0]), float(new_pos[1]), float(new_pos[2]))  # Update position\n\n        # Extract the rotation from the transformation matrix\n        rotation_matrix = transformation_matrix[:3, :3]\n        current_rotation = R.from_euler(\"xyz\", self.origin.rpy)\n        new_rotation = R.from_matrix(rotation_matrix @ current_rotation.as_matrix())\n        euler_angles = new_rotation.as_euler(\"xyz\")\n        self.origin.rpy = (float(euler_angles[0]), float(euler_angles[1]), float(euler_angles[2]))\n\n    def to_xml(self, root: Optional[_Element] = None) -&gt; _Element:\n        \"\"\"\n        Convert the visual properties to an XML element.\n\n        Args:\n            root: The root element to append the visual properties to.\n\n        Returns:\n            The XML element representing the visual properties.\n\n        Examples:\n            &gt;&gt;&gt; visual = VisualLink(\n            ...     name=\"link_visual\",\n            ...     origin=Origin.zero_origin(),\n            ...     geometry=BoxGeometry(size=(1.0, 1.0, 1.0)),\n            ...     material=Material.from_color(\"red\", Colors.RED)\n            ... )\n            &gt;&gt;&gt; visual.to_xml()\n            &lt;Element 'visual' at 0x...&gt;\n        \"\"\"\n        visual: _Element = ET.Element(\"visual\") if root is None else ET.SubElement(root, \"visual\")\n        if self.name:\n            visual.set(\"name\", self.name)\n        self.origin.to_xml(visual)\n        self.geometry.to_xml(visual)\n        self.material.to_xml(visual)\n        return visual\n\n    def to_mjcf(self, root: _Element) -&gt; None:\n        \"\"\"\n        Convert the visual properties to an MuJoCo compatible XML element.\n\n        Args:\n            root: The root element to append the visual properties to.\n\n        Returns:\n            The XML element representing the visual properties.\n\n        Examples:\n            &gt;&gt;&gt; visual = VisualLink(\n            ...     name=\"link_visual\",\n            ...     origin=Origin.zero_origin(),\n            ...     geometry=BoxGeometry(size=(1.0, 1.0, 1.0)),\n            ...     material=Material.from_color(\"red\", Colors.RED)\n            ... )\n            &gt;&gt;&gt; visual.to_mjcf()\n            &lt;Element 'visual' at 0x...&gt;\n        \"\"\"\n        visual = root if root.tag == \"geom\" else ET.SubElement(root, \"geom\")\n        if self.name:\n            visual.set(\"name\", self.name)\n        # TODO: Parent body uses visual origin, these share the same?\n        self.origin.to_mjcf(visual)\n\n        if self.geometry:\n            self.geometry.to_mjcf(visual)\n\n        self.material.to_mjcf(visual)\n\n        visual.set(\"conaffinity\", \"0\")\n        visual.set(\"condim\", \"1\")\n        visual.set(\"contype\", \"0\")\n        visual.set(\"density\", \"0\")\n        visual.set(\"group\", \"1\")\n\n    @classmethod\n    def from_xml(cls, xml: _Element) -&gt; \"VisualLink\":\n        \"\"\"\n        Create a visual link from an XML element.\n\n        Args:\n            xml: The XML element to create the visual link from.\n\n        Returns:\n            The visual link created from the XML element.\n\n        Examples:\n            &gt;&gt;&gt; xml = ET.Element('visual')\n            &gt;&gt;&gt; VisualLink.from_xml(xml)\n            VisualLink(name='visual', origin=None, geometry=None, material=None)\n        \"\"\"\n        name = xml.get(\"name\")\n        origin_element = xml.find(\"origin\")\n        geometry_element = xml.find(\"geometry\")\n        material_element = xml.find(\"material\")\n\n        if origin_element is None or geometry_element is None or material_element is None:\n            raise ValueError(\"VisualLink requires origin, geometry, and material elements\")\n\n        origin = Origin.from_xml(origin_element)\n        geometry = set_geometry_from_xml(geometry_element)\n        material = Material.from_xml(material_element)\n\n        if geometry is None:\n            raise ValueError(\"Failed to parse geometry element\")\n\n        return cls(name=name, origin=origin, geometry=geometry, material=material)\n</code></pre>"},{"location":"api/link/#onshape_robotics_toolkit.models.link.VisualLink.from_xml","title":"<code>from_xml(xml)</code>  <code>classmethod</code>","text":"<p>Create a visual link from an XML element.</p> <p>Parameters:</p> Name Type Description Default <code>xml</code> <code>_Element</code> <p>The XML element to create the visual link from.</p> required <p>Returns:</p> Type Description <code>VisualLink</code> <p>The visual link created from the XML element.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; xml = ET.Element('visual')\n&gt;&gt;&gt; VisualLink.from_xml(xml)\nVisualLink(name='visual', origin=None, geometry=None, material=None)\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/link.py</code> <pre><code>@classmethod\ndef from_xml(cls, xml: _Element) -&gt; \"VisualLink\":\n    \"\"\"\n    Create a visual link from an XML element.\n\n    Args:\n        xml: The XML element to create the visual link from.\n\n    Returns:\n        The visual link created from the XML element.\n\n    Examples:\n        &gt;&gt;&gt; xml = ET.Element('visual')\n        &gt;&gt;&gt; VisualLink.from_xml(xml)\n        VisualLink(name='visual', origin=None, geometry=None, material=None)\n    \"\"\"\n    name = xml.get(\"name\")\n    origin_element = xml.find(\"origin\")\n    geometry_element = xml.find(\"geometry\")\n    material_element = xml.find(\"material\")\n\n    if origin_element is None or geometry_element is None or material_element is None:\n        raise ValueError(\"VisualLink requires origin, geometry, and material elements\")\n\n    origin = Origin.from_xml(origin_element)\n    geometry = set_geometry_from_xml(geometry_element)\n    material = Material.from_xml(material_element)\n\n    if geometry is None:\n        raise ValueError(\"Failed to parse geometry element\")\n\n    return cls(name=name, origin=origin, geometry=geometry, material=material)\n</code></pre>"},{"location":"api/link/#onshape_robotics_toolkit.models.link.VisualLink.to_mjcf","title":"<code>to_mjcf(root)</code>","text":"<p>Convert the visual properties to an MuJoCo compatible XML element.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>_Element</code> <p>The root element to append the visual properties to.</p> required <p>Returns:</p> Type Description <code>None</code> <p>The XML element representing the visual properties.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; visual = VisualLink(\n...     name=\"link_visual\",\n...     origin=Origin.zero_origin(),\n...     geometry=BoxGeometry(size=(1.0, 1.0, 1.0)),\n...     material=Material.from_color(\"red\", Colors.RED)\n... )\n&gt;&gt;&gt; visual.to_mjcf()\n&lt;Element 'visual' at 0x...&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/link.py</code> <pre><code>def to_mjcf(self, root: _Element) -&gt; None:\n    \"\"\"\n    Convert the visual properties to an MuJoCo compatible XML element.\n\n    Args:\n        root: The root element to append the visual properties to.\n\n    Returns:\n        The XML element representing the visual properties.\n\n    Examples:\n        &gt;&gt;&gt; visual = VisualLink(\n        ...     name=\"link_visual\",\n        ...     origin=Origin.zero_origin(),\n        ...     geometry=BoxGeometry(size=(1.0, 1.0, 1.0)),\n        ...     material=Material.from_color(\"red\", Colors.RED)\n        ... )\n        &gt;&gt;&gt; visual.to_mjcf()\n        &lt;Element 'visual' at 0x...&gt;\n    \"\"\"\n    visual = root if root.tag == \"geom\" else ET.SubElement(root, \"geom\")\n    if self.name:\n        visual.set(\"name\", self.name)\n    # TODO: Parent body uses visual origin, these share the same?\n    self.origin.to_mjcf(visual)\n\n    if self.geometry:\n        self.geometry.to_mjcf(visual)\n\n    self.material.to_mjcf(visual)\n\n    visual.set(\"conaffinity\", \"0\")\n    visual.set(\"condim\", \"1\")\n    visual.set(\"contype\", \"0\")\n    visual.set(\"density\", \"0\")\n    visual.set(\"group\", \"1\")\n</code></pre>"},{"location":"api/link/#onshape_robotics_toolkit.models.link.VisualLink.to_xml","title":"<code>to_xml(root=None)</code>","text":"<p>Convert the visual properties to an XML element.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>Optional[_Element]</code> <p>The root element to append the visual properties to.</p> <code>None</code> <p>Returns:</p> Type Description <code>_Element</code> <p>The XML element representing the visual properties.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; visual = VisualLink(\n...     name=\"link_visual\",\n...     origin=Origin.zero_origin(),\n...     geometry=BoxGeometry(size=(1.0, 1.0, 1.0)),\n...     material=Material.from_color(\"red\", Colors.RED)\n... )\n&gt;&gt;&gt; visual.to_xml()\n&lt;Element 'visual' at 0x...&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/link.py</code> <pre><code>def to_xml(self, root: Optional[_Element] = None) -&gt; _Element:\n    \"\"\"\n    Convert the visual properties to an XML element.\n\n    Args:\n        root: The root element to append the visual properties to.\n\n    Returns:\n        The XML element representing the visual properties.\n\n    Examples:\n        &gt;&gt;&gt; visual = VisualLink(\n        ...     name=\"link_visual\",\n        ...     origin=Origin.zero_origin(),\n        ...     geometry=BoxGeometry(size=(1.0, 1.0, 1.0)),\n        ...     material=Material.from_color(\"red\", Colors.RED)\n        ... )\n        &gt;&gt;&gt; visual.to_xml()\n        &lt;Element 'visual' at 0x...&gt;\n    \"\"\"\n    visual: _Element = ET.Element(\"visual\") if root is None else ET.SubElement(root, \"visual\")\n    if self.name:\n        visual.set(\"name\", self.name)\n    self.origin.to_xml(visual)\n    self.geometry.to_xml(visual)\n    self.material.to_xml(visual)\n    return visual\n</code></pre>"},{"location":"api/link/#onshape_robotics_toolkit.models.link.VisualLink.transform","title":"<code>transform(transformation_matrix)</code>","text":"<p>Apply a transformation to the visual link's origin.</p> <p>Parameters:</p> Name Type Description Default <code>transformation_matrix</code> <code>ndarray</code> <p>A 4x4 transformation matrix (homogeneous).</p> required Source code in <code>onshape_robotics_toolkit/models/link.py</code> <pre><code>def transform(self, transformation_matrix: np.ndarray) -&gt; None:\n    \"\"\"\n    Apply a transformation to the visual link's origin.\n\n    Args:\n        transformation_matrix (np.ndarray): A 4x4 transformation matrix (homogeneous).\n    \"\"\"\n    # Apply translation and rotation to the origin position\n    pos = np.array([self.origin.xyz[0], self.origin.xyz[1], self.origin.xyz[2], 1])\n    new_pos = transformation_matrix @ pos\n    self.origin.xyz = (float(new_pos[0]), float(new_pos[1]), float(new_pos[2]))  # Update position\n\n    # Extract the rotation from the transformation matrix\n    rotation_matrix = transformation_matrix[:3, :3]\n    current_rotation = R.from_euler(\"xyz\", self.origin.rpy)\n    new_rotation = R.from_matrix(rotation_matrix @ current_rotation.as_matrix())\n    euler_angles = new_rotation.as_euler(\"xyz\")\n    self.origin.rpy = (float(euler_angles[0]), float(euler_angles[1]), float(euler_angles[2]))\n</code></pre>"},{"location":"api/link/#onshape_robotics_toolkit.models.link.set_geometry_from_xml","title":"<code>set_geometry_from_xml(geometry)</code>","text":"<p>Set the geometry from an XML element.</p> <p>Parameters:</p> Name Type Description Default <code>geometry</code> <code>_Element</code> <p>The XML element to create the geometry from.</p> required <p>Returns:</p> Type Description <code>BaseGeometry | None</code> <p>The geometry created from the XML element.</p> Source code in <code>onshape_robotics_toolkit/models/link.py</code> <pre><code>def set_geometry_from_xml(geometry: _Element) -&gt; BaseGeometry | None:\n    \"\"\"\n    Set the geometry from an XML element.\n\n    Args:\n        geometry: The XML element to create the geometry from.\n\n    Returns:\n        The geometry created from the XML element.\n    \"\"\"\n    if geometry.find(\"mesh\") is not None:\n        return MeshGeometry.from_xml(geometry)\n    elif geometry.find(\"box\"):\n        return BoxGeometry.from_xml(geometry)\n    elif geometry.find(\"length\") and geometry.find(\"radius\"):\n        return CylinderGeometry.from_xml(geometry)\n    elif geometry.find(\"radius\"):\n        return SphereGeometry.from_xml(geometry)\n\n    return None\n</code></pre>"},{"location":"api/mass/","title":"Mass","text":"<p>This module defines data model for mass properties retrieved from Onshape REST API responses.</p> <p>The data models are implemented as Pydantic BaseModel classes, which are used to</p> <pre><code>1. Parse JSON responses from the API into Python objects.\n2. Validate the structure and types of the JSON responses.\n3. Provide type hints for better code clarity and autocompletion.\n</code></pre> <p>These models ensure that the data received from the API adheres to the expected format and types, facilitating easier and safer manipulation of the data within the application.</p> Models <ul> <li>PrincipalAxis: Represents the principal axis of a part or an entity.</li> <li>MassProperties: Represents the mass properties of a part or an entity.</li> </ul>"},{"location":"api/mass/#onshape_robotics_toolkit.models.mass.MassProperties","title":"<code>MassProperties</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents the mass properties of a part or an entity.</p> JSON <pre><code>    {\n        \"volume\" : [ 0.003411385108378978, 0.003410724395374695, 0.0034120458213832646 ],\n        \"periphery\" : [ 0.3551154530453107, 0.35506836484837767, 0.3551625412422433 ],\n        \"centroid\" : [ -2.07609188073475E-9, ... ],\n        \"inertia\" : [ 0.0994460593470721, ... ],\n        \"mass\" : [ 9.585992154544929, 9.584199206938452, 9.587785102151415 ],\n        \"hasMass\" : true,\n        \"massMissingCount\" : 0,\n        \"principalInertia\" : [ 0.09944605933465941, 0.09944605954654827, 0.19238058837442526 ],\n        \"principalAxes\" : [\n            {\n            \"x\" : -0.9702683926946019,\n            \"y\" : -5.514078101148926E-9,\n            \"z\" : -0.2420314982349062\n            }, {\n            \"x\" : -0.2420314982349062,\n            \"y\" : -5.44073563520025E-10,\n            \"z\" : 0.9702683926946021\n            }, {\n            \"x\" : 5.481818620570986E-9,\n            \"y\" : -0.9999999999999999,\n            \"z\" : 8.066832175421143E-10\n            }\n        ]\n    }\n</code></pre> <p>Attributes:</p> Name Type Description <code>volume</code> <code>list[float]</code> <p>The volume of the part.</p> <code>mass</code> <code>list[float]</code> <p>The mass of the part</p> <code>centroid</code> <code>list[float]</code> <p>The centroid of the part.</p> <code>inertia</code> <code>list[float]</code> <p>The inertia of the part.</p> <code>principalInertia</code> <code>list[float, float, float]</code> <p>The principal inertia of the part.</p> <code>principalAxes</code> <code>list[PrincipalAxis]</code> <p>The principal axes of the part.</p> Properties <p>principal_inertia: The principal inertia as a numpy array. center_of_mass: The center of mass as a tuple of three floats. inertia_matrix: The inertia matrix as a 3x3 numpy matrix. principal_axes: The principal axes as a 3x3 numpy matrix.</p> <p>Methods:</p> Name Description <code>principal_axes_wrt</code> <p>Returns the principal axes with respect to a given reference frame.</p> <code>inertia_wrt</code> <p>Returns the inertia matrix with respect to a given reference frame.</p> <code>center_of_mass_wrt</code> <p>Returns the center of mass with respect to a given reference frame.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; mass_properties = MassProperties(\n...     volume=[0.003411385108378978, 0.003410724395374695, 0.0034120458213832646],\n...     mass=[9.585992154544929, 9.584199206938452, 9.587785102151415],\n...     centroid=[...],\n...     inertia=[...],\n...     principalInertia=[0.09944605933465941, 0.09944605954654827, 0.19238058837442526],\n...     principalAxes=[...]\n... )\n&gt;&gt;&gt; mass_properties.principal_inertia\narray([0.09944606, 0.09944606, 0.19238059])\n</code></pre> <pre><code>&gt;&gt;&gt; mass_properties.center_of_mass_wrt(np.eye(4))\narray([0., 0., 0.])\n</code></pre> <pre><code>&gt;&gt;&gt; mass_properties.principal_axes_wrt(np.eye(3))\narray([0.09944605933465941, 0.09944605954654827, 0.19238058837442526])\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/mass.py</code> <pre><code>class MassProperties(BaseModel):\n    \"\"\"\n    Represents the mass properties of a part or an entity.\n\n    JSON:\n        ```json\n            {\n                \"volume\" : [ 0.003411385108378978, 0.003410724395374695, 0.0034120458213832646 ],\n                \"periphery\" : [ 0.3551154530453107, 0.35506836484837767, 0.3551625412422433 ],\n                \"centroid\" : [ -2.07609188073475E-9, ... ],\n                \"inertia\" : [ 0.0994460593470721, ... ],\n                \"mass\" : [ 9.585992154544929, 9.584199206938452, 9.587785102151415 ],\n                \"hasMass\" : true,\n                \"massMissingCount\" : 0,\n                \"principalInertia\" : [ 0.09944605933465941, 0.09944605954654827, 0.19238058837442526 ],\n                \"principalAxes\" : [\n                    {\n                    \"x\" : -0.9702683926946019,\n                    \"y\" : -5.514078101148926E-9,\n                    \"z\" : -0.2420314982349062\n                    }, {\n                    \"x\" : -0.2420314982349062,\n                    \"y\" : -5.44073563520025E-10,\n                    \"z\" : 0.9702683926946021\n                    }, {\n                    \"x\" : 5.481818620570986E-9,\n                    \"y\" : -0.9999999999999999,\n                    \"z\" : 8.066832175421143E-10\n                    }\n                ]\n            }\n        ```\n\n    Attributes:\n        volume (list[float]): The volume of the part.\n        mass (list[float]): The mass of the part\n        centroid (list[float]): The centroid of the part.\n        inertia (list[float]): The inertia of the part.\n        principalInertia (list[float, float, float]): The principal inertia of the part.\n        principalAxes (list[PrincipalAxis]): The principal axes of the part.\n\n    Properties:\n        principal_inertia: The principal inertia as a numpy array.\n        center_of_mass: The center of mass as a tuple of three floats.\n        inertia_matrix: The inertia matrix as a 3x3 numpy matrix.\n        principal_axes: The principal axes as a 3x3 numpy matrix.\n\n    Methods:\n        principal_axes_wrt: Returns the principal axes with respect to a given reference frame.\n        inertia_wrt: Returns the inertia matrix with respect to a given reference frame.\n        center_of_mass_wrt: Returns the center of mass with respect to a given reference frame.\n\n    Examples:\n        &gt;&gt;&gt; mass_properties = MassProperties(\n        ...     volume=[0.003411385108378978, 0.003410724395374695, 0.0034120458213832646],\n        ...     mass=[9.585992154544929, 9.584199206938452, 9.587785102151415],\n        ...     centroid=[...],\n        ...     inertia=[...],\n        ...     principalInertia=[0.09944605933465941, 0.09944605954654827, 0.19238058837442526],\n        ...     principalAxes=[...]\n        ... )\n        &gt;&gt;&gt; mass_properties.principal_inertia\n        array([0.09944606, 0.09944606, 0.19238059])\n\n        &gt;&gt;&gt; mass_properties.center_of_mass_wrt(np.eye(4))\n        array([0., 0., 0.])\n\n        &gt;&gt;&gt; mass_properties.principal_axes_wrt(np.eye(3))\n        array([0.09944605933465941, 0.09944605954654827, 0.19238058837442526])\n    \"\"\"\n\n    volume: list[float] = Field(..., description=\"The volume of the part.\")\n    mass: list[float] = Field(..., description=\"The mass of the part.\")\n    centroid: list[float] = Field(..., description=\"The centroid of the part.\")\n    inertia: list[float] = Field(..., description=\"The inertia of the part.\")\n    principalInertia: list[float] = Field(..., description=\"The principal inertia of the part.\")\n    principalAxes: list[PrincipalAxis] = Field(..., description=\"The principal axes of the part.\")\n\n    @field_validator(\"principalAxes\")\n    def check_principal_axes(cls, v: list[PrincipalAxis]) -&gt; list[PrincipalAxis]:\n        \"\"\"\n        Validate the principal axes to ensure they have 3 elements.\n\n        Args:\n            v: The principal axes to validate.\n\n        Returns:\n            The validated principal axes.\n\n        Raises:\n            ValueError: If the principal axes do not have 3 elements.\n        \"\"\"\n        if len(v) != 3:\n            raise ValueError(\"Principal axes must have 3 elements\")\n        return v\n\n    @property\n    def principal_inertia(self) -&gt; np.ndarray:\n        \"\"\"\n        Returns the principal inertia as a numpy array.\n\n        Returns:\n            The principal inertia.\n        \"\"\"\n        return np.array(self.principalInertia)\n\n    @property\n    def center_of_mass(self) -&gt; tuple[float, float, float]:\n        \"\"\"\n        Returns the center of mass as a tuple of three floats.\n\n        Returns:\n            The center of mass.\n        \"\"\"\n        return (self.centroid[0], self.centroid[1], self.centroid[2])\n\n    @property\n    def inertia_matrix(self) -&gt; np.matrix:\n        \"\"\"\n        Returns the inertia matrix as a 3x3 numpy matrix.\n\n        Returns:\n            The inertia matrix.\n        \"\"\"\n        return np.matrix(np.array(self.inertia[:9]).reshape(3, 3))\n\n    @property\n    def principal_axes(self) -&gt; np.matrix:\n        \"\"\"\n        Returns the principal axes as a 3x3 numpy matrix.\n\n        Returns:\n            The principal axes.\n        \"\"\"\n        return np.matrix(np.array([axis.values for axis in self.principalAxes]))\n\n    def principal_axes_wrt(self, reference: np.matrix) -&gt; np.matrix:\n        \"\"\"\n        Returns the principal axes with respect to a given reference frame.\n\n        Args:\n            reference: The reference frame as a 3x3 matrix.\n\n        Returns:\n            The principal axes with respect to the reference frame.\n\n        Raises:\n            ValueError: If the reference frame is not a 3x3 matrix.\n\n        Examples:\n            &gt;&gt;&gt; mass_properties.principal_axes_wrt(np.eye(3))\n            array([0.09944605933465941, 0.09944605954654827, 0.19238058837442526])\n        \"\"\"\n        if reference.shape != (3, 3):\n            raise ValueError(\"Reference frame must be a 3x3 matrix\")\n\n        result = reference @ self.principal_axes\n        return cast(np.matrix, result)\n\n    def inertia_wrt(self, reference: np.matrix) -&gt; np.matrix:\n        \"\"\"\n        Returns the inertia matrix with respect to a given reference frame.\n\n        Args:\n            reference: The reference frame as a 3x3 matrix.\n\n        Returns:\n            The inertia matrix with respect to the reference frame.\n\n        Raises:\n            ValueError: If the reference frame is not a 3x3 matrix.\n\n        Examples:\n            &gt;&gt;&gt; mass_properties.inertia_wrt(np.eye(3))\n            array([0.09944605933465941, 0.09944605954654827, 0.19238058837442526])\n        \"\"\"\n        if reference.shape != (3, 3):\n            raise ValueError(\"Reference frame must be a 3x3 matrix\")\n\n        result = reference @ self.inertia_matrix @ reference.T\n        return cast(np.matrix, result)\n\n    def center_of_mass_wrt(self, reference: np.matrix) -&gt; np.ndarray:\n        \"\"\"\n        Returns the center of mass with respect to a given reference frame.\n\n        Args:\n            reference: The reference frame as a 4x4 matrix.\n\n        Returns:\n            The center of mass with respect to the reference frame.\n\n        Raises:\n            ValueError: If the reference frame is not a 4x4 matrix.\n\n        Examples:\n            &gt;&gt;&gt; mass_properties.center_of_mass_wrt(np.eye(4))\n            array([0., 0., 0.])\n        \"\"\"\n        if reference.shape != (4, 4):\n            raise ValueError(\"Reference frame must be a 4x4 matrix\")\n\n        com = np.matrix([*list(self.center_of_mass), 1.0])\n        com_wrt = (reference * com.T)[:3]\n        return np.array([com_wrt[0, 0], com_wrt[1, 0], com_wrt[2, 0]])\n</code></pre>"},{"location":"api/mass/#onshape_robotics_toolkit.models.mass.MassProperties.center_of_mass","title":"<code>center_of_mass</code>  <code>property</code>","text":"<p>Returns the center of mass as a tuple of three floats.</p> <p>Returns:</p> Type Description <code>tuple[float, float, float]</code> <p>The center of mass.</p>"},{"location":"api/mass/#onshape_robotics_toolkit.models.mass.MassProperties.inertia_matrix","title":"<code>inertia_matrix</code>  <code>property</code>","text":"<p>Returns the inertia matrix as a 3x3 numpy matrix.</p> <p>Returns:</p> Type Description <code>matrix</code> <p>The inertia matrix.</p>"},{"location":"api/mass/#onshape_robotics_toolkit.models.mass.MassProperties.principal_axes","title":"<code>principal_axes</code>  <code>property</code>","text":"<p>Returns the principal axes as a 3x3 numpy matrix.</p> <p>Returns:</p> Type Description <code>matrix</code> <p>The principal axes.</p>"},{"location":"api/mass/#onshape_robotics_toolkit.models.mass.MassProperties.principal_inertia","title":"<code>principal_inertia</code>  <code>property</code>","text":"<p>Returns the principal inertia as a numpy array.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>The principal inertia.</p>"},{"location":"api/mass/#onshape_robotics_toolkit.models.mass.MassProperties.center_of_mass_wrt","title":"<code>center_of_mass_wrt(reference)</code>","text":"<p>Returns the center of mass with respect to a given reference frame.</p> <p>Parameters:</p> Name Type Description Default <code>reference</code> <code>matrix</code> <p>The reference frame as a 4x4 matrix.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The center of mass with respect to the reference frame.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the reference frame is not a 4x4 matrix.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; mass_properties.center_of_mass_wrt(np.eye(4))\narray([0., 0., 0.])\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/mass.py</code> <pre><code>def center_of_mass_wrt(self, reference: np.matrix) -&gt; np.ndarray:\n    \"\"\"\n    Returns the center of mass with respect to a given reference frame.\n\n    Args:\n        reference: The reference frame as a 4x4 matrix.\n\n    Returns:\n        The center of mass with respect to the reference frame.\n\n    Raises:\n        ValueError: If the reference frame is not a 4x4 matrix.\n\n    Examples:\n        &gt;&gt;&gt; mass_properties.center_of_mass_wrt(np.eye(4))\n        array([0., 0., 0.])\n    \"\"\"\n    if reference.shape != (4, 4):\n        raise ValueError(\"Reference frame must be a 4x4 matrix\")\n\n    com = np.matrix([*list(self.center_of_mass), 1.0])\n    com_wrt = (reference * com.T)[:3]\n    return np.array([com_wrt[0, 0], com_wrt[1, 0], com_wrt[2, 0]])\n</code></pre>"},{"location":"api/mass/#onshape_robotics_toolkit.models.mass.MassProperties.check_principal_axes","title":"<code>check_principal_axes(v)</code>","text":"<p>Validate the principal axes to ensure they have 3 elements.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>list[PrincipalAxis]</code> <p>The principal axes to validate.</p> required <p>Returns:</p> Type Description <code>list[PrincipalAxis]</code> <p>The validated principal axes.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the principal axes do not have 3 elements.</p> Source code in <code>onshape_robotics_toolkit/models/mass.py</code> <pre><code>@field_validator(\"principalAxes\")\ndef check_principal_axes(cls, v: list[PrincipalAxis]) -&gt; list[PrincipalAxis]:\n    \"\"\"\n    Validate the principal axes to ensure they have 3 elements.\n\n    Args:\n        v: The principal axes to validate.\n\n    Returns:\n        The validated principal axes.\n\n    Raises:\n        ValueError: If the principal axes do not have 3 elements.\n    \"\"\"\n    if len(v) != 3:\n        raise ValueError(\"Principal axes must have 3 elements\")\n    return v\n</code></pre>"},{"location":"api/mass/#onshape_robotics_toolkit.models.mass.MassProperties.inertia_wrt","title":"<code>inertia_wrt(reference)</code>","text":"<p>Returns the inertia matrix with respect to a given reference frame.</p> <p>Parameters:</p> Name Type Description Default <code>reference</code> <code>matrix</code> <p>The reference frame as a 3x3 matrix.</p> required <p>Returns:</p> Type Description <code>matrix</code> <p>The inertia matrix with respect to the reference frame.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the reference frame is not a 3x3 matrix.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; mass_properties.inertia_wrt(np.eye(3))\narray([0.09944605933465941, 0.09944605954654827, 0.19238058837442526])\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/mass.py</code> <pre><code>def inertia_wrt(self, reference: np.matrix) -&gt; np.matrix:\n    \"\"\"\n    Returns the inertia matrix with respect to a given reference frame.\n\n    Args:\n        reference: The reference frame as a 3x3 matrix.\n\n    Returns:\n        The inertia matrix with respect to the reference frame.\n\n    Raises:\n        ValueError: If the reference frame is not a 3x3 matrix.\n\n    Examples:\n        &gt;&gt;&gt; mass_properties.inertia_wrt(np.eye(3))\n        array([0.09944605933465941, 0.09944605954654827, 0.19238058837442526])\n    \"\"\"\n    if reference.shape != (3, 3):\n        raise ValueError(\"Reference frame must be a 3x3 matrix\")\n\n    result = reference @ self.inertia_matrix @ reference.T\n    return cast(np.matrix, result)\n</code></pre>"},{"location":"api/mass/#onshape_robotics_toolkit.models.mass.MassProperties.principal_axes_wrt","title":"<code>principal_axes_wrt(reference)</code>","text":"<p>Returns the principal axes with respect to a given reference frame.</p> <p>Parameters:</p> Name Type Description Default <code>reference</code> <code>matrix</code> <p>The reference frame as a 3x3 matrix.</p> required <p>Returns:</p> Type Description <code>matrix</code> <p>The principal axes with respect to the reference frame.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the reference frame is not a 3x3 matrix.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; mass_properties.principal_axes_wrt(np.eye(3))\narray([0.09944605933465941, 0.09944605954654827, 0.19238058837442526])\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/mass.py</code> <pre><code>def principal_axes_wrt(self, reference: np.matrix) -&gt; np.matrix:\n    \"\"\"\n    Returns the principal axes with respect to a given reference frame.\n\n    Args:\n        reference: The reference frame as a 3x3 matrix.\n\n    Returns:\n        The principal axes with respect to the reference frame.\n\n    Raises:\n        ValueError: If the reference frame is not a 3x3 matrix.\n\n    Examples:\n        &gt;&gt;&gt; mass_properties.principal_axes_wrt(np.eye(3))\n        array([0.09944605933465941, 0.09944605954654827, 0.19238058837442526])\n    \"\"\"\n    if reference.shape != (3, 3):\n        raise ValueError(\"Reference frame must be a 3x3 matrix\")\n\n    result = reference @ self.principal_axes\n    return cast(np.matrix, result)\n</code></pre>"},{"location":"api/mass/#onshape_robotics_toolkit.models.mass.PrincipalAxis","title":"<code>PrincipalAxis</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents the principal axis of a part or an entity.</p> JSON <pre><code>    {\n        \"x\" : 5.481818620570986E-9,\n        \"y\" : -0.9999999999999999,\n        \"z\" : 8.066832175421143E-10\n    }\n</code></pre> <p>Attributes:</p> Name Type Description <code>x</code> <code>float</code> <p>The x-component of the principal axis.</p> <code>y</code> <code>float</code> <p>The y-component of the principal axis.</p> <code>z</code> <code>float</code> <p>The z-component of the principal axis.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; axis = PrincipalAxis(x=0.0, y=0.0, z=1.0)\n&gt;&gt;&gt; axis.values\narray([0., 0., 1.])\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/mass.py</code> <pre><code>class PrincipalAxis(BaseModel):\n    \"\"\"\n    Represents the principal axis of a part or an entity.\n\n    JSON:\n        ```json\n            {\n                \"x\" : 5.481818620570986E-9,\n                \"y\" : -0.9999999999999999,\n                \"z\" : 8.066832175421143E-10\n            }\n        ```\n\n    Attributes:\n        x (float): The x-component of the principal axis.\n        y (float): The y-component of the principal axis.\n        z (float): The z-component of the principal axis.\n\n    Examples:\n        &gt;&gt;&gt; axis = PrincipalAxis(x=0.0, y=0.0, z=1.0)\n        &gt;&gt;&gt; axis.values\n        array([0., 0., 1.])\n\n    \"\"\"\n\n    x: float = Field(..., description=\"The x-component of the principal axis.\")\n    y: float = Field(..., description=\"The y-component of the principal axis.\")\n    z: float = Field(..., description=\"The z-component of the principal axis.\")\n\n    @property\n    def values(self) -&gt; np.ndarray:\n        return np.array([self.x, self.y, self.z])\n</code></pre>"},{"location":"api/mesh/","title":"Mesh","text":"<p>This module contains functions for transforming meshes and inertia matrices.</p>"},{"location":"api/mesh/#onshape_robotics_toolkit.mesh.transform_inertia_matrix","title":"<code>transform_inertia_matrix(inertia_matrix, rotation)</code>","text":"<p>Transform an inertia matrix</p> <p>Parameters:</p> Name Type Description Default <code>inertia_matrix</code> <code>NDArray[floating]</code> <p>Inertia matrix to use for transformation</p> required <code>rotation</code> <code>NDArray[floating]</code> <p>Rotation matrix to apply to the inertia matrix</p> required <p>Returns:</p> Type Description <code>NDArray[floating]</code> <p>Transformed inertia matrix</p> Source code in <code>onshape_robotics_toolkit/mesh.py</code> <pre><code>def transform_inertia_matrix(\n    inertia_matrix: NDArray[np.floating], rotation: NDArray[np.floating]\n) -&gt; NDArray[np.floating]:\n    \"\"\"\n    Transform an inertia matrix\n\n    Args:\n        inertia_matrix: Inertia matrix to use for transformation\n        rotation: Rotation matrix to apply to the inertia matrix\n\n    Returns:\n        Transformed inertia matrix\n    \"\"\"\n\n    result: NDArray[np.floating] = rotation @ inertia_matrix @ rotation.T\n    return result\n</code></pre>"},{"location":"api/mesh/#onshape_robotics_toolkit.mesh.transform_mesh","title":"<code>transform_mesh(mesh, transform)</code>","text":"<p>Apply a transformation matrix to an STL mesh.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>STL mesh to use for transformation</p> required <code>transform</code> <code>ndarray</code> <p>Transformation matrix to apply to the mesh</p> required <p>Returns:</p> Type Description <code>Mesh</code> <p>Transformed STL mesh</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; mesh = Mesh.from_file(\"mesh.stl\")\n&gt;&gt;&gt; transform = np.eye(4)\n&gt;&gt;&gt; transform_mesh(mesh, transform)\n</code></pre> Source code in <code>onshape_robotics_toolkit/mesh.py</code> <pre><code>def transform_mesh(mesh: Mesh, transform: np.ndarray) -&gt; Mesh:\n    \"\"\"\n    Apply a transformation matrix to an STL mesh.\n\n    Args:\n        mesh: STL mesh to use for transformation\n        transform: Transformation matrix to apply to the mesh\n\n    Returns:\n        Transformed STL mesh\n\n    Examples:\n        &gt;&gt;&gt; mesh = Mesh.from_file(\"mesh.stl\")\n        &gt;&gt;&gt; transform = np.eye(4)\n        &gt;&gt;&gt; transform_mesh(mesh, transform)\n    \"\"\"\n\n    _transform_vectors = partial(\n        transform_vectors, rotation=transform[:3, :3], translation=transform[0:3, 3:4].T.tolist()\n    )\n\n    mesh.v0 = _transform_vectors(mesh.v0)\n    mesh.v1 = _transform_vectors(mesh.v1)\n    mesh.v2 = _transform_vectors(mesh.v2)\n    mesh.normals = _transform_vectors(mesh.normals)\n\n    return mesh\n</code></pre>"},{"location":"api/mesh/#onshape_robotics_toolkit.mesh.transform_vectors","title":"<code>transform_vectors(vectors, rotation, translation)</code>","text":"<p>Apply a transformation matrix to a set of vectors.</p> <p>Parameters:</p> Name Type Description Default <code>vectors</code> <code>NDArray[floating]</code> <p>Array of vectors to use for transformation</p> required <code>rotation</code> <code>NDArray[floating]</code> <p>Rotation matrix to apply to the vectors</p> required <code>translation</code> <code>NDArray[floating]</code> <p>Translation matrix to apply to the vectors</p> required <p>Returns:</p> Type Description <code>NDArray[floating]</code> <p>Array of transformed vectors</p> Source code in <code>onshape_robotics_toolkit/mesh.py</code> <pre><code>def transform_vectors(\n    vectors: NDArray[np.floating], rotation: NDArray[np.floating], translation: NDArray[np.floating]\n) -&gt; NDArray[np.floating]:\n    \"\"\"\n    Apply a transformation matrix to a set of vectors.\n\n    Args:\n        vectors: Array of vectors to use for transformation\n        rotation: Rotation matrix to apply to the vectors\n        translation: Translation matrix to apply to the vectors\n\n    Returns:\n        Array of transformed vectors\n    \"\"\"\n\n    result: NDArray[np.floating] = np.dot(vectors, rotation.T) + translation * len(vectors)\n    return result\n</code></pre>"},{"location":"api/parse/","title":"Parse","text":"<p>This module contains functions that provide a way to traverse the assembly structure, extract information about parts, subassemblies, instances, and mates, and generate a hierarchical representation of the assembly.</p>"},{"location":"api/parse/#onshape_robotics_toolkit.parse.CAD","title":"<code>CAD</code>  <code>dataclass</code>","text":"<p>Streamlined CAD document with flat dict-based storage.</p> <p>All data is stored in simple dicts keyed by PathKey for O(1) lookup. No nested registries, no duplicate storage, single source of truth.</p> <p>This structure maps to Onshape's assembly JSON schema but flattens the hierarchy for easier access: {   \"parts\": [...],                    -&gt; parts (populated eagerly, mass props None)   \"rootAssembly\": {     \"instances\": [...],              -&gt; instances (flattened)     \"occurrences\": [...],            -&gt; occurrences (flattened)     \"features\": [...],               -&gt; mates (with assembly provenance)     \"patterns\": [...]                -&gt; patterns (flattened)   },   \"subAssemblies\": [...]             -&gt; data merged into root dicts }</p> <p>Attributes:</p> Name Type Description <code>document_id</code> <code>str</code> <p>Onshape document ID</p> <code>element_id</code> <code>str</code> <p>Onshape element (assembly) ID</p> <code>workspace_id</code> <code>str</code> <p>Onshape workspace ID</p> <code>document_microversion</code> <code>str</code> <p>Onshape document microversion</p> <code>max_depth</code> <code>int</code> <p>Maximum depth for flexible assemblies (0 = all rigid)</p> <code>keys_by_id</code> <code>dict[tuple[str, ...], PathKey]</code> <p>Canonical PathKey index by ID (ID path tuple \u2192 PathKey)</p> <code>keys_by_name</code> <code>dict[tuple[str, ...], PathKey]</code> <p>Reverse PathKey index by name (name path tuple \u2192 PathKey)</p> <code>instances</code> <code>dict[PathKey, Union[PartInstance, AssemblyInstance]]</code> <p>All instances (parts AND assemblies) from root + subassemblies</p> <code>occurrences</code> <code>dict[PathKey, Occurrence]</code> <p>All occurrence transforms from root + subassemblies</p> <code>mates</code> <code>dict[tuple[Optional[PathKey], PathKey, PathKey], MateFeatureData]</code> <p>All mate relationships with assembly provenance    Key = (assembly_key, parent_key, child_key)    - assembly_key: None for root, PathKey for subassembly    - parent_key, child_key: absolute PathKeys</p> <code>patterns</code> <code>dict[str, Pattern]</code> <p>All pattern definitions from root + subassemblies</p> <code>parts</code> <code>dict[PathKey, Part]</code> <p>Part definitions from assembly.parts (mass properties None until fetched)</p> <code>fetched_subassemblies</code> <code>dict[PathKey, Part]</code> <p>Recursively fetched subassembly CAD documents</p> Source code in <code>onshape_robotics_toolkit/parse.py</code> <pre><code>@dataclass\nclass CAD:\n    \"\"\"\n    Streamlined CAD document with flat dict-based storage.\n\n    All data is stored in simple dicts keyed by PathKey for O(1) lookup.\n    No nested registries, no duplicate storage, single source of truth.\n\n    This structure maps to Onshape's assembly JSON schema but flattens\n    the hierarchy for easier access:\n    {\n      \"parts\": [...],                    -&gt; parts (populated eagerly, mass props None)\n      \"rootAssembly\": {\n        \"instances\": [...],              -&gt; instances (flattened)\n        \"occurrences\": [...],            -&gt; occurrences (flattened)\n        \"features\": [...],               -&gt; mates (with assembly provenance)\n        \"patterns\": [...]                -&gt; patterns (flattened)\n      },\n      \"subAssemblies\": [...]             -&gt; data merged into root dicts\n    }\n\n    Attributes:\n        document_id: Onshape document ID\n        element_id: Onshape element (assembly) ID\n        workspace_id: Onshape workspace ID\n        document_microversion: Onshape document microversion\n        max_depth: Maximum depth for flexible assemblies (0 = all rigid)\n        keys_by_id: Canonical PathKey index by ID (ID path tuple \u2192 PathKey)\n        keys_by_name: Reverse PathKey index by name (name path tuple \u2192 PathKey)\n        instances: All instances (parts AND assemblies) from root + subassemblies\n        occurrences: All occurrence transforms from root + subassemblies\n        mates: All mate relationships with assembly provenance\n               Key = (assembly_key, parent_key, child_key)\n               - assembly_key: None for root, PathKey for subassembly\n               - parent_key, child_key: absolute PathKeys\n        patterns: All pattern definitions from root + subassemblies\n        parts: Part definitions from assembly.parts (mass properties None until fetched)\n        fetched_subassemblies: Recursively fetched subassembly CAD documents\n    \"\"\"\n\n    # Document metadata\n    document_id: str\n    element_id: str\n    wtype: str\n    workspace_id: str\n    document_microversion: str\n    name: Optional[str]\n    max_depth: int\n\n    # Core data (flat dicts with absolute PathKeys)\n    keys_by_id: dict[tuple[str, ...], PathKey]  # ID path tuple -&gt; PathKey (canonical index)\n    keys_by_name: dict[tuple[str, ...], PathKey]  # Name path tuple -&gt; PathKey (reverse index)\n    instances: dict[PathKey, Union[PartInstance, AssemblyInstance]]\n    occurrences: dict[PathKey, Occurrence]\n    subassemblies: dict[PathKey, SubAssembly]\n    mates: dict[tuple[Optional[PathKey], PathKey, PathKey], MateFeatureData]  # (assembly, parent, child)\n    patterns: dict[str, Pattern]\n    parts: dict[PathKey, Part]  # Populated eagerly from assembly.parts\n\n    def __init__(\n        self,\n        document_id: str,\n        element_id: str,\n        wtype: str,\n        workspace_id: str,\n        document_microversion: str,\n        name: Optional[str] = \"cad\",\n        max_depth: int = 0,\n        client: Optional[Client] = None,\n    ):\n        \"\"\"\n        Initialize an empty CAD document.\n\n        Args:\n            document_id: Onshape document ID\n            element_id: Onshape element (assembly) ID\n            wtype: Workspace type of the document\n            workspace_id: Onshape workspace ID\n            document_microversion: Onshape document microversion\n            name: name of the Onshape document (not element)\n            max_depth: Maximum depth for flexible assemblies\n        \"\"\"\n        self.document_id = document_id\n        self.element_id = element_id\n        self.wtype = wtype\n        self.workspace_id = workspace_id\n        self.document_microversion = document_microversion\n        self.name = name\n        self.max_depth = max_depth\n\n        # Initialize empty dicts\n        self.keys_by_id = {}\n        self.keys_by_name = {}\n        self.instances = {}\n        self.occurrences = {}\n        self.mates = {}\n        self.patterns = {}\n        self.parts = {}\n        self.subassemblies = {}\n\n        self._client = client\n\n    def get_path_key(self, path: Union[str, list[str], tuple[str, ...]]) -&gt; Optional[PathKey]:\n        \"\"\"\n        Get PathKey from an ID path.\n\n        Args:\n            path: Instance ID (string) or path (list/tuple of IDs)\n\n        Returns:\n            PathKey if found, None otherwise\n\n        Examples:\n            # From single ID\n            key = cad.get_path_key(\"M123\")\n\n            # From path list\n            key = cad.get_path_key([\"M123\", \"M456\"])\n\n            # From path tuple\n            key = cad.get_path_key((\"M123\", \"M456\"))\n        \"\"\"\n        path_tuple = (path,) if isinstance(path, str) else tuple(path)\n        return self.keys_by_id.get(path_tuple)\n\n    def get_path_key_by_name(self, name_path: Union[str, list[str], tuple[str, ...]]) -&gt; Optional[PathKey]:\n        \"\"\"\n        Get PathKey from a name path (reverse lookup).\n\n        Args:\n            name_path: Instance name (string) or name path (list/tuple of names)\n\n        Returns:\n            PathKey if found, None otherwise\n\n        Examples:\n            # From single name\n            key = cad.get_path_key_by_name(\"wheel_1\")\n\n            # From name path list\n            key = cad.get_path_key_by_name([\"Assembly_1\", \"Part_1\"])\n\n            # From name path tuple\n            key = cad.get_path_key_by_name((\"Assembly_1\", \"Part_1\"))\n        \"\"\"\n        name_tuple = (name_path,) if isinstance(name_path, str) else tuple(name_path)\n        return self.keys_by_name.get(name_tuple)\n\n    def is_rigid_assembly(self, key: PathKey) -&gt; bool:\n        \"\"\"Check if instance is a rigid assembly.\"\"\"\n        # TODO: this should come out of subassemblies dict\n        instance = self.instances.get(key)\n        return isinstance(instance, AssemblyInstance) and instance.isRigid\n\n    def is_flexible_assembly(self, key: PathKey) -&gt; bool:\n        \"\"\"Check if instance is a flexible assembly.\"\"\"\n        # TODO: this should come out of subassemblies dict\n        instance = self.instances.get(key)\n        return isinstance(instance, AssemblyInstance) and not instance.isRigid\n\n    def is_part(self, key: PathKey) -&gt; bool:\n        \"\"\"Check if instance is a part.\"\"\"\n        # TODO: this should come out of parts dict w/ regard to rigid subassemblies\n        return isinstance(self.instances.get(key), PartInstance)\n\n    def get_transform(self, key: PathKey, wrt: Optional[np.ndarray] = None) -&gt; Optional[np.ndarray]:\n        \"\"\"Get 4x4 transform matrix for occurrence.\"\"\"\n        occ = self.occurrences.get(key)\n\n        if occ:\n            if wrt is not None:\n                return occ.tf_wrt(wrt)\n            else:\n                return occ.tf\n        return None\n\n    def get_rigid_assembly_root(self, key: PathKey) -&gt; Optional[PathKey]:\n        \"\"\"\n        Find the top-most rigid assembly root for a given PathKey.\n\n        Walks up the hierarchy to find the highest-level rigid assembly.\n        This ensures that if an assembly is inside another rigid assembly,\n        we return the outermost one.\n\n        If the key itself is a rigid assembly, checks if it's inside another rigid assembly.\n        If the key is inside a rigid assembly, returns the top-most rigid assembly's PathKey.\n        If the key is not inside any rigid assembly, returns None.\n\n        Args:\n            key: PathKey to find rigid assembly root for\n\n        Returns:\n            PathKey of top-most rigid assembly root, or None if not inside rigid assembly\n\n        Examples:\n            &gt;&gt;&gt; # Part at depth 2 inside rigid assembly at depth 1\n            &gt;&gt;&gt; key = PathKey((\"asm1\", \"sub1\", \"part1\"), (\"Assembly_1\", \"Sub_1\", \"Part_1\"))\n            &gt;&gt;&gt; rigid_root = cad.get_rigid_assembly_root(key)\n            &gt;&gt;&gt; # Returns PathKey((\"asm1\", \"sub1\"), (\"Assembly_1\", \"Sub_1\"))\n        \"\"\"\n        # Walk up the hierarchy from the key to find ALL rigid assemblies\n        # Return the top-most one (closest to root)\n        rigid_root: Optional[PathKey] = None\n        current: Optional[PathKey] = key\n\n        while current is not None:\n            instance = self.instances.get(current)\n            if isinstance(instance, AssemblyInstance) and instance.isRigid:\n                rigid_root = current  # Keep updating to get the top-most\n            current = current.parent\n\n        return rigid_root\n\n    def get_mates_from_root(self) -&gt; dict[tuple[PathKey, PathKey], MateFeatureData]:\n        \"\"\"\n        Get only root-level mates (no assembly provenance).\n\n        Returns:\n            Dictionary with (parent, child) keys\n        \"\"\"\n        return {(p, c): mate for (asm, p, c), mate in self.mates.items() if asm is None}\n\n    def get_mates_from_subassembly(self, sub_key: PathKey) -&gt; dict[tuple[PathKey, PathKey], MateFeatureData]:\n        \"\"\"\n        Get mates from specific subassembly.\n\n        Args:\n            sub_key: PathKey of the subassembly\n\n        Returns:\n            Dictionary with (parent, child) keys\n        \"\"\"\n        return {(p, c): mate for (asm, p, c), mate in self.mates.items() if asm == sub_key}\n\n    def get_all_mates_flattened(self) -&gt; dict[tuple[PathKey, PathKey], MateFeatureData]:\n        \"\"\"\n        Get all mates without assembly provenance (backward compatible).\n\n        If there are duplicate (parent, child) pairs from different assemblies,\n        this will only keep one (last one wins).\n\n        Returns:\n            Dictionary with (parent, child) keys\n        \"\"\"\n        return {(p, c): mate for (asm, p, c), mate in self.mates.items()}\n\n    def get_mate_data(\n        self, parent: PathKey, child: PathKey, assembly: Optional[PathKey] = None\n    ) -&gt; Optional[MateFeatureData]:\n        \"\"\"\n        Get mate data for specific parent-child pair.\n\n        Args:\n            parent: Parent PathKey\n            child: Child PathKey\n            assembly: Assembly PathKey (None for root, PathKey for subassembly)\n                     If None, searches all assemblies (root first)\n\n        Returns:\n            MateFeatureData if found, None otherwise\n        \"\"\"\n        if assembly is not None:\n            return self.mates.get((assembly, parent, child))\n        else:\n            mate = self.mates.get((None, parent, child))\n            if mate:\n                return mate\n\n            for (_asm, p, c), mate in self.mates.items():\n                if p == parent and c == child:\n                    return mate\n            return None\n\n    def get_mate_assembly(self, parent: PathKey, child: PathKey) -&gt; Optional[Optional[PathKey]]:\n        \"\"\"\n        Find which assembly contains this mate.\n\n        Args:\n            parent: Parent PathKey\n            child: Child PathKey\n\n        Returns:\n            None if root assembly, PathKey if subassembly, None if not found\n        \"\"\"\n        for asm, p, c in self.mates:\n            if p == parent and c == child:\n                return asm  # Returns None for root, PathKey for subassembly\n        return None\n\n    def estimate_api_calls(\n        self,\n        fetch_mass_properties: bool = True,\n        fetch_mate_properties: bool = True,\n        download_meshes: bool = True,\n    ) -&gt; dict[str, int]:\n        \"\"\"\n        Estimate the number of REMAINING API calls needed to process this CAD assembly.\n\n        This method analyzes the parsed assembly structure and calculates how many\n        additional API calls will be required to fetch mass properties and download meshes.\n\n        Note: This does NOT include the initial get_assembly() call that was already\n        made to create this CAD object.\n\n        Args:\n            fetch_mass_properties: Whether mass properties will be fetched\n            download_meshes: Whether mesh files will be downloaded\n\n        Returns:\n            Dictionary containing breakdown of estimated REMAINING API calls:\n                - 'subassemblies': Calls for fetching rigid subassembly data\n                - 'mass_properties': Calls for fetching mass properties\n                - 'meshes': Calls for downloading mesh files\n                - 'total': Total estimated REMAINING API calls\n\n        Examples:\n            &gt;&gt;&gt; cad = CAD.from_assembly(assembly, max_depth=1)\n            &gt;&gt;&gt; estimation = cad.estimate_api_calls(\n            ...     fetch_mass_properties=True,\n            ...     download_meshes=True\n            ... )\n            &gt;&gt;&gt; print(f\"Estimated remaining API calls: {estimation['total']}\")\n            Estimated remaining API calls: 24\n        \"\"\"\n        num_kinematic_parts = sum(\n            1 for key, part in self.parts.items() if part.rigidAssemblyToPartTF is None and not part.isRigidAssembly\n        )\n\n        num_rigid_subassemblies = sum(1 for key, sub in self.subassemblies.items() if sub.isRigid)\n\n        # Each rigid subassembly needs get_root_assembly to fetch occurrence data\n        subassembly_calls = num_rigid_subassemblies\n\n        mass_property_calls = 0\n        if fetch_mass_properties:\n            mass_property_calls = num_kinematic_parts + num_rigid_subassemblies\n\n        mate_property_calls = 0\n        if fetch_mate_properties:\n            mate_property_calls = 1 + len(self.subassemblies) - num_rigid_subassemblies\n\n        mesh_download_calls = 0\n        if download_meshes:\n            mesh_download_calls = num_kinematic_parts + num_rigid_subassemblies\n\n        total_calls = subassembly_calls + mass_property_calls + mesh_download_calls + mate_property_calls\n\n        return {\n            \"subassemblies\": subassembly_calls,\n            \"mass_properties\": mass_property_calls,\n            \"mate_properties\": mate_property_calls,\n            \"meshes\": mesh_download_calls,\n            \"total\": total_calls,\n        }\n\n    def __repr__(self) -&gt; str:\n        # TODO: would be nice to have the CAD tree print here\n        part_count = sum(1 for inst in self.instances.values() if isinstance(inst, PartInstance))\n        asm_count = sum(1 for inst in self.instances.values() if isinstance(inst, AssemblyInstance))\n        return (\n            f\"CAD(\"\n            f\"keys={len(self.keys_by_id)}, \"\n            f\"instances={len(self.instances)} (parts={part_count}, asm={asm_count}), \"\n            f\"occurrences={len(self.occurrences)}, \"\n            f\"subassemblies={(len(self.subassemblies))}, \"\n            f\"mates={len(self.mates)}, \"\n            f\"patterns={len(self.patterns)}, \"\n            f\"parts={len(self.parts)})\"\n        )\n\n    @classmethod\n    def from_assembly(\n        cls,\n        assembly: Assembly,\n        max_depth: int = 0,\n        client: Optional[Client] = None,\n        fetch_mass_properties: bool = True,\n        fetch_mate_properties: bool = True,\n    ) -&gt; \"CAD\":\n        \"\"\"\n        Create a CAD from an Onshape Assembly.\n\n        Args:\n            assembly: Onshape assembly data\n            max_depth: Maximum depth for flexible assemblies\n\n        Returns:\n            CAD with populated flat dicts\n        \"\"\"\n        # Create CAD instance\n        if assembly.document is None:\n            raise ValueError(\"Assembly document is None\")\n\n        cad = cls(\n            document_id=assembly.rootAssembly.documentId,\n            element_id=assembly.rootAssembly.elementId,\n            wtype=assembly.document.wtype,\n            workspace_id=assembly.document.wid,\n            document_microversion=assembly.rootAssembly.documentMicroversion,\n            name=assembly.document.name,  # TODO: this is different from assembly.name\n            max_depth=max_depth,\n            client=client,\n        )\n\n        # Build id_to_name mapping (needed for PathKey creation)\n        id_to_name = cls._build_id_to_name_map(assembly)\n\n        # Build PathKeys from occurrences (single source of truth)\n        cad.keys_by_id, cad.keys_by_name = cls._build_path_keys_from_occurrences(\n            assembly.rootAssembly.occurrences, id_to_name\n        )\n\n        # Populate all data using the pre-built PathKeys\n        cad._populate_from_assembly(assembly)\n\n        if fetch_mate_properties:\n            cad.fetch_mate_limits(client)\n\n        logger.info(f\"Created {cad}\")\n        record_cad_config(max_depth=max_depth)\n\n        if client is not None:\n            estimation = cad.estimate_api_calls(\n                fetch_mass_properties=fetch_mass_properties,\n                fetch_mate_properties=fetch_mate_properties,\n                download_meshes=True,\n            )\n            logger.info(\n                f\"Estimated API calls for CAD to Robot conversion \u2192 Total: {estimation['total']} \"\n                f\"(subassemblies: {estimation['subassemblies']}, \"\n                f\"mass_properties: {estimation['mass_properties']}, \"\n                f\"mate_properties: {estimation['mate_properties']}, \"\n                f\"meshes: {estimation['meshes']})\"\n            )\n\n        return cad\n\n    @classmethod\n    def from_url(\n        cls,\n        url: str,\n        *,\n        client: Client,\n        max_depth: int = 0,\n        configuration: str = \"default\",\n        log_response: bool = True,\n        with_meta_data: bool = True,\n    ) -&gt; \"CAD\":\n        \"\"\"Create a CAD instance directly from an Onshape document URL.\"\"\"\n        base_url, did, wtype, wid, eid = parse_url(url)\n        if client is None:\n            raise ValueError(\"client must be provided to load CAD from URL\")\n\n        document = Document(base_url=base_url, did=did, wtype=wtype, wid=wid, eid=eid, url=url)\n\n        assembly = client.get_assembly(\n            document.did,\n            document.wtype,\n            document.wid,\n            document.eid,\n            configuration=configuration,\n            log_response=log_response,\n            with_meta_data=with_meta_data,\n        )\n\n        return cls.from_assembly(assembly, max_depth=max_depth, client=client)\n\n    @staticmethod\n    def _build_path_keys_from_occurrences(\n        occurrences: list[Occurrence], id_to_name: dict[str, str]\n    ) -&gt; tuple[dict[tuple[str, ...], PathKey], dict[tuple[str, ...], PathKey]]:\n        \"\"\"\n        Build all PathKeys upfront from occurrences.\n\n        Occurrences are the single source of truth for paths in the assembly.\n        This creates PathKeys once and builds two indexes for O(1) lookup:\n        - By ID path: for internal lookups\n        - By name path: for user-facing lookups\n\n        Args:\n            occurrences: List of occurrences from root assembly\n            id_to_name: Mapping from instance ID to sanitized name\n\n        Returns:\n            Tuple of (keys_by_id, keys_by_name) dictionaries\n        \"\"\"\n        logger.debug(\"Building PathKeys from occurrences...\")\n\n        keys_by_id: dict[tuple[str, ...], PathKey] = {}\n        keys_by_name: dict[tuple[str, ...], PathKey] = {}\n\n        for occurrence in occurrences:\n            # Create PathKey with both ID and name paths\n            key = PathKey.from_path(occurrence.path, id_to_name)\n\n            # Index by ID path tuple (immutable, hashable)\n            keys_by_id[key.path] = key\n\n            # Index by name path tuple for reverse lookup\n            keys_by_name[key.name_path] = key\n\n        logger.debug(f\"Built {len(keys_by_id)} PathKeys from {len(occurrences)} occurrences\")\n        return keys_by_id, keys_by_name\n\n    @staticmethod\n    def _build_id_to_name_map(assembly: Assembly) -&gt; dict[str, str]:\n        \"\"\"\n        Build mapping from instance ID to sanitized name.\n\n        Processes root assembly and all subassemblies to build complete mapping.\n        This must be called FIRST before creating any PathKeys.\n\n        Args:\n            assembly: Assembly from Onshape API\n\n        Returns:\n            Dictionary mapping instance IDs to sanitized names\n        \"\"\"\n        logger.debug(\"Building instance ID to name mapping...\")\n\n        id_to_name: dict[str, str] = {}\n\n        # Root assembly instances\n        for instance in assembly.rootAssembly.instances:\n            sanitized = get_sanitized_name(instance.name)\n            id_to_name[instance.id] = sanitized\n\n        # Subassembly instances\n        visited_uids: set[str] = set()\n        subassembly_deque: deque[SubAssembly] = deque(assembly.subAssemblies)\n\n        while subassembly_deque:\n            subassembly = subassembly_deque.popleft()\n\n            if subassembly.uid in visited_uids:\n                continue\n            visited_uids.add(subassembly.uid)\n\n            for instance in subassembly.instances:\n                sanitized = get_sanitized_name(instance.name)\n                id_to_name[instance.id] = sanitized\n\n        logger.debug(f\"Mapped {len(id_to_name)} instance IDs to names\")\n        return id_to_name\n\n    def _populate_from_assembly(self, assembly: Assembly) -&gt; None:\n        \"\"\"\n        Populate all CAD data using pre-built PathKeys from self.keys_by_id.\n\n        Flattens data from root assembly and all subassemblies into flat registries.\n\n        Args:\n            assembly: Assembly from Onshape API\n        \"\"\"\n        # Step 1: Populate instances (root + subassemblies)\n        self._populate_instances(assembly)\n\n        # Step 2: Populate occurrences (root + subassemblies)\n        self._populate_occurrences(assembly)\n\n        # Step 3: Populate subassemblies and check/mark if they are rigid\n        self._populate_subassemblies(assembly)\n\n        # Step 4: Populate parts from assembly.parts (mass properties still None)\n        self._populate_parts(assembly)\n\n        # Step 6: Populate mates with assembly provenance\n        self._populate_mates(assembly)\n\n        # Step 5: Populate patterns (root + subassemblies)\n        self._populate_patterns(assembly)\n\n        logger.debug(\n            f\"Populated CAD: {len(self.instances)} instances, \"\n            f\"{len(self.occurrences)} occurrences, {len(self.mates)} mates, \"\n            f\"{len(self.patterns)} patterns, {len(self.parts)} parts\"\n        )\n\n    def _populate_instances(self, assembly: Assembly) -&gt; None:\n        \"\"\"\n        Populate instances from root assembly and all subassemblies.\n\n        This creates a flat registry of ALL instances (root + nested) mapped by absolute PathKeys.\n\n        Args:\n            assembly: Assembly from Onshape API\n        \"\"\"\n        subassembly_lookup = {subassembly.uid: subassembly for subassembly in assembly.subAssemblies}\n\n        def _populate_branch(\n            branch_instances: list[Union[PartInstance, AssemblyInstance]],\n            parent_key: Optional[PathKey],\n        ) -&gt; None:\n            for instance in branch_instances:\n                path_tuple = (instance.id,) if parent_key is None else (*parent_key.path, instance.id)\n                key = self.keys_by_id.get(path_tuple)\n                if not key:\n                    if instance.suppressed:\n                        continue\n                    # check if parent is suppressed\n                    if parent_key and self.instances[parent_key].suppressed:\n                        continue\n\n                    scope = \"root\" if parent_key is None else \"nested\"\n                    logger.warning(f\"No PathKey for {scope} instance {instance.id} ({instance.name})\")\n                    continue\n\n                self.instances[key] = copy.deepcopy(instance)\n\n                if isinstance(instance, AssemblyInstance):\n                    subassembly = subassembly_lookup.get(instance.uid)\n                    if not subassembly:\n                        logger.warning(\n                            f\"Missing SubAssembly definition for instance {instance.id} \"\n                            f\"({instance.name}) with uid {instance.uid}\"\n                        )\n                        continue\n                    _populate_branch(subassembly.instances, key)\n                elif isinstance(instance, PartInstance):\n                    record_part_name(str(key), getattr(instance, \"name\", None))\n\n        _populate_branch(assembly.rootAssembly.instances, None)\n        logger.info(f\"Populated {len(self.instances)} instances (including nested)\")\n\n    def _populate_occurrences(self, assembly: Assembly) -&gt; None:\n        \"\"\"\n        Populate occurrences from root assembly (includes all nested occurrences).\n\n        Args:\n            assembly: Assembly from Onshape API\n        \"\"\"\n        for occurrence in assembly.rootAssembly.occurrences:\n            path_tuple = tuple(occurrence.path)\n            key = self.keys_by_id.get(path_tuple)\n            if key:\n                self.occurrences[key] = occurrence\n            else:\n                logger.warning(f\"No PathKey for occurrence {occurrence.path}\")\n\n        logger.info(f\"Populated {len(self.occurrences)} occurrences\")\n\n    def _populate_subassemblies(self, assembly: Assembly) -&gt; None:\n        \"\"\"\n        Populate subassemblies from the assembly JSON\n\n        Args:\n            assembly: Assembly from Onshape API\n        \"\"\"\n        # Build a multimap from subassembly UID -&gt; list[PathKey] (one per occurrence)\n        uid_to_pathkeys: dict[str, list[PathKey]] = {}\n        for key, inst in self.instances.items():\n            if isinstance(inst, AssemblyInstance):\n                uid_to_pathkeys.setdefault(inst.uid, []).append(key)\n\n        total_defs = len(assembly.subAssemblies)\n        total_occurrences = 0\n        rigid_by_depth = 0\n        rigid_by_features = 0\n\n        for subassembly in assembly.subAssemblies:\n            pathkeys = uid_to_pathkeys.get(subassembly.uid)\n            if not pathkeys:\n                logger.warning(\n                    \"SubAssembly definition uid=%s has no matching AssemblyInstance occurrences\", subassembly.uid\n                )\n                continue\n\n            # Analyze features to determine if this subassembly should be rigid\n            # An assembly is rigid by features if:\n            # 1. It has no features (empty assembly), OR\n            # 2. It has features AND all features are mate groups (organizational only)\n            is_rigid_by_mate_groups = self._is_rigid_by_features(subassembly)\n\n            for pathkey in pathkeys:\n                # Create a deep copy for this occurrence\n                subassembly_copy = copy.deepcopy(subassembly)\n\n                # Mark rigidity based on depth or feature analysis\n                is_rigid_by_depth_check = pathkey.depth &gt;= self.max_depth\n\n                if is_rigid_by_mate_groups:\n                    subassembly_copy.isRigid = True\n                    rigid_by_features += 1\n                    logger.debug(\n                        f\"Subassembly {pathkey} marked as rigid (features analysis: \"\n                        f\"{len(subassembly.features)} features, all mate groups)\"\n                    )\n                elif is_rigid_by_depth_check:\n                    subassembly_copy.isRigid = True\n                    rigid_by_depth += 1\n                    logger.debug(\n                        f\"Subassembly {pathkey} marked as rigid (depth {pathkey.depth} &gt;= max_depth {self.max_depth})\"\n                    )\n\n                # Update the corresponding instance\n                inst = self.instances[pathkey]\n                if isinstance(inst, AssemblyInstance):\n                    inst.isRigid = subassembly_copy.isRigid\n\n                self.subassemblies[pathkey] = subassembly_copy\n                total_occurrences += 1\n\n        logger.info(\n            f\"Populated {total_occurrences} subassembly occurrences from {total_defs} definitions \"\n            f\"(rigid_by_depth={rigid_by_depth}, rigid_by_features={rigid_by_features}, max_depth={self.max_depth})\",\n        )\n\n    def _is_rigid_by_features(self, subassembly: SubAssembly) -&gt; bool:\n        \"\"\"\n        Determine if a subassembly should be treated as rigid based on its features.\n\n        A subassembly is considered rigid if:\n        1. It has no features at all (empty assembly), OR\n        2. It has features but ALL of them are mate groups\n\n        Mate groups are organizational features that group parts together without\n        defining kinematic relationships. When an assembly contains only mate groups,\n        it indicates the designer intends for those parts to move as a single rigid body.\n\n        Args:\n            subassembly: SubAssembly to analyze\n\n        Returns:\n            True if subassembly should be rigid, False otherwise\n\n        Examples:\n            &gt;&gt;&gt; # Empty assembly -&gt; rigid\n            &gt;&gt;&gt; sub = SubAssembly(features=[])\n            &gt;&gt;&gt; _is_rigid_by_features(sub)\n            True\n\n            &gt;&gt;&gt; # Only mate groups -&gt; rigid\n            &gt;&gt;&gt; sub = SubAssembly(features=[MateGroup1, MateGroup2])\n            &gt;&gt;&gt; _is_rigid_by_features(sub)\n            True\n\n            &gt;&gt;&gt; # Mix of mate groups and mates -&gt; flexible\n            &gt;&gt;&gt; sub = SubAssembly(features=[MateGroup1, RevoluteMate])\n            &gt;&gt;&gt; _is_rigid_by_features(sub)\n            False\n        \"\"\"\n        if len(subassembly.features) == 0:\n            return True\n\n        # Check if all non-suppressed features are mate groups\n        non_suppressed_features = [f for f in subassembly.features if not f.suppressed]\n        if len(non_suppressed_features) == 0:\n            return True\n\n        return all(feature.featureType in RIGID_ASSEMBLY_ONLY_FEATURE_TYPES for feature in non_suppressed_features)\n\n    def _populate_mates(self, assembly: Assembly) -&gt; None:\n        \"\"\"\n        Populate mates from root and all subassemblies with assembly provenance.\n\n        Root mates: Key = (None, parent, child)\n        Subassembly mates: Key = (sub_key, parent, child)\n\n        For mates referencing parts inside rigid assemblies:\n        - Remap PathKey to rigid assembly root\n        - Update matedCS transform to be relative to rigid assembly\n\n        Args:\n            assembly: Assembly from Onshape API\n        \"\"\"\n\n        def _process_feature(\n            feature: AssemblyFeature,\n            assembly_key: Optional[PathKey],\n            path_prefix: Optional[tuple[str, ...]],\n        ) -&gt; None:\n            \"\"\"Internal helper to process a single assembly feature.\n\n            Handles both mate features (which create kinematic relationships) and\n            mate groups (which are organizational only and don't create edges).\n\n            Args:\n                feature: Feature object which may contain MateFeatureData or MateGroupFeatureData\n                assembly_key: None for root, or PathKey of subassembly provenance\n                path_prefix: Tuple prefix to prepend for relative subassembly paths\n            \"\"\"\n            if feature.suppressed:\n                return\n\n            # Handle mate groups (organizational only - no kinematic relationship)\n            if feature.featureType == AssemblyFeatureType.MATEGROUP:\n                if isinstance(feature.featureData, MateGroupFeatureData):\n                    mate_group_data: MateGroupFeatureData = feature.featureData\n                    scope = \"root\" if assembly_key is None else f\"subassembly {assembly_key}\"\n                    logger.debug(\n                        f\"Found mate group '{mate_group_data.name}' in {scope} with \"\n                        f\"{len(mate_group_data.occurrences)} occurrences (organizational only, no mate edges created)\"\n                    )\n                return\n\n            # Handle mate connectors (not yet implemented)\n            if feature.featureType == AssemblyFeatureType.MATECONNECTOR:\n                # TODO: add support for mate connectors\n                return\n\n            # Handle regular mates (create kinematic relationships)\n            if feature.featureType != AssemblyFeatureType.MATE or not isinstance(feature.featureData, MateFeatureData):\n                return\n\n            mate_data: MateFeatureData = copy.deepcopy(feature.featureData)\n\n            # TODO: Onshape mate feature data always has two entities (parent/child). If origin mates ever\n            # appear differently, this is the place to update handling.\n            try:\n                parent_occ = mate_data.matedEntities[PARENT].matedOccurrence\n                child_occ = mate_data.matedEntities[CHILD].matedOccurrence\n            except Exception:\n                logger.warning(f\"Malformed mate feature {mate_data.name}\")\n                return\n\n            parent_path = tuple(parent_occ)\n            child_path = tuple(child_occ)\n\n            if path_prefix:\n                parent_path = path_prefix + parent_path\n                child_path = path_prefix + child_path\n\n            parent_key = self.keys_by_id.get(parent_path)\n            child_key = self.keys_by_id.get(child_path)\n\n            # NOTE: reorient the mated entities to match this parent, child order\n            # TODO: add tests to make sure this convention is preserved\n            # We create indices for parent and child, get the occurrences,\n            # remap the mate data to always be parent -&gt; child\n            mate_data.matedEntities = [\n                mate_data.matedEntities[PARENT],\n                mate_data.matedEntities[CHILD],\n            ]\n\n            sanitized_mate_name = get_sanitized_name(mate_data.name)\n            record_mate_name(sanitized_mate_name, mate_data.name, mate_data.limits)\n\n            if parent_key and child_key:\n                self.mates[(assembly_key, parent_key, child_key)] = mate_data\n            else:\n                scope = \"root\" if assembly_key is None else f\"subassembly {assembly_key}\"\n                logger.warning(\n                    \"Missing PathKey for %s mate: %s (parent_found=%s, child_found=%s)\",\n                    scope,\n                    mate_data.name,\n                    bool(parent_key),\n                    bool(child_key),\n                )\n\n        # Process root assembly features (absolute paths)\n        for feature in assembly.rootAssembly.features:\n            _process_feature(feature, None, None)\n\n        # Process subassembly features (relative paths)\n        for sub_key, subassembly in self.subassemblies.items():\n            if subassembly.isRigid:\n                continue\n\n            for feature in subassembly.features:\n                _process_feature(feature=feature, assembly_key=sub_key, path_prefix=sub_key.path)\n\n        logger.debug(f\"Populated {len(self.mates)} mates (root + flexible subassemblies)\")\n\n    def _populate_patterns(self, assembly: Assembly) -&gt; None:\n        \"\"\"\n        Populate patterns from root assembly and all subassemblies.\n\n        Args:\n            assembly: Assembly from Onshape API\n        \"\"\"\n\n        def _add_pattern(pattern: Pattern, path_prefix: Optional[tuple[str, ...]]) -&gt; None:\n            if pattern.suppressed:\n                return\n\n            mutated_seed_pattern_instances: dict[tuple[str, ...], list[tuple[str, ...]]] = {}\n            for seed_id, instance_ids in pattern.seedToPatternInstances.items():\n                # since seed_id can be both a single string or a tuple of strings,\n                # we need to make it a tuple for consistent keying\n                seed_id_tuple: tuple[str, ...] = (seed_id,) if isinstance(seed_id, str) else seed_id\n\n                mutated_id = seed_id_tuple if path_prefix is None else (*path_prefix, *seed_id_tuple)\n\n                for instance_id in instance_ids:\n                    # since instance_id can be both a single string or a tuple of strings,\n                    # we need to make it a tuple for consistent keying\n                    instance_id_tuple: tuple[str, ...]\n                    if isinstance(instance_id, str):\n                        instance_id_tuple = (instance_id,)\n                    elif isinstance(instance_id, list):\n                        instance_id_tuple = tuple(instance_id)\n                    else:\n                        instance_id_tuple = instance_id\n\n                    mutated_instance_id = (\n                        instance_id_tuple if path_prefix is None else (*path_prefix, *instance_id_tuple)\n                    )\n                    mutated_seed_pattern_instances.setdefault(mutated_id, []).append(mutated_instance_id)\n\n            pattern.seedToPatternInstances = mutated_seed_pattern_instances  # type: ignore[assignment]\n            self.patterns[pattern.id] = pattern\n\n        # Root patterns\n        for pattern in assembly.rootAssembly.patterns:\n            _add_pattern(pattern, None)\n\n        # Subassembly patterns (only from flexible subassemblies)\n        for subassembly_key, subassembly in self.subassemblies.items():\n            if subassembly.isRigid:\n                continue\n\n            for pattern in subassembly.patterns:\n                _add_pattern(pattern, subassembly_key.path)\n\n        self._flatten_patterns()\n\n        logger.debug(f\"Populated {len(self.patterns)} patterns\")\n\n    def _flatten_patterns(\n        self,\n    ) -&gt; None:\n        def _add_mate(\n            seed_mate: MateFeatureData,\n            seed_key: PathKey,\n            instance_key: PathKey,\n            other_entity_key: PathKey,\n            mate_key: tuple[Optional[PathKey], PathKey, PathKey],\n            is_seed_parent: bool = True,\n        ) -&gt; None:\n            new_mate = copy.deepcopy(seed_mate)\n            # NOTE: seed index needs to be replaced by the instance\n            # since we reordered the populated mates to always have parent-&gt;child order,\n            # we should not use the global constants (PARENT, CHILD) here\n            oe_index = 1 if is_seed_parent else 0\n            oe_mated_cs = new_mate.matedEntities[oe_index].matedCS\n\n            # NOTE: compute new matedCS for the other entity, this is crucial because\n            # this governs where this new instance will be placed in the robot structure\n            seed_pose_wrt_world = self.occurrences[seed_key].tf\n            instance_pose_wrt_world = self.occurrences[instance_key].tf\n            oe_pose_wrt_world = self.occurrences[other_entity_key].tf\n\n            # NOTE: find the other entity's mated CS wrt to the instance part\n            # First, find the other entity's mated CS wrt seed part, then transform it\n            # to the instance global coordinates, then find this wrt to the other entity\n            oe_mated_cs_wrt_world = oe_pose_wrt_world @ oe_mated_cs.to_tf\n            oe_mated_cs_wrt_seed = np.linalg.inv(seed_pose_wrt_world) @ oe_mated_cs_wrt_world\n            oe_mated_cs_for_instance = instance_pose_wrt_world @ oe_mated_cs_wrt_seed\n            oe_mated_cs_tf = np.linalg.inv(oe_pose_wrt_world) @ oe_mated_cs_for_instance\n\n            new_mate.matedEntities[oe_index].matedCS = MatedCS.from_tf(oe_mated_cs_tf)\n            new_mate.matedEntities[1 - oe_index].matedOccurrence = list(instance_key.path)\n            self.mates[mate_key] = new_mate\n\n        seed_instance_to_pattern_instances: dict[tuple[str, PathKey], list[PathKey]] = {}\n\n        for pattern_id, pattern in self.patterns.items():\n            if pattern.suppressed:\n                continue\n\n            for seed_id, instance_ids in pattern.seedToPatternInstances.items():\n                # Ensure seed_id is a tuple for dictionary lookup\n                seed_id_tuple = seed_id if isinstance(seed_id, tuple) else (seed_id,)\n                seed_path_key = self.keys_by_id[seed_id_tuple]\n                key = (pattern_id, seed_path_key)\n\n                if key not in seed_instance_to_pattern_instances:\n                    seed_instance_to_pattern_instances[key] = []\n\n                for instance_id in instance_ids:\n                    # NOTE: instance_id is a list of strings (path)\n                    instance_path_key = self.keys_by_id[tuple(instance_id)]\n                    seed_instance_to_pattern_instances[key].append(instance_path_key)\n\n        # find all mates referencing this part\n        original_mates = copy.deepcopy(self.mates)\n        for (assembly_key, parent_key, child_key), mate in original_mates.items():\n            for (_, seed_key), instance_keys in seed_instance_to_pattern_instances.items():\n                if parent_key == seed_key:\n                    for instance_key in instance_keys:\n                        _add_mate(\n                            seed_mate=mate,\n                            seed_key=parent_key,\n                            instance_key=instance_key,\n                            other_entity_key=child_key,\n                            mate_key=(assembly_key, instance_key, child_key),\n                            is_seed_parent=True,\n                        )\n                if child_key == seed_key:\n                    for instance_key in instance_keys:\n                        _add_mate(\n                            seed_mate=mate,\n                            seed_key=child_key,\n                            instance_key=instance_key,\n                            other_entity_key=parent_key,\n                            mate_key=(assembly_key, parent_key, instance_key),\n                            is_seed_parent=False,\n                        )\n\n    def _populate_parts(self, assembly: Assembly) -&gt; None:\n        \"\"\"\n        Populate parts from assembly.parts list.\n\n        Maps Part objects to PathKeys by matching instance UIDs.\n        Creates synthetic Part objects for rigid assemblies.\n        Mass properties remain None (populated later via API calls).\n\n        Args:\n            assembly: Assembly from Onshape API\n        \"\"\"\n        # Build Part lookup by UID\n        # Build a multimap from part UID -&gt; list[PathKey] (one per occurrence)\n        uid_to_pathkeys: dict[str, list[PathKey]] = {}\n        for key, inst in self.instances.items():\n            if isinstance(inst, PartInstance):\n                uid_to_pathkeys.setdefault(inst.uid, []).append(key)\n\n        for part in assembly.parts:\n            pathkeys = uid_to_pathkeys.get(part.uid)\n            if not pathkeys:\n                logger.warning(\"Part definition uid=%s has no matching PartInstance\", part.uid)\n                continue\n\n            for pathkey in pathkeys:\n                self.parts[pathkey] = copy.deepcopy(part)  # Avoid mutating original data\n                self.parts[pathkey].worldToPartTF = MatedCS.from_tf(self.occurrences[pathkey].tf)\n\n                # Check if this part belongs to a rigid assembly\n                # This can happen either because:\n                # 1. The part's depth exceeds max_depth (depth-based rigidity), OR\n                # 2. The part is inside an assembly that was marked rigid by feature analysis (mate groups only)\n                rigid_root = self.get_rigid_assembly_root(pathkey)\n                if rigid_root is not None:\n                    self.parts[pathkey].rigidAssemblyKey = rigid_root\n                    self.parts[pathkey].rigidAssemblyWorkspaceId = self.workspace_id\n\n                    # NOTE: Using the root occurrences of the rigid assembly directly from Onshape API\n                    # instead of computing it from the root assembly's global occurrences because\n                    # Onshape's occurrence TF for subassemblies are not what we expect it to be, the occurrence TF\n                    # does not reflect the pose of the subassembly in world frame, will Onshape potentially fix this?\n                    if self.subassemblies[rigid_root].RootOccurrences is None:\n                        if self._client is None:\n                            logger.warning(\n                                f\"At max_depth of {self.max_depth}, we require Client to \"\n                                \"fetch all root occurrences of a subassembly.\"\n                            )\n                            logger.warning(\"These root occurrences are used to remap parts inside rigid assemblies.\")\n                            logger.warning(\n                                f\"Skipping setting rigidAssemblyToPartTF for part {pathkey} \"\n                                f\"inside rigid assembly {rigid_root}.\"\n                            )\n                            logger.warning(\n                                \"This will result in malformed joints that have refer to parts within rigid assemblies.\"\n                            )\n                            continue\n\n                        asyncio.run(self.fetch_occurrences_for_subassemblies(self._client))\n\n                    part_pose_wrt_rigid_root = self.subassemblies[rigid_root].RootOccurrences[pathkey]  # type: ignore[index]\n                    self.parts[pathkey].rigidAssemblyToPartTF = MatedCS.from_tf(tf=part_pose_wrt_rigid_root.tf)\n\n                    logger.debug(f\"Set rigidAssemblyToPartTF for {pathkey}, with rigid assembly {rigid_root}\")\n\n        # Create synthetic Part objects for rigid assemblies\n        for key, subassembly in self.subassemblies.items():\n            if subassembly.isRigid:\n                subassembly_instance = self.instances[key]\n                # Rigid assembly: create synthetic Part object\n                self.parts[key] = Part(\n                    isStandardContent=False,\n                    partId=subassembly_instance.elementId,  # Use element ID as part ID\n                    bodyType=\"assembly\",\n                    documentId=subassembly_instance.documentId,\n                    elementId=subassembly_instance.elementId,\n                    documentMicroversion=subassembly_instance.documentMicroversion,\n                    configuration=subassembly_instance.configuration,\n                    fullConfiguration=subassembly_instance.fullConfiguration,\n                    documentVersion=subassembly_instance.documentVersion,\n                    isRigidAssembly=True,\n                    rigidAssemblyKey=None,  # Not applicable for rigid assembly itself\n                    rigidAssemblyWorkspaceId=self.workspace_id,\n                    rigidAssemblyToPartTF=None,\n                    worldToPartTF=MatedCS.from_tf(self.occurrences[key].tf),\n                    MassProperty=None,  # Populated later via mass property fetch\n                )\n\n        logger.info(f\"Populated {len(self.parts)} parts from assembly\")\n\n    async def fetch_mass_properties_for_parts(self, client: Client) -&gt; None:\n        async def _fetch_mass_properties(key: PathKey, part: Part, client: Client) -&gt; None:\n            try:\n                if part.isRigidAssembly:\n                    logger.debug(f\"Fetching mass properties for rigid assembly: {key}\")\n                    part.MassProperty = await asyncio.to_thread(\n                        client.get_assembly_mass_properties,\n                        did=part.documentId,\n                        wtype=WorkspaceType.W.value,\n                        wid=part.rigidAssemblyWorkspaceId,  # type: ignore[arg-type]\n                        eid=part.elementId,\n                    )\n                else:\n                    logger.debug(f\"Fetching mass properties for part: {key}\")\n                    part.MassProperty = await asyncio.to_thread(\n                        client.get_mass_property,\n                        did=part.documentId,\n                        wtype=WorkspaceType.M.value,\n                        wid=part.documentMicroversion if part.documentMicroversion else self.document_microversion,\n                        eid=part.elementId,\n                        partID=part.partId,\n                    )\n            except Exception as e:\n                logger.error(f\"Failed to fetch mass properties for part {key}: {e}\")\n\n        tasks = []\n        for key, part in self.parts.items():\n            if part.MassProperty is not None:\n                logger.debug(f\"Part {key} already has mass properties, skipping\")\n                continue\n\n            if part.rigidAssemblyToPartTF is not None:\n                # this part belongs to a rigid subassembly, skip fetching mass properties\n                continue\n\n            tasks.append(_fetch_mass_properties(key, part, client))\n\n        if tasks:\n            await asyncio.gather(*tasks, return_exceptions=True)\n\n    async def fetch_occurrences_for_subassemblies(self, client: Client) -&gt; None:\n        async def _fetch_rootassembly(key: PathKey, subassembly: SubAssembly, client: Client) -&gt; None:\n            try:\n                logger.debug(f\"Fetching root assembly for subassembly: {key}\")\n                _subassembly_data: RootAssembly = await asyncio.to_thread(\n                    client.get_root_assembly,\n                    did=subassembly.documentId,\n                    wtype=WorkspaceType.M.value,\n                    wid=subassembly.documentMicroversion,\n                    eid=subassembly.elementId,\n                    with_mass_properties=True,\n                    log_response=False,\n                )\n                _subassembly_occurrences = _subassembly_data.occurrences\n                for occurrence in _subassembly_occurrences:\n                    # NOTE: add sub-assembly key as prefix to get absolute path\n                    path_tuple = tuple(key.path) + tuple(occurrence.path)\n                    occ_key = self.keys_by_id.get(path_tuple)\n                    if occ_key:\n                        if subassembly.RootOccurrences is None:\n                            subassembly.RootOccurrences = {}\n                        subassembly.RootOccurrences[occ_key] = occurrence\n                    else:\n                        # Check if any parent in the hierarchy is suppressed (causing missing PathKey)\n                        # Walk up the path and check if any instance is suppressed\n                        is_suppressed_parent = False\n                        for i in range(len(path_tuple), 0, -1):\n                            partial_path = path_tuple[:i]\n                            partial_key = self.keys_by_id.get(partial_path)\n                            if (\n                                partial_key\n                                and self.instances.get(partial_key, None)\n                                and self.instances[partial_key].suppressed\n                            ):\n                                is_suppressed_parent = True\n                                break\n\n                        if not is_suppressed_parent:\n                            logger.warning(f\"No PathKey for subassembly occurrence {occurrence.path} in {key}\")\n\n            except Exception as e:\n                logger.error(f\"Failed to fetch root assembly for subassembly {key}: {e}\")\n\n        tasks = []\n        for key, subassembly in self.subassemblies.items():\n            if subassembly.RootOccurrences is not None:\n                logger.debug(f\"Subassembly {key} already has RootOccurrences, skipping\")\n                continue\n\n            if not subassembly.isRigid:\n                # dont fetch root occurrences for flexible subassemblies\n                continue\n\n            tasks.append(_fetch_rootassembly(key, subassembly, client))\n\n        if tasks:\n            await asyncio.gather(*tasks, return_exceptions=True)\n\n    def fetch_mate_limits(self, client: Optional[Client]) -&gt; None:\n        \"\"\"\n        Fetch joint limits from Onshape features and populate mate data.\n\n        This method fetches features for the root assembly and all flexible subassemblies,\n        extracts joint limit parameters from mate features, and stores them in the\n        corresponding MateFeatureData objects.\n\n        Args:\n            client: Onshape API client for fetching features\n\n        Note:\n            - Only processes mates with limitsEnabled=true\n            - Parses limit expressions (e.g., \"90 deg\", \"0.5 m\") to numerical values\n            - Stores limits as {'min': float, 'max': float} dict in MateFeatureData.limits\n            - For revolute joints: uses axial Z limits\n            - For prismatic/slider joints: uses Z limits\n        \"\"\"\n        if client is None:\n            logger.warning(\"No client provided for fetching mate limits, skipping\")\n            return\n\n        logger.info(\"Fetching mate limits from assembly features\")\n\n        # Build list of assemblies to fetch features from (root + flexible subassemblies)\n        assemblies_to_fetch: list[tuple[Optional[PathKey], str, str, str, str]] = []\n        assemblies_to_fetch.append((None, self.document_id, self.wtype, self.workspace_id, self.element_id))\n\n        # Add flexible subassemblies\n        for sub_key, subassembly in self.subassemblies.items():\n            if not subassembly.isRigid:\n                assemblies_to_fetch.append((\n                    sub_key,\n                    subassembly.documentId,\n                    WorkspaceType.M.value,\n                    subassembly.documentMicroversion,\n                    subassembly.elementId,\n                ))\n\n        # Fetch features for each assembly\n        limits_found_count = 0\n        for assembly_key, did, wtype, wid, eid in assemblies_to_fetch:\n            try:\n                logger.debug(f\"Fetching features for assembly: {assembly_key or 'root'}\")\n                features = client.get_features(did=did, wtype=wtype, wid=wid, eid=eid)\n\n                # Process each feature to extract limits\n                for feature in features.features:\n                    if feature.message.featureType != \"mate\":\n                        continue\n\n                    feature_id = feature.message.featureId\n\n                    # Find the corresponding mate in our mates dict\n                    mate_data: Optional[MateFeatureData] = None\n                    for _, mate in self.mates.items():\n                        if mate.id == feature_id:\n                            mate_data = mate\n                            break\n\n                    if mate_data is None:\n                        logger.debug(f\"Could not find mate data for feature {feature_id}\")\n                        continue\n\n                    # Check if limits are enabled\n                    params = feature.message.parameter_dict()\n                    limits_enabled = params.get(\"limitsEnabled\")\n                    if limits_enabled is None or not limits_enabled.get(\"message\", {}).get(\"value\", False):\n                        continue\n\n                    # Determine which limit parameters to use based on mate type\n                    is_axial = mate_data.mateType in (MateType.REVOLUTE, MateType.CYLINDRICAL)\n\n                    # Extract limit expressions\n                    if is_axial:\n                        min_param_name = \"limitAxialZMin\"\n                        max_param_name = \"limitAxialZMax\"\n                    else:\n                        min_param_name = \"limitZMin\"\n                        max_param_name = \"limitZMax\"\n\n                    # Extract parameter expressions\n                    def get_param_expression(param_dict: dict[str, Any], param_name: str) -&gt; str | None:\n                        param = param_dict.get(param_name)\n                        if not isinstance(param, dict):\n                            return None\n                        # Handle BTMParameterNullableQuantity type\n                        if param.get(\"typeName\") == \"BTMParameterNullableQuantity\":\n                            message = param.get(\"message\", {})\n                            if not isinstance(message, dict) or message.get(\"isNull\", True):\n                                return None\n                            expression = message.get(\"expression\")\n                            return expression if isinstance(expression, str) else None\n                        return None\n\n                    min_expression = get_param_expression(params, min_param_name)\n                    max_expression = get_param_expression(params, max_param_name)\n\n                    # Parse expressions to numerical values\n                    min_value = parse_onshape_expression(min_expression)\n                    max_value = parse_onshape_expression(max_expression)\n\n                    # Only store if we got valid values\n                    if min_value is not None and max_value is not None:\n                        limits = {\"min\": min_value, \"max\": max_value}\n                        mate_data.limits = limits\n                        sanitized_mate_name = get_sanitized_name(mate_data.name)\n                        update_mate_limits(sanitized_mate_name, limits)\n                        limits_found_count += 1\n                        logger.debug(\n                            f\"Set limits for mate '{mate_data.name}' ({mate_data.mateType}): \"\n                            f\"min={min_value:.4f}, max={max_value:.4f}\"\n                        )\n\n            except Exception as e:\n                logger.warning(f\"Failed to fetch features for assembly {assembly_key or 'root'}: {e}\")\n                continue\n\n        logger.info(f\"Fetched limits for {limits_found_count} mates out of {len(self.mates)} total mates\")\n</code></pre>"},{"location":"api/parse/#onshape_robotics_toolkit.parse.CAD.__init__","title":"<code>__init__(document_id, element_id, wtype, workspace_id, document_microversion, name='cad', max_depth=0, client=None)</code>","text":"<p>Initialize an empty CAD document.</p> <p>Parameters:</p> Name Type Description Default <code>document_id</code> <code>str</code> <p>Onshape document ID</p> required <code>element_id</code> <code>str</code> <p>Onshape element (assembly) ID</p> required <code>wtype</code> <code>str</code> <p>Workspace type of the document</p> required <code>workspace_id</code> <code>str</code> <p>Onshape workspace ID</p> required <code>document_microversion</code> <code>str</code> <p>Onshape document microversion</p> required <code>name</code> <code>Optional[str]</code> <p>name of the Onshape document (not element)</p> <code>'cad'</code> <code>max_depth</code> <code>int</code> <p>Maximum depth for flexible assemblies</p> <code>0</code> Source code in <code>onshape_robotics_toolkit/parse.py</code> <pre><code>def __init__(\n    self,\n    document_id: str,\n    element_id: str,\n    wtype: str,\n    workspace_id: str,\n    document_microversion: str,\n    name: Optional[str] = \"cad\",\n    max_depth: int = 0,\n    client: Optional[Client] = None,\n):\n    \"\"\"\n    Initialize an empty CAD document.\n\n    Args:\n        document_id: Onshape document ID\n        element_id: Onshape element (assembly) ID\n        wtype: Workspace type of the document\n        workspace_id: Onshape workspace ID\n        document_microversion: Onshape document microversion\n        name: name of the Onshape document (not element)\n        max_depth: Maximum depth for flexible assemblies\n    \"\"\"\n    self.document_id = document_id\n    self.element_id = element_id\n    self.wtype = wtype\n    self.workspace_id = workspace_id\n    self.document_microversion = document_microversion\n    self.name = name\n    self.max_depth = max_depth\n\n    # Initialize empty dicts\n    self.keys_by_id = {}\n    self.keys_by_name = {}\n    self.instances = {}\n    self.occurrences = {}\n    self.mates = {}\n    self.patterns = {}\n    self.parts = {}\n    self.subassemblies = {}\n\n    self._client = client\n</code></pre>"},{"location":"api/parse/#onshape_robotics_toolkit.parse.CAD.estimate_api_calls","title":"<code>estimate_api_calls(fetch_mass_properties=True, fetch_mate_properties=True, download_meshes=True)</code>","text":"<p>Estimate the number of REMAINING API calls needed to process this CAD assembly.</p> <p>This method analyzes the parsed assembly structure and calculates how many additional API calls will be required to fetch mass properties and download meshes.</p> <p>Note: This does NOT include the initial get_assembly() call that was already made to create this CAD object.</p> <p>Parameters:</p> Name Type Description Default <code>fetch_mass_properties</code> <code>bool</code> <p>Whether mass properties will be fetched</p> <code>True</code> <code>download_meshes</code> <code>bool</code> <p>Whether mesh files will be downloaded</p> <code>True</code> <p>Returns:</p> Type Description <code>dict[str, int]</code> <p>Dictionary containing breakdown of estimated REMAINING API calls: - 'subassemblies': Calls for fetching rigid subassembly data - 'mass_properties': Calls for fetching mass properties - 'meshes': Calls for downloading mesh files - 'total': Total estimated REMAINING API calls</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cad = CAD.from_assembly(assembly, max_depth=1)\n&gt;&gt;&gt; estimation = cad.estimate_api_calls(\n...     fetch_mass_properties=True,\n...     download_meshes=True\n... )\n&gt;&gt;&gt; print(f\"Estimated remaining API calls: {estimation['total']}\")\nEstimated remaining API calls: 24\n</code></pre> Source code in <code>onshape_robotics_toolkit/parse.py</code> <pre><code>def estimate_api_calls(\n    self,\n    fetch_mass_properties: bool = True,\n    fetch_mate_properties: bool = True,\n    download_meshes: bool = True,\n) -&gt; dict[str, int]:\n    \"\"\"\n    Estimate the number of REMAINING API calls needed to process this CAD assembly.\n\n    This method analyzes the parsed assembly structure and calculates how many\n    additional API calls will be required to fetch mass properties and download meshes.\n\n    Note: This does NOT include the initial get_assembly() call that was already\n    made to create this CAD object.\n\n    Args:\n        fetch_mass_properties: Whether mass properties will be fetched\n        download_meshes: Whether mesh files will be downloaded\n\n    Returns:\n        Dictionary containing breakdown of estimated REMAINING API calls:\n            - 'subassemblies': Calls for fetching rigid subassembly data\n            - 'mass_properties': Calls for fetching mass properties\n            - 'meshes': Calls for downloading mesh files\n            - 'total': Total estimated REMAINING API calls\n\n    Examples:\n        &gt;&gt;&gt; cad = CAD.from_assembly(assembly, max_depth=1)\n        &gt;&gt;&gt; estimation = cad.estimate_api_calls(\n        ...     fetch_mass_properties=True,\n        ...     download_meshes=True\n        ... )\n        &gt;&gt;&gt; print(f\"Estimated remaining API calls: {estimation['total']}\")\n        Estimated remaining API calls: 24\n    \"\"\"\n    num_kinematic_parts = sum(\n        1 for key, part in self.parts.items() if part.rigidAssemblyToPartTF is None and not part.isRigidAssembly\n    )\n\n    num_rigid_subassemblies = sum(1 for key, sub in self.subassemblies.items() if sub.isRigid)\n\n    # Each rigid subassembly needs get_root_assembly to fetch occurrence data\n    subassembly_calls = num_rigid_subassemblies\n\n    mass_property_calls = 0\n    if fetch_mass_properties:\n        mass_property_calls = num_kinematic_parts + num_rigid_subassemblies\n\n    mate_property_calls = 0\n    if fetch_mate_properties:\n        mate_property_calls = 1 + len(self.subassemblies) - num_rigid_subassemblies\n\n    mesh_download_calls = 0\n    if download_meshes:\n        mesh_download_calls = num_kinematic_parts + num_rigid_subassemblies\n\n    total_calls = subassembly_calls + mass_property_calls + mesh_download_calls + mate_property_calls\n\n    return {\n        \"subassemblies\": subassembly_calls,\n        \"mass_properties\": mass_property_calls,\n        \"mate_properties\": mate_property_calls,\n        \"meshes\": mesh_download_calls,\n        \"total\": total_calls,\n    }\n</code></pre>"},{"location":"api/parse/#onshape_robotics_toolkit.parse.CAD.fetch_mate_limits","title":"<code>fetch_mate_limits(client)</code>","text":"<p>Fetch joint limits from Onshape features and populate mate data.</p> <p>This method fetches features for the root assembly and all flexible subassemblies, extracts joint limit parameters from mate features, and stores them in the corresponding MateFeatureData objects.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Optional[Client]</code> <p>Onshape API client for fetching features</p> required Note <ul> <li>Only processes mates with limitsEnabled=true</li> <li>Parses limit expressions (e.g., \"90 deg\", \"0.5 m\") to numerical values</li> <li>Stores limits as {'min': float, 'max': float} dict in MateFeatureData.limits</li> <li>For revolute joints: uses axial Z limits</li> <li>For prismatic/slider joints: uses Z limits</li> </ul> Source code in <code>onshape_robotics_toolkit/parse.py</code> <pre><code>def fetch_mate_limits(self, client: Optional[Client]) -&gt; None:\n    \"\"\"\n    Fetch joint limits from Onshape features and populate mate data.\n\n    This method fetches features for the root assembly and all flexible subassemblies,\n    extracts joint limit parameters from mate features, and stores them in the\n    corresponding MateFeatureData objects.\n\n    Args:\n        client: Onshape API client for fetching features\n\n    Note:\n        - Only processes mates with limitsEnabled=true\n        - Parses limit expressions (e.g., \"90 deg\", \"0.5 m\") to numerical values\n        - Stores limits as {'min': float, 'max': float} dict in MateFeatureData.limits\n        - For revolute joints: uses axial Z limits\n        - For prismatic/slider joints: uses Z limits\n    \"\"\"\n    if client is None:\n        logger.warning(\"No client provided for fetching mate limits, skipping\")\n        return\n\n    logger.info(\"Fetching mate limits from assembly features\")\n\n    # Build list of assemblies to fetch features from (root + flexible subassemblies)\n    assemblies_to_fetch: list[tuple[Optional[PathKey], str, str, str, str]] = []\n    assemblies_to_fetch.append((None, self.document_id, self.wtype, self.workspace_id, self.element_id))\n\n    # Add flexible subassemblies\n    for sub_key, subassembly in self.subassemblies.items():\n        if not subassembly.isRigid:\n            assemblies_to_fetch.append((\n                sub_key,\n                subassembly.documentId,\n                WorkspaceType.M.value,\n                subassembly.documentMicroversion,\n                subassembly.elementId,\n            ))\n\n    # Fetch features for each assembly\n    limits_found_count = 0\n    for assembly_key, did, wtype, wid, eid in assemblies_to_fetch:\n        try:\n            logger.debug(f\"Fetching features for assembly: {assembly_key or 'root'}\")\n            features = client.get_features(did=did, wtype=wtype, wid=wid, eid=eid)\n\n            # Process each feature to extract limits\n            for feature in features.features:\n                if feature.message.featureType != \"mate\":\n                    continue\n\n                feature_id = feature.message.featureId\n\n                # Find the corresponding mate in our mates dict\n                mate_data: Optional[MateFeatureData] = None\n                for _, mate in self.mates.items():\n                    if mate.id == feature_id:\n                        mate_data = mate\n                        break\n\n                if mate_data is None:\n                    logger.debug(f\"Could not find mate data for feature {feature_id}\")\n                    continue\n\n                # Check if limits are enabled\n                params = feature.message.parameter_dict()\n                limits_enabled = params.get(\"limitsEnabled\")\n                if limits_enabled is None or not limits_enabled.get(\"message\", {}).get(\"value\", False):\n                    continue\n\n                # Determine which limit parameters to use based on mate type\n                is_axial = mate_data.mateType in (MateType.REVOLUTE, MateType.CYLINDRICAL)\n\n                # Extract limit expressions\n                if is_axial:\n                    min_param_name = \"limitAxialZMin\"\n                    max_param_name = \"limitAxialZMax\"\n                else:\n                    min_param_name = \"limitZMin\"\n                    max_param_name = \"limitZMax\"\n\n                # Extract parameter expressions\n                def get_param_expression(param_dict: dict[str, Any], param_name: str) -&gt; str | None:\n                    param = param_dict.get(param_name)\n                    if not isinstance(param, dict):\n                        return None\n                    # Handle BTMParameterNullableQuantity type\n                    if param.get(\"typeName\") == \"BTMParameterNullableQuantity\":\n                        message = param.get(\"message\", {})\n                        if not isinstance(message, dict) or message.get(\"isNull\", True):\n                            return None\n                        expression = message.get(\"expression\")\n                        return expression if isinstance(expression, str) else None\n                    return None\n\n                min_expression = get_param_expression(params, min_param_name)\n                max_expression = get_param_expression(params, max_param_name)\n\n                # Parse expressions to numerical values\n                min_value = parse_onshape_expression(min_expression)\n                max_value = parse_onshape_expression(max_expression)\n\n                # Only store if we got valid values\n                if min_value is not None and max_value is not None:\n                    limits = {\"min\": min_value, \"max\": max_value}\n                    mate_data.limits = limits\n                    sanitized_mate_name = get_sanitized_name(mate_data.name)\n                    update_mate_limits(sanitized_mate_name, limits)\n                    limits_found_count += 1\n                    logger.debug(\n                        f\"Set limits for mate '{mate_data.name}' ({mate_data.mateType}): \"\n                        f\"min={min_value:.4f}, max={max_value:.4f}\"\n                    )\n\n        except Exception as e:\n            logger.warning(f\"Failed to fetch features for assembly {assembly_key or 'root'}: {e}\")\n            continue\n\n    logger.info(f\"Fetched limits for {limits_found_count} mates out of {len(self.mates)} total mates\")\n</code></pre>"},{"location":"api/parse/#onshape_robotics_toolkit.parse.CAD.from_assembly","title":"<code>from_assembly(assembly, max_depth=0, client=None, fetch_mass_properties=True, fetch_mate_properties=True)</code>  <code>classmethod</code>","text":"<p>Create a CAD from an Onshape Assembly.</p> <p>Parameters:</p> Name Type Description Default <code>assembly</code> <code>Assembly</code> <p>Onshape assembly data</p> required <code>max_depth</code> <code>int</code> <p>Maximum depth for flexible assemblies</p> <code>0</code> <p>Returns:</p> Type Description <code>CAD</code> <p>CAD with populated flat dicts</p> Source code in <code>onshape_robotics_toolkit/parse.py</code> <pre><code>@classmethod\ndef from_assembly(\n    cls,\n    assembly: Assembly,\n    max_depth: int = 0,\n    client: Optional[Client] = None,\n    fetch_mass_properties: bool = True,\n    fetch_mate_properties: bool = True,\n) -&gt; \"CAD\":\n    \"\"\"\n    Create a CAD from an Onshape Assembly.\n\n    Args:\n        assembly: Onshape assembly data\n        max_depth: Maximum depth for flexible assemblies\n\n    Returns:\n        CAD with populated flat dicts\n    \"\"\"\n    # Create CAD instance\n    if assembly.document is None:\n        raise ValueError(\"Assembly document is None\")\n\n    cad = cls(\n        document_id=assembly.rootAssembly.documentId,\n        element_id=assembly.rootAssembly.elementId,\n        wtype=assembly.document.wtype,\n        workspace_id=assembly.document.wid,\n        document_microversion=assembly.rootAssembly.documentMicroversion,\n        name=assembly.document.name,  # TODO: this is different from assembly.name\n        max_depth=max_depth,\n        client=client,\n    )\n\n    # Build id_to_name mapping (needed for PathKey creation)\n    id_to_name = cls._build_id_to_name_map(assembly)\n\n    # Build PathKeys from occurrences (single source of truth)\n    cad.keys_by_id, cad.keys_by_name = cls._build_path_keys_from_occurrences(\n        assembly.rootAssembly.occurrences, id_to_name\n    )\n\n    # Populate all data using the pre-built PathKeys\n    cad._populate_from_assembly(assembly)\n\n    if fetch_mate_properties:\n        cad.fetch_mate_limits(client)\n\n    logger.info(f\"Created {cad}\")\n    record_cad_config(max_depth=max_depth)\n\n    if client is not None:\n        estimation = cad.estimate_api_calls(\n            fetch_mass_properties=fetch_mass_properties,\n            fetch_mate_properties=fetch_mate_properties,\n            download_meshes=True,\n        )\n        logger.info(\n            f\"Estimated API calls for CAD to Robot conversion \u2192 Total: {estimation['total']} \"\n            f\"(subassemblies: {estimation['subassemblies']}, \"\n            f\"mass_properties: {estimation['mass_properties']}, \"\n            f\"mate_properties: {estimation['mate_properties']}, \"\n            f\"meshes: {estimation['meshes']})\"\n        )\n\n    return cad\n</code></pre>"},{"location":"api/parse/#onshape_robotics_toolkit.parse.CAD.from_url","title":"<code>from_url(url, *, client, max_depth=0, configuration='default', log_response=True, with_meta_data=True)</code>  <code>classmethod</code>","text":"<p>Create a CAD instance directly from an Onshape document URL.</p> Source code in <code>onshape_robotics_toolkit/parse.py</code> <pre><code>@classmethod\ndef from_url(\n    cls,\n    url: str,\n    *,\n    client: Client,\n    max_depth: int = 0,\n    configuration: str = \"default\",\n    log_response: bool = True,\n    with_meta_data: bool = True,\n) -&gt; \"CAD\":\n    \"\"\"Create a CAD instance directly from an Onshape document URL.\"\"\"\n    base_url, did, wtype, wid, eid = parse_url(url)\n    if client is None:\n        raise ValueError(\"client must be provided to load CAD from URL\")\n\n    document = Document(base_url=base_url, did=did, wtype=wtype, wid=wid, eid=eid, url=url)\n\n    assembly = client.get_assembly(\n        document.did,\n        document.wtype,\n        document.wid,\n        document.eid,\n        configuration=configuration,\n        log_response=log_response,\n        with_meta_data=with_meta_data,\n    )\n\n    return cls.from_assembly(assembly, max_depth=max_depth, client=client)\n</code></pre>"},{"location":"api/parse/#onshape_robotics_toolkit.parse.CAD.get_all_mates_flattened","title":"<code>get_all_mates_flattened()</code>","text":"<p>Get all mates without assembly provenance (backward compatible).</p> <p>If there are duplicate (parent, child) pairs from different assemblies, this will only keep one (last one wins).</p> <p>Returns:</p> Type Description <code>dict[tuple[PathKey, PathKey], MateFeatureData]</code> <p>Dictionary with (parent, child) keys</p> Source code in <code>onshape_robotics_toolkit/parse.py</code> <pre><code>def get_all_mates_flattened(self) -&gt; dict[tuple[PathKey, PathKey], MateFeatureData]:\n    \"\"\"\n    Get all mates without assembly provenance (backward compatible).\n\n    If there are duplicate (parent, child) pairs from different assemblies,\n    this will only keep one (last one wins).\n\n    Returns:\n        Dictionary with (parent, child) keys\n    \"\"\"\n    return {(p, c): mate for (asm, p, c), mate in self.mates.items()}\n</code></pre>"},{"location":"api/parse/#onshape_robotics_toolkit.parse.CAD.get_mate_assembly","title":"<code>get_mate_assembly(parent, child)</code>","text":"<p>Find which assembly contains this mate.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>PathKey</code> <p>Parent PathKey</p> required <code>child</code> <code>PathKey</code> <p>Child PathKey</p> required <p>Returns:</p> Type Description <code>Optional[Optional[PathKey]]</code> <p>None if root assembly, PathKey if subassembly, None if not found</p> Source code in <code>onshape_robotics_toolkit/parse.py</code> <pre><code>def get_mate_assembly(self, parent: PathKey, child: PathKey) -&gt; Optional[Optional[PathKey]]:\n    \"\"\"\n    Find which assembly contains this mate.\n\n    Args:\n        parent: Parent PathKey\n        child: Child PathKey\n\n    Returns:\n        None if root assembly, PathKey if subassembly, None if not found\n    \"\"\"\n    for asm, p, c in self.mates:\n        if p == parent and c == child:\n            return asm  # Returns None for root, PathKey for subassembly\n    return None\n</code></pre>"},{"location":"api/parse/#onshape_robotics_toolkit.parse.CAD.get_mate_data","title":"<code>get_mate_data(parent, child, assembly=None)</code>","text":"<p>Get mate data for specific parent-child pair.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>PathKey</code> <p>Parent PathKey</p> required <code>child</code> <code>PathKey</code> <p>Child PathKey</p> required <code>assembly</code> <code>Optional[PathKey]</code> <p>Assembly PathKey (None for root, PathKey for subassembly)      If None, searches all assemblies (root first)</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[MateFeatureData]</code> <p>MateFeatureData if found, None otherwise</p> Source code in <code>onshape_robotics_toolkit/parse.py</code> <pre><code>def get_mate_data(\n    self, parent: PathKey, child: PathKey, assembly: Optional[PathKey] = None\n) -&gt; Optional[MateFeatureData]:\n    \"\"\"\n    Get mate data for specific parent-child pair.\n\n    Args:\n        parent: Parent PathKey\n        child: Child PathKey\n        assembly: Assembly PathKey (None for root, PathKey for subassembly)\n                 If None, searches all assemblies (root first)\n\n    Returns:\n        MateFeatureData if found, None otherwise\n    \"\"\"\n    if assembly is not None:\n        return self.mates.get((assembly, parent, child))\n    else:\n        mate = self.mates.get((None, parent, child))\n        if mate:\n            return mate\n\n        for (_asm, p, c), mate in self.mates.items():\n            if p == parent and c == child:\n                return mate\n        return None\n</code></pre>"},{"location":"api/parse/#onshape_robotics_toolkit.parse.CAD.get_mates_from_root","title":"<code>get_mates_from_root()</code>","text":"<p>Get only root-level mates (no assembly provenance).</p> <p>Returns:</p> Type Description <code>dict[tuple[PathKey, PathKey], MateFeatureData]</code> <p>Dictionary with (parent, child) keys</p> Source code in <code>onshape_robotics_toolkit/parse.py</code> <pre><code>def get_mates_from_root(self) -&gt; dict[tuple[PathKey, PathKey], MateFeatureData]:\n    \"\"\"\n    Get only root-level mates (no assembly provenance).\n\n    Returns:\n        Dictionary with (parent, child) keys\n    \"\"\"\n    return {(p, c): mate for (asm, p, c), mate in self.mates.items() if asm is None}\n</code></pre>"},{"location":"api/parse/#onshape_robotics_toolkit.parse.CAD.get_mates_from_subassembly","title":"<code>get_mates_from_subassembly(sub_key)</code>","text":"<p>Get mates from specific subassembly.</p> <p>Parameters:</p> Name Type Description Default <code>sub_key</code> <code>PathKey</code> <p>PathKey of the subassembly</p> required <p>Returns:</p> Type Description <code>dict[tuple[PathKey, PathKey], MateFeatureData]</code> <p>Dictionary with (parent, child) keys</p> Source code in <code>onshape_robotics_toolkit/parse.py</code> <pre><code>def get_mates_from_subassembly(self, sub_key: PathKey) -&gt; dict[tuple[PathKey, PathKey], MateFeatureData]:\n    \"\"\"\n    Get mates from specific subassembly.\n\n    Args:\n        sub_key: PathKey of the subassembly\n\n    Returns:\n        Dictionary with (parent, child) keys\n    \"\"\"\n    return {(p, c): mate for (asm, p, c), mate in self.mates.items() if asm == sub_key}\n</code></pre>"},{"location":"api/parse/#onshape_robotics_toolkit.parse.CAD.get_path_key","title":"<code>get_path_key(path)</code>","text":"<p>Get PathKey from an ID path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, list[str], tuple[str, ...]]</code> <p>Instance ID (string) or path (list/tuple of IDs)</p> required <p>Returns:</p> Type Description <code>Optional[PathKey]</code> <p>PathKey if found, None otherwise</p> <p>Examples:</p>"},{"location":"api/parse/#onshape_robotics_toolkit.parse.CAD.get_path_key--from-single-id","title":"From single ID","text":"<p>key = cad.get_path_key(\"M123\")</p>"},{"location":"api/parse/#onshape_robotics_toolkit.parse.CAD.get_path_key--from-path-list","title":"From path list","text":"<p>key = cad.get_path_key([\"M123\", \"M456\"])</p>"},{"location":"api/parse/#onshape_robotics_toolkit.parse.CAD.get_path_key--from-path-tuple","title":"From path tuple","text":"<p>key = cad.get_path_key((\"M123\", \"M456\"))</p> Source code in <code>onshape_robotics_toolkit/parse.py</code> <pre><code>def get_path_key(self, path: Union[str, list[str], tuple[str, ...]]) -&gt; Optional[PathKey]:\n    \"\"\"\n    Get PathKey from an ID path.\n\n    Args:\n        path: Instance ID (string) or path (list/tuple of IDs)\n\n    Returns:\n        PathKey if found, None otherwise\n\n    Examples:\n        # From single ID\n        key = cad.get_path_key(\"M123\")\n\n        # From path list\n        key = cad.get_path_key([\"M123\", \"M456\"])\n\n        # From path tuple\n        key = cad.get_path_key((\"M123\", \"M456\"))\n    \"\"\"\n    path_tuple = (path,) if isinstance(path, str) else tuple(path)\n    return self.keys_by_id.get(path_tuple)\n</code></pre>"},{"location":"api/parse/#onshape_robotics_toolkit.parse.CAD.get_path_key_by_name","title":"<code>get_path_key_by_name(name_path)</code>","text":"<p>Get PathKey from a name path (reverse lookup).</p> <p>Parameters:</p> Name Type Description Default <code>name_path</code> <code>Union[str, list[str], tuple[str, ...]]</code> <p>Instance name (string) or name path (list/tuple of names)</p> required <p>Returns:</p> Type Description <code>Optional[PathKey]</code> <p>PathKey if found, None otherwise</p> <p>Examples:</p>"},{"location":"api/parse/#onshape_robotics_toolkit.parse.CAD.get_path_key_by_name--from-single-name","title":"From single name","text":"<p>key = cad.get_path_key_by_name(\"wheel_1\")</p>"},{"location":"api/parse/#onshape_robotics_toolkit.parse.CAD.get_path_key_by_name--from-name-path-list","title":"From name path list","text":"<p>key = cad.get_path_key_by_name([\"Assembly_1\", \"Part_1\"])</p>"},{"location":"api/parse/#onshape_robotics_toolkit.parse.CAD.get_path_key_by_name--from-name-path-tuple","title":"From name path tuple","text":"<p>key = cad.get_path_key_by_name((\"Assembly_1\", \"Part_1\"))</p> Source code in <code>onshape_robotics_toolkit/parse.py</code> <pre><code>def get_path_key_by_name(self, name_path: Union[str, list[str], tuple[str, ...]]) -&gt; Optional[PathKey]:\n    \"\"\"\n    Get PathKey from a name path (reverse lookup).\n\n    Args:\n        name_path: Instance name (string) or name path (list/tuple of names)\n\n    Returns:\n        PathKey if found, None otherwise\n\n    Examples:\n        # From single name\n        key = cad.get_path_key_by_name(\"wheel_1\")\n\n        # From name path list\n        key = cad.get_path_key_by_name([\"Assembly_1\", \"Part_1\"])\n\n        # From name path tuple\n        key = cad.get_path_key_by_name((\"Assembly_1\", \"Part_1\"))\n    \"\"\"\n    name_tuple = (name_path,) if isinstance(name_path, str) else tuple(name_path)\n    return self.keys_by_name.get(name_tuple)\n</code></pre>"},{"location":"api/parse/#onshape_robotics_toolkit.parse.CAD.get_rigid_assembly_root","title":"<code>get_rigid_assembly_root(key)</code>","text":"<p>Find the top-most rigid assembly root for a given PathKey.</p> <p>Walks up the hierarchy to find the highest-level rigid assembly. This ensures that if an assembly is inside another rigid assembly, we return the outermost one.</p> <p>If the key itself is a rigid assembly, checks if it's inside another rigid assembly. If the key is inside a rigid assembly, returns the top-most rigid assembly's PathKey. If the key is not inside any rigid assembly, returns None.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>PathKey</code> <p>PathKey to find rigid assembly root for</p> required <p>Returns:</p> Type Description <code>Optional[PathKey]</code> <p>PathKey of top-most rigid assembly root, or None if not inside rigid assembly</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Part at depth 2 inside rigid assembly at depth 1\n&gt;&gt;&gt; key = PathKey((\"asm1\", \"sub1\", \"part1\"), (\"Assembly_1\", \"Sub_1\", \"Part_1\"))\n&gt;&gt;&gt; rigid_root = cad.get_rigid_assembly_root(key)\n&gt;&gt;&gt; # Returns PathKey((\"asm1\", \"sub1\"), (\"Assembly_1\", \"Sub_1\"))\n</code></pre> Source code in <code>onshape_robotics_toolkit/parse.py</code> <pre><code>def get_rigid_assembly_root(self, key: PathKey) -&gt; Optional[PathKey]:\n    \"\"\"\n    Find the top-most rigid assembly root for a given PathKey.\n\n    Walks up the hierarchy to find the highest-level rigid assembly.\n    This ensures that if an assembly is inside another rigid assembly,\n    we return the outermost one.\n\n    If the key itself is a rigid assembly, checks if it's inside another rigid assembly.\n    If the key is inside a rigid assembly, returns the top-most rigid assembly's PathKey.\n    If the key is not inside any rigid assembly, returns None.\n\n    Args:\n        key: PathKey to find rigid assembly root for\n\n    Returns:\n        PathKey of top-most rigid assembly root, or None if not inside rigid assembly\n\n    Examples:\n        &gt;&gt;&gt; # Part at depth 2 inside rigid assembly at depth 1\n        &gt;&gt;&gt; key = PathKey((\"asm1\", \"sub1\", \"part1\"), (\"Assembly_1\", \"Sub_1\", \"Part_1\"))\n        &gt;&gt;&gt; rigid_root = cad.get_rigid_assembly_root(key)\n        &gt;&gt;&gt; # Returns PathKey((\"asm1\", \"sub1\"), (\"Assembly_1\", \"Sub_1\"))\n    \"\"\"\n    # Walk up the hierarchy from the key to find ALL rigid assemblies\n    # Return the top-most one (closest to root)\n    rigid_root: Optional[PathKey] = None\n    current: Optional[PathKey] = key\n\n    while current is not None:\n        instance = self.instances.get(current)\n        if isinstance(instance, AssemblyInstance) and instance.isRigid:\n            rigid_root = current  # Keep updating to get the top-most\n        current = current.parent\n\n    return rigid_root\n</code></pre>"},{"location":"api/parse/#onshape_robotics_toolkit.parse.CAD.get_transform","title":"<code>get_transform(key, wrt=None)</code>","text":"<p>Get 4x4 transform matrix for occurrence.</p> Source code in <code>onshape_robotics_toolkit/parse.py</code> <pre><code>def get_transform(self, key: PathKey, wrt: Optional[np.ndarray] = None) -&gt; Optional[np.ndarray]:\n    \"\"\"Get 4x4 transform matrix for occurrence.\"\"\"\n    occ = self.occurrences.get(key)\n\n    if occ:\n        if wrt is not None:\n            return occ.tf_wrt(wrt)\n        else:\n            return occ.tf\n    return None\n</code></pre>"},{"location":"api/parse/#onshape_robotics_toolkit.parse.CAD.is_flexible_assembly","title":"<code>is_flexible_assembly(key)</code>","text":"<p>Check if instance is a flexible assembly.</p> Source code in <code>onshape_robotics_toolkit/parse.py</code> <pre><code>def is_flexible_assembly(self, key: PathKey) -&gt; bool:\n    \"\"\"Check if instance is a flexible assembly.\"\"\"\n    # TODO: this should come out of subassemblies dict\n    instance = self.instances.get(key)\n    return isinstance(instance, AssemblyInstance) and not instance.isRigid\n</code></pre>"},{"location":"api/parse/#onshape_robotics_toolkit.parse.CAD.is_part","title":"<code>is_part(key)</code>","text":"<p>Check if instance is a part.</p> Source code in <code>onshape_robotics_toolkit/parse.py</code> <pre><code>def is_part(self, key: PathKey) -&gt; bool:\n    \"\"\"Check if instance is a part.\"\"\"\n    # TODO: this should come out of parts dict w/ regard to rigid subassemblies\n    return isinstance(self.instances.get(key), PartInstance)\n</code></pre>"},{"location":"api/parse/#onshape_robotics_toolkit.parse.CAD.is_rigid_assembly","title":"<code>is_rigid_assembly(key)</code>","text":"<p>Check if instance is a rigid assembly.</p> Source code in <code>onshape_robotics_toolkit/parse.py</code> <pre><code>def is_rigid_assembly(self, key: PathKey) -&gt; bool:\n    \"\"\"Check if instance is a rigid assembly.\"\"\"\n    # TODO: this should come out of subassemblies dict\n    instance = self.instances.get(key)\n    return isinstance(instance, AssemblyInstance) and instance.isRigid\n</code></pre>"},{"location":"api/parse/#onshape_robotics_toolkit.parse.PathKey","title":"<code>PathKey</code>  <code>dataclass</code>","text":"<p>Immutable path-based key using Onshape's natural ID hierarchy.</p> <p>Stores both ID path (for uniqueness/hashing) and name path (for readability). Both paths are built during CAD population and cached in the PathKey.</p> <p>Examples:</p>"},{"location":"api/parse/#onshape_robotics_toolkit.parse.PathKey--root-level-part-instance","title":"Root-level part instance","text":"<p>PathKey((\"MqRDHdbA0tAm2ygBR\",), (\"wheel_1\",))</p>"},{"location":"api/parse/#onshape_robotics_toolkit.parse.PathKey--nested-part-in-subassembly","title":"Nested part in subassembly","text":"<p>PathKey(     (\"MoN/4FhyvQ92+I8TU\", \"MZHBlAU4IxmX6u6A0\", \"MrpOYQ6mQsyqwPVz0\"),     (\"assembly_1\", \"subassembly_2\", \"part_3\") )</p> Source code in <code>onshape_robotics_toolkit/parse.py</code> <pre><code>@dataclass(frozen=True, slots=True)\nclass PathKey:\n    \"\"\"\n    Immutable path-based key using Onshape's natural ID hierarchy.\n\n    Stores both ID path (for uniqueness/hashing) and name path (for readability).\n    Both paths are built during CAD population and cached in the PathKey.\n\n    Examples:\n        # Root-level part instance\n        PathKey((\"MqRDHdbA0tAm2ygBR\",), (\"wheel_1\",))\n\n        # Nested part in subassembly\n        PathKey(\n            (\"MoN/4FhyvQ92+I8TU\", \"MZHBlAU4IxmX6u6A0\", \"MrpOYQ6mQsyqwPVz0\"),\n            (\"assembly_1\", \"subassembly_2\", \"part_3\")\n        )\n    \"\"\"\n\n    _path: tuple[str, ...]\n    _name_path: tuple[str, ...]\n\n    def __init__(self, path: tuple[str, ...], name_path: tuple[str, ...]):\n        \"\"\"\n        Create a PathKey from tuples of instance IDs and names.\n\n        Args:\n            path: Tuple of Onshape instance IDs representing hierarchical position\n            name_path: Tuple of sanitized names parallel to path\n        \"\"\"\n        if len(path) != len(name_path):\n            raise ValueError(f\"path and name_path must have same length: {len(path)} != {len(name_path)}\")\n\n        object.__setattr__(self, \"_path\", path)\n        object.__setattr__(self, \"_name_path\", name_path)\n\n    @property\n    def path(self) -&gt; tuple[str, ...]:\n        \"\"\"Get the immutable ID path tuple.\"\"\"\n        return self._path\n\n    @property\n    def name_path(self) -&gt; tuple[str, ...]:\n        \"\"\"Get the immutable name path tuple.\"\"\"\n        return self._name_path\n\n    @property\n    def leaf(self) -&gt; str:\n        \"\"\"Get the last ID in the path (the actual entity ID).\"\"\"\n        return self._path[-1] if self._path else \"\"\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"Get the last name in the path (human-readable leaf name).\"\"\"\n        return self._name_path[-1] if self._name_path else \"\"\n\n    @property\n    def parent(self) -&gt; Optional[\"PathKey\"]:\n        \"\"\"Get parent PathKey by trimming last element.\"\"\"\n        if len(self._path) &lt;= 1:\n            return None\n        return PathKey(self._path[:-1], self._name_path[:-1])\n\n    @property\n    def root(self) -&gt; Optional[str]:\n        \"\"\"Get the root ID (first element in path).\"\"\"\n        return self._path[0] if self._path else None\n\n    @property\n    def depth(self) -&gt; int:\n        \"\"\"Get depth in hierarchy (0 = root level).\"\"\"\n        return len(self._path) - 1\n\n    def __repr__(self) -&gt; str:\n        return f\"PathKey({self._path})\"\n\n    def __str__(self) -&gt; str:\n        \"\"\"String representation showing the name path structure.\"\"\"\n        return \"_\".join(self._name_path) if self._name_path else \"(empty)\"\n\n    def __lt__(self, other: \"PathKey\") -&gt; bool:\n        \"\"\"\n        Less-than comparison for sorting PathKeys.\n\n        Compares by depth first, then lexicographically by path elements.\n        This ensures consistent ordering for visualization and debugging.\n\n        Args:\n            other: Another PathKey to compare with\n\n        Returns:\n            True if this PathKey should sort before other\n        \"\"\"\n        if not isinstance(other, PathKey):\n            return NotImplemented\n        # Sort by depth first (shallower first), then by path\n        return (self.depth, self._path) &lt; (other.depth, other._path)\n\n    def __le__(self, other: \"PathKey\") -&gt; bool:\n        \"\"\"Less-than-or-equal comparison.\"\"\"\n        if not isinstance(other, PathKey):\n            return NotImplemented\n        return (self.depth, self._path) &lt;= (other.depth, other._path)\n\n    def __gt__(self, other: \"PathKey\") -&gt; bool:\n        \"\"\"Greater-than comparison.\"\"\"\n        if not isinstance(other, PathKey):\n            return NotImplemented\n        return (self.depth, self._path) &gt; (other.depth, other._path)\n\n    def __ge__(self, other: \"PathKey\") -&gt; bool:\n        \"\"\"Greater-than-or-equal comparison.\"\"\"\n        if not isinstance(other, PathKey):\n            return NotImplemented\n        return (self.depth, self._path) &gt;= (other.depth, other._path)\n\n    @classmethod\n    def from_path(cls, path: Union[list[str], str], id_to_name: dict[str, str]) -&gt; \"PathKey\":\n        \"\"\"\n        Create PathKey from a path (list) or single instance ID (string).\n\n        This handles both:\n        - occurrence.path from JSON (list of IDs)\n        - matedOccurrence from mate features (list of IDs)\n        - single instance ID for root-level instances (string)\n\n        Args:\n            path: Either a list of instance IDs or a single instance ID string\n            id_to_name: Mapping from instance ID to sanitized name\n\n        Returns:\n            PathKey with both ID and name paths\n\n        Examples:\n            # From occurrence JSON (list)\n            occ_key = PathKey.from_path(occurrence.path, id_to_name)\n            # PathKey((\"MoN/4FhyvQ92+I8TU\", \"MM10pxoGk/3TUSoYG\"), (\"asm_1\", \"part_2\"))\n\n            # From single instance ID (string)\n            part_key = PathKey.from_path(\"MqRDHdbA0tAm2ygBR\", id_to_name)\n            # PathKey((\"MqRDHdbA0tAm2ygBR\",), (\"wheel_1\",))\n        \"\"\"\n        # Single instance ID -&gt; single-element tuple, otherwise convert list to tuple\n        id_tuple = (path,) if isinstance(path, str) else tuple(path)\n        try:\n            name_tuple = tuple(id_to_name[instance_id] for instance_id in id_tuple)\n        except KeyError as e:\n            raise KeyError(f\"Instance ID {e} not found in id_to_name mapping\") from e\n\n        return cls(id_tuple, name_tuple)\n</code></pre>"},{"location":"api/parse/#onshape_robotics_toolkit.parse.PathKey.depth","title":"<code>depth</code>  <code>property</code>","text":"<p>Get depth in hierarchy (0 = root level).</p>"},{"location":"api/parse/#onshape_robotics_toolkit.parse.PathKey.leaf","title":"<code>leaf</code>  <code>property</code>","text":"<p>Get the last ID in the path (the actual entity ID).</p>"},{"location":"api/parse/#onshape_robotics_toolkit.parse.PathKey.name","title":"<code>name</code>  <code>property</code>","text":"<p>Get the last name in the path (human-readable leaf name).</p>"},{"location":"api/parse/#onshape_robotics_toolkit.parse.PathKey.name_path","title":"<code>name_path</code>  <code>property</code>","text":"<p>Get the immutable name path tuple.</p>"},{"location":"api/parse/#onshape_robotics_toolkit.parse.PathKey.parent","title":"<code>parent</code>  <code>property</code>","text":"<p>Get parent PathKey by trimming last element.</p>"},{"location":"api/parse/#onshape_robotics_toolkit.parse.PathKey.path","title":"<code>path</code>  <code>property</code>","text":"<p>Get the immutable ID path tuple.</p>"},{"location":"api/parse/#onshape_robotics_toolkit.parse.PathKey.root","title":"<code>root</code>  <code>property</code>","text":"<p>Get the root ID (first element in path).</p>"},{"location":"api/parse/#onshape_robotics_toolkit.parse.PathKey.__ge__","title":"<code>__ge__(other)</code>","text":"<p>Greater-than-or-equal comparison.</p> Source code in <code>onshape_robotics_toolkit/parse.py</code> <pre><code>def __ge__(self, other: \"PathKey\") -&gt; bool:\n    \"\"\"Greater-than-or-equal comparison.\"\"\"\n    if not isinstance(other, PathKey):\n        return NotImplemented\n    return (self.depth, self._path) &gt;= (other.depth, other._path)\n</code></pre>"},{"location":"api/parse/#onshape_robotics_toolkit.parse.PathKey.__gt__","title":"<code>__gt__(other)</code>","text":"<p>Greater-than comparison.</p> Source code in <code>onshape_robotics_toolkit/parse.py</code> <pre><code>def __gt__(self, other: \"PathKey\") -&gt; bool:\n    \"\"\"Greater-than comparison.\"\"\"\n    if not isinstance(other, PathKey):\n        return NotImplemented\n    return (self.depth, self._path) &gt; (other.depth, other._path)\n</code></pre>"},{"location":"api/parse/#onshape_robotics_toolkit.parse.PathKey.__init__","title":"<code>__init__(path, name_path)</code>","text":"<p>Create a PathKey from tuples of instance IDs and names.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>tuple[str, ...]</code> <p>Tuple of Onshape instance IDs representing hierarchical position</p> required <code>name_path</code> <code>tuple[str, ...]</code> <p>Tuple of sanitized names parallel to path</p> required Source code in <code>onshape_robotics_toolkit/parse.py</code> <pre><code>def __init__(self, path: tuple[str, ...], name_path: tuple[str, ...]):\n    \"\"\"\n    Create a PathKey from tuples of instance IDs and names.\n\n    Args:\n        path: Tuple of Onshape instance IDs representing hierarchical position\n        name_path: Tuple of sanitized names parallel to path\n    \"\"\"\n    if len(path) != len(name_path):\n        raise ValueError(f\"path and name_path must have same length: {len(path)} != {len(name_path)}\")\n\n    object.__setattr__(self, \"_path\", path)\n    object.__setattr__(self, \"_name_path\", name_path)\n</code></pre>"},{"location":"api/parse/#onshape_robotics_toolkit.parse.PathKey.__le__","title":"<code>__le__(other)</code>","text":"<p>Less-than-or-equal comparison.</p> Source code in <code>onshape_robotics_toolkit/parse.py</code> <pre><code>def __le__(self, other: \"PathKey\") -&gt; bool:\n    \"\"\"Less-than-or-equal comparison.\"\"\"\n    if not isinstance(other, PathKey):\n        return NotImplemented\n    return (self.depth, self._path) &lt;= (other.depth, other._path)\n</code></pre>"},{"location":"api/parse/#onshape_robotics_toolkit.parse.PathKey.__lt__","title":"<code>__lt__(other)</code>","text":"<p>Less-than comparison for sorting PathKeys.</p> <p>Compares by depth first, then lexicographically by path elements. This ensures consistent ordering for visualization and debugging.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>PathKey</code> <p>Another PathKey to compare with</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if this PathKey should sort before other</p> Source code in <code>onshape_robotics_toolkit/parse.py</code> <pre><code>def __lt__(self, other: \"PathKey\") -&gt; bool:\n    \"\"\"\n    Less-than comparison for sorting PathKeys.\n\n    Compares by depth first, then lexicographically by path elements.\n    This ensures consistent ordering for visualization and debugging.\n\n    Args:\n        other: Another PathKey to compare with\n\n    Returns:\n        True if this PathKey should sort before other\n    \"\"\"\n    if not isinstance(other, PathKey):\n        return NotImplemented\n    # Sort by depth first (shallower first), then by path\n    return (self.depth, self._path) &lt; (other.depth, other._path)\n</code></pre>"},{"location":"api/parse/#onshape_robotics_toolkit.parse.PathKey.__str__","title":"<code>__str__()</code>","text":"<p>String representation showing the name path structure.</p> Source code in <code>onshape_robotics_toolkit/parse.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"String representation showing the name path structure.\"\"\"\n    return \"_\".join(self._name_path) if self._name_path else \"(empty)\"\n</code></pre>"},{"location":"api/parse/#onshape_robotics_toolkit.parse.PathKey.from_path","title":"<code>from_path(path, id_to_name)</code>  <code>classmethod</code>","text":"<p>Create PathKey from a path (list) or single instance ID (string).</p> <p>This handles both: - occurrence.path from JSON (list of IDs) - matedOccurrence from mate features (list of IDs) - single instance ID for root-level instances (string)</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[list[str], str]</code> <p>Either a list of instance IDs or a single instance ID string</p> required <code>id_to_name</code> <code>dict[str, str]</code> <p>Mapping from instance ID to sanitized name</p> required <p>Returns:</p> Type Description <code>PathKey</code> <p>PathKey with both ID and name paths</p> <p>Examples:</p>"},{"location":"api/parse/#onshape_robotics_toolkit.parse.PathKey.from_path--from-occurrence-json-list","title":"From occurrence JSON (list)","text":"<p>occ_key = PathKey.from_path(occurrence.path, id_to_name)</p>"},{"location":"api/parse/#onshape_robotics_toolkit.parse.PathKey.from_path--pathkeymon4fhyvq92i8tu-mm10pxogk3tusoyg-asm_1-part_2","title":"PathKey((\"MoN/4FhyvQ92+I8TU\", \"MM10pxoGk/3TUSoYG\"), (\"asm_1\", \"part_2\"))","text":""},{"location":"api/parse/#onshape_robotics_toolkit.parse.PathKey.from_path--from-single-instance-id-string","title":"From single instance ID (string)","text":"<p>part_key = PathKey.from_path(\"MqRDHdbA0tAm2ygBR\", id_to_name)</p>"},{"location":"api/parse/#onshape_robotics_toolkit.parse.PathKey.from_path--pathkeymqrdhdba0tam2ygbr-wheel_1","title":"PathKey((\"MqRDHdbA0tAm2ygBR\",), (\"wheel_1\",))","text":"Source code in <code>onshape_robotics_toolkit/parse.py</code> <pre><code>@classmethod\ndef from_path(cls, path: Union[list[str], str], id_to_name: dict[str, str]) -&gt; \"PathKey\":\n    \"\"\"\n    Create PathKey from a path (list) or single instance ID (string).\n\n    This handles both:\n    - occurrence.path from JSON (list of IDs)\n    - matedOccurrence from mate features (list of IDs)\n    - single instance ID for root-level instances (string)\n\n    Args:\n        path: Either a list of instance IDs or a single instance ID string\n        id_to_name: Mapping from instance ID to sanitized name\n\n    Returns:\n        PathKey with both ID and name paths\n\n    Examples:\n        # From occurrence JSON (list)\n        occ_key = PathKey.from_path(occurrence.path, id_to_name)\n        # PathKey((\"MoN/4FhyvQ92+I8TU\", \"MM10pxoGk/3TUSoYG\"), (\"asm_1\", \"part_2\"))\n\n        # From single instance ID (string)\n        part_key = PathKey.from_path(\"MqRDHdbA0tAm2ygBR\", id_to_name)\n        # PathKey((\"MqRDHdbA0tAm2ygBR\",), (\"wheel_1\",))\n    \"\"\"\n    # Single instance ID -&gt; single-element tuple, otherwise convert list to tuple\n    id_tuple = (path,) if isinstance(path, str) else tuple(path)\n    try:\n        name_tuple = tuple(id_to_name[instance_id] for instance_id in id_tuple)\n    except KeyError as e:\n        raise KeyError(f\"Instance ID {e} not found in id_to_name mapping\") from e\n\n    return cls(id_tuple, name_tuple)\n</code></pre>"},{"location":"api/robot/","title":"Robot","text":"<p>This module contains classes for creating a URDF robot model</p> Dataclass <ul> <li>Robot: Represents a robot model in URDF format, containing links and joints.</li> </ul>"},{"location":"api/robot/#onshape_robotics_toolkit.robot.Robot","title":"<code>Robot</code>","text":"<p>               Bases: <code>DiGraph</code></p> <p>Represents a robot model with a graph structure for links and joints.</p> <p>The Robot class is the final output of the CAD \u2192 KinematicGraph \u2192 Robot pipeline. It stores the robot structure as a NetworkX directed graph where nodes are links and edges are joints, along with associated STL assets.</p> <p>Recommended Creation Methods: - <code>Robot.from_graph()</code>: Create from pre-built CAD + KinematicGraph (most efficient) - <code>Robot.from_url()</code>: Create directly from Onshape URL (most convenient)</p> <p>Attributes:     name (str): The name of the robot     kinematic_graph (KinematicGraph): The kinematic graph used to create the robot     graph (nx.DiGraph): Graph structure holding links (nodes) and joints (edges)</p> <p>Key Methods:     show_tree: Display the robot's graph as a tree structure     show_graph: Display the robot's graph as a directed graph     from_graph: Create robot from KinematicGraph (recommended)     from_url: Create robot from Onshape URL</p> <p>Serialization: To export the robot to URDF or MJCF formats, use the format-specific serializers from the <code>onshape_robotics_toolkit.formats</code> module:</p> <pre><code>&gt;&gt;&gt; from onshape_robotics_toolkit.formats import URDFSerializer, MJCFSerializer, MJCFConfig\n&gt;&gt;&gt; # URDF export\n&gt;&gt;&gt; urdf_serializer = URDFSerializer()\n&gt;&gt;&gt; urdf_serializer.save(robot, \"robot.urdf\", download_assets=True)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # MJCF export with configuration\n&gt;&gt;&gt; mjcf_config = MJCFConfig(position=(0, 0, 1), add_ground_plane=True)\n&gt;&gt;&gt; mjcf_serializer = MJCFSerializer(mjcf_config)\n&gt;&gt;&gt; mjcf_serializer.save(robot, \"robot.xml\", download_assets=True)\n</code></pre> <p>Example:     &gt;&gt;&gt; from onshape_robotics_toolkit.connect import Client     &gt;&gt;&gt; from onshape_robotics_toolkit.graph import KinematicGraph     &gt;&gt;&gt; from onshape_robotics_toolkit.formats import URDFSerializer     &gt;&gt;&gt;     &gt;&gt;&gt; # Option 1: From URL (convenient)     &gt;&gt;&gt; robot = Robot.from_url(     ...     name=\"my_robot\",     ...     url=\"https://cad.onshape.com/documents/...\",     ...     client=Client(),     ...     max_depth=1     ... )     &gt;&gt;&gt;     &gt;&gt;&gt; # Option 2: From KinematicGraph (efficient, more control)     &gt;&gt;&gt; graph = KinematicGraph.from_cad(cad, use_user_defined_root=True)     &gt;&gt;&gt; robot = Robot.from_graph(graph, Client(), \"my_robot\")     &gt;&gt;&gt;     &gt;&gt;&gt; # Save to file using format serializers     &gt;&gt;&gt; serializer = URDFSerializer()     &gt;&gt;&gt; serializer.save(robot, \"robot.urdf\", download_assets=True)</p> Source code in <code>onshape_robotics_toolkit/robot.py</code> <pre><code>class Robot(nx.DiGraph):\n    \"\"\"\n    Represents a robot model with a graph structure for links and joints.\n\n    The Robot class is the final output of the CAD \u2192 KinematicGraph \u2192 Robot pipeline.\n    It stores the robot structure as a NetworkX directed graph where nodes are links\n    and edges are joints, along with associated STL assets.\n\n    **Recommended Creation Methods:**\n    - `Robot.from_graph()`: Create from pre-built CAD + KinematicGraph (most efficient)\n    - `Robot.from_url()`: Create directly from Onshape URL (most convenient)\n\n    **Attributes:**\n        name (str): The name of the robot\n        kinematic_graph (KinematicGraph): The kinematic graph used to create the robot\n        graph (nx.DiGraph): Graph structure holding links (nodes) and joints (edges)\n\n    **Key Methods:**\n        show_tree: Display the robot's graph as a tree structure\n        show_graph: Display the robot's graph as a directed graph\n        from_graph: Create robot from KinematicGraph (recommended)\n        from_url: Create robot from Onshape URL\n\n    **Serialization:**\n    To export the robot to URDF or MJCF formats, use the format-specific serializers\n    from the `onshape_robotics_toolkit.formats` module:\n\n        &gt;&gt;&gt; from onshape_robotics_toolkit.formats import URDFSerializer, MJCFSerializer, MJCFConfig\n        &gt;&gt;&gt; # URDF export\n        &gt;&gt;&gt; urdf_serializer = URDFSerializer()\n        &gt;&gt;&gt; urdf_serializer.save(robot, \"robot.urdf\", download_assets=True)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # MJCF export with configuration\n        &gt;&gt;&gt; mjcf_config = MJCFConfig(position=(0, 0, 1), add_ground_plane=True)\n        &gt;&gt;&gt; mjcf_serializer = MJCFSerializer(mjcf_config)\n        &gt;&gt;&gt; mjcf_serializer.save(robot, \"robot.xml\", download_assets=True)\n\n    **Example:**\n        &gt;&gt;&gt; from onshape_robotics_toolkit.connect import Client\n        &gt;&gt;&gt; from onshape_robotics_toolkit.graph import KinematicGraph\n        &gt;&gt;&gt; from onshape_robotics_toolkit.formats import URDFSerializer\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Option 1: From URL (convenient)\n        &gt;&gt;&gt; robot = Robot.from_url(\n        ...     name=\"my_robot\",\n        ...     url=\"https://cad.onshape.com/documents/...\",\n        ...     client=Client(),\n        ...     max_depth=1\n        ... )\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Option 2: From KinematicGraph (efficient, more control)\n        &gt;&gt;&gt; graph = KinematicGraph.from_cad(cad, use_user_defined_root=True)\n        &gt;&gt;&gt; robot = Robot.from_graph(graph, Client(), \"my_robot\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Save to file using format serializers\n        &gt;&gt;&gt; serializer = URDFSerializer()\n        &gt;&gt;&gt; serializer.save(robot, \"robot.urdf\", download_assets=True)\n    \"\"\"\n\n    def __init__(self, kinematic_graph: KinematicGraph, name: str):\n        \"\"\"\n        Initialize a Robot instance.\n\n        Args:\n            kinematic_graph: The kinematic graph containing robot structure\n            name: The name of the robot\n\n        Note:\n            This constructor is typically not called directly. Use Robot.from_graph()\n            to create robot instances from kinematic graphs.\n        \"\"\"\n        self.kinematic_graph: KinematicGraph = kinematic_graph\n        super().__init__(name=name)\n\n    # TODO: implement from URDF method with PathKeys and new graph system\n    @classmethod\n    def from_graph(\n        cls,\n        kinematic_graph: \"KinematicGraph\",\n        client: Client,\n        name: str,\n        fetch_mass_properties: bool = True,\n    ) -&gt; \"Robot\":\n        \"\"\"\n        Create a Robot from pre-built CAD and KinematicGraph objects.\n\n        This is the recommended method for creating robots when you already have\n        CAD and KinematicGraph instances. It handles mass property fetching\n        and robot generation in an efficient, streamlined way.\n\n        Args:\n            kinematic_graph: Kinematic graph with parts and mates\n            client: Onshape client for downloading assets and fetching mass properties\n            name: The name of the robot\n            fetch_mass_properties: Whether to fetch mass properties for kinematic parts\n\n        Returns:\n            Robot: The generated robot model\n\n        Example:\n            &gt;&gt;&gt; from onshape_robotics_toolkit.parse import CAD\n            &gt;&gt;&gt; from onshape_robotics_toolkit.graph import KinematicGraph\n            &gt;&gt;&gt; from onshape_robotics_toolkit.formats import URDFSerializer\n            &gt;&gt;&gt; cad = CAD.from_assembly(assembly, max_depth=1)\n            &gt;&gt;&gt; graph = KinematicGraph.from_cad(cad, use_user_defined_root=True)\n            &gt;&gt;&gt; robot = Robot.from_graph(graph, client, \"my_robot\")\n            &gt;&gt;&gt; # Save using format serializers\n            &gt;&gt;&gt; serializer = URDFSerializer()\n            &gt;&gt;&gt; serializer.save(robot, \"robot.urdf\", download_assets=True)\n        \"\"\"\n        # Check for empty kinematic graph\n        if len(kinematic_graph.nodes) == 0:\n            raise ValueError(\n                \"Cannot create robot from empty kinematic graph. \"\n                \"The assembly contains only mate groups with no rigid assemblies or fixed parts. \"\n                \"Cannot determine a root link for the robot. \"\n                \"Mark at least one part or subassembly as fixed in Onshape, or ensure rigid assemblies exist.\"\n            )\n\n        if fetch_mass_properties:\n            asyncio.run(kinematic_graph.cad.fetch_mass_properties_for_parts(client))\n\n        # Generate robot structure from kinematic graph\n        robot = cls(\n            kinematic_graph=kinematic_graph,\n            name=name,\n        )\n        record_robot_config(\n            name=name,\n            fetch_mass_properties=fetch_mass_properties,\n        )\n\n        # Get root node from kinematic graph\n        if kinematic_graph.root is None:\n            raise ValueError(\"Kinematic graph has no root node\")\n\n        root_key = kinematic_graph.root\n        logger.info(f\"Processing root node: {root_key}\")\n\n        root_part = robot.kinematic_graph.nodes[root_key][\"data\"]\n        # NOTE: make sure Pathkey.__str__ produces names without\n        # special characters that are invalid in URDF/MJCF\n        root_default_name = str(root_key)\n        root_name = resolve_part_name(root_default_name)\n        root_link, world_to_root_link, root_asset = get_robot_link(\n            name=root_name,\n            part=root_part,\n            client=client,\n            mate=None,\n        )\n\n        robot.add_node(root_key, data=root_link, asset=root_asset, world_to_link_tf=world_to_root_link)\n        logger.info(f\"Processing {len(kinematic_graph.edges)} edges in the kinematic graph.\")\n\n        used_joint_names: set[str] = set()\n\n        # Process edges in topological order\n        for parent_key, child_key in robot.kinematic_graph.edges:\n            logger.info(f\"Processing edge: {parent_key} \u2192 {child_key}\")\n\n            # Get parent transform\n            world_to_parent_tf = robot.nodes[parent_key][\"world_to_link_tf\"]\n\n            robot.kinematic_graph.nodes[parent_key][\"data\"]\n            child_part: Part = robot.kinematic_graph.nodes[child_key][\"data\"]\n\n            # Get mate data from graph edge\n            mate_data: MateFeatureData = robot.kinematic_graph.get_edge_data(parent_key, child_key)[\"data\"]\n            if mate_data is None:\n                logger.warning(f\"No mate data found for edge {parent_key} \u2192 {child_key}. Skipping.\")\n                continue\n\n            # Check for mate relations (mimic joints)\n            joint_mimic = None\n            # TODO: Implement mate relation support with PathKey system\n            # This will require updating the relation processing to use PathKeys\n\n            # Create/get joint(s)\n            # For spherical joints, dummy links and joints are created\n            joints_dict, links_dict = get_robot_joint(\n                parent_key=parent_key,\n                child_key=child_key,\n                mate=mate_data,\n                world_to_parent_tf=world_to_parent_tf,\n                used_joint_names=used_joint_names,\n                mimic=joint_mimic,\n            )\n\n            # Create child link\n            child_default_name = str(child_key)\n            child_name = resolve_part_name(child_default_name)\n\n            link, world_to_link_tf, asset = get_robot_link(\n                name=child_name,\n                part=child_part,\n                client=client,\n                mate=mate_data,\n            )\n\n            # Add child link if not already in graph\n            if child_key not in robot.nodes:\n                robot.add_node(child_key, data=link, asset=asset, world_to_link_tf=world_to_link_tf)\n            else:\n                # NOTE: possible cause for this: the kinematic graph has a loop\n                logger.warning(f\"Link {child_key} already exists in the robot graph. Skipping.\")\n\n            if links_dict is not None:\n                for _link_key, _link in links_dict.items():\n                    if _link_key not in robot.nodes:\n                        robot.add_node(\n                            _link_key,\n                            data=_link,\n                            asset=None,\n                            world_to_link_tf=None,\n                        )\n                    else:\n                        logger.warning(f\"Link {_link_key} already exists in the robot graph. Skipping.\")\n\n            # Add joints\n            for _joint_key, _joint_data in joints_dict.items():\n                robot.add_edge(_joint_key[0], _joint_key[1], data=_joint_data)\n\n        return robot\n\n    def show_tree(self) -&gt; None:\n        \"\"\"Display the robot's graph as a tree structure.\"\"\"\n\n        def print_tree(node: str, depth: int = 0) -&gt; None:\n            prefix = \"    \" * depth\n            print(f\"{prefix}{node}\")\n            for child in self.kinematic_graph.successors(node):\n                print_tree(child, depth + 1)\n\n        root_nodes = [n for n in self.kinematic_graph.nodes if self.kinematic_graph.in_degree(n) == 0]\n        for root in root_nodes:\n            print_tree(root)\n\n    async def _download_assets(self, mesh_dir: Optional[str] = None) -&gt; None:\n        \"\"\"Asynchronously download the assets.\n\n        Args:\n            mesh_dir: Optional custom directory for mesh files. If provided, updates all assets\n                to use this directory before downloading.\n        \"\"\"\n        tasks = []\n        for _node, data in self.nodes(data=True):\n            asset = data.get(\"asset\")\n            if asset and not asset.is_from_file:\n                # Update asset's mesh directory if specified\n                if mesh_dir is not None:\n                    asset.mesh_dir = mesh_dir\n                tasks.append(asset.download())\n        try:\n            await asyncio.gather(*tasks)\n            logger.info(\"All assets downloaded successfully.\")\n        except Exception as e:\n            logger.error(f\"Error downloading assets: {e}\")\n</code></pre>"},{"location":"api/robot/#onshape_robotics_toolkit.robot.Robot.__init__","title":"<code>__init__(kinematic_graph, name)</code>","text":"<p>Initialize a Robot instance.</p> <p>Parameters:</p> Name Type Description Default <code>kinematic_graph</code> <code>KinematicGraph</code> <p>The kinematic graph containing robot structure</p> required <code>name</code> <code>str</code> <p>The name of the robot</p> required Note <p>This constructor is typically not called directly. Use Robot.from_graph() to create robot instances from kinematic graphs.</p> Source code in <code>onshape_robotics_toolkit/robot.py</code> <pre><code>def __init__(self, kinematic_graph: KinematicGraph, name: str):\n    \"\"\"\n    Initialize a Robot instance.\n\n    Args:\n        kinematic_graph: The kinematic graph containing robot structure\n        name: The name of the robot\n\n    Note:\n        This constructor is typically not called directly. Use Robot.from_graph()\n        to create robot instances from kinematic graphs.\n    \"\"\"\n    self.kinematic_graph: KinematicGraph = kinematic_graph\n    super().__init__(name=name)\n</code></pre>"},{"location":"api/robot/#onshape_robotics_toolkit.robot.Robot.from_graph","title":"<code>from_graph(kinematic_graph, client, name, fetch_mass_properties=True)</code>  <code>classmethod</code>","text":"<p>Create a Robot from pre-built CAD and KinematicGraph objects.</p> <p>This is the recommended method for creating robots when you already have CAD and KinematicGraph instances. It handles mass property fetching and robot generation in an efficient, streamlined way.</p> <p>Parameters:</p> Name Type Description Default <code>kinematic_graph</code> <code>KinematicGraph</code> <p>Kinematic graph with parts and mates</p> required <code>client</code> <code>Client</code> <p>Onshape client for downloading assets and fetching mass properties</p> required <code>name</code> <code>str</code> <p>The name of the robot</p> required <code>fetch_mass_properties</code> <code>bool</code> <p>Whether to fetch mass properties for kinematic parts</p> <code>True</code> <p>Returns:</p> Name Type Description <code>Robot</code> <code>Robot</code> <p>The generated robot model</p> Example <p>from onshape_robotics_toolkit.parse import CAD from onshape_robotics_toolkit.graph import KinematicGraph from onshape_robotics_toolkit.formats import URDFSerializer cad = CAD.from_assembly(assembly, max_depth=1) graph = KinematicGraph.from_cad(cad, use_user_defined_root=True) robot = Robot.from_graph(graph, client, \"my_robot\")</p> Source code in <code>onshape_robotics_toolkit/robot.py</code> <pre><code>@classmethod\ndef from_graph(\n    cls,\n    kinematic_graph: \"KinematicGraph\",\n    client: Client,\n    name: str,\n    fetch_mass_properties: bool = True,\n) -&gt; \"Robot\":\n    \"\"\"\n    Create a Robot from pre-built CAD and KinematicGraph objects.\n\n    This is the recommended method for creating robots when you already have\n    CAD and KinematicGraph instances. It handles mass property fetching\n    and robot generation in an efficient, streamlined way.\n\n    Args:\n        kinematic_graph: Kinematic graph with parts and mates\n        client: Onshape client for downloading assets and fetching mass properties\n        name: The name of the robot\n        fetch_mass_properties: Whether to fetch mass properties for kinematic parts\n\n    Returns:\n        Robot: The generated robot model\n\n    Example:\n        &gt;&gt;&gt; from onshape_robotics_toolkit.parse import CAD\n        &gt;&gt;&gt; from onshape_robotics_toolkit.graph import KinematicGraph\n        &gt;&gt;&gt; from onshape_robotics_toolkit.formats import URDFSerializer\n        &gt;&gt;&gt; cad = CAD.from_assembly(assembly, max_depth=1)\n        &gt;&gt;&gt; graph = KinematicGraph.from_cad(cad, use_user_defined_root=True)\n        &gt;&gt;&gt; robot = Robot.from_graph(graph, client, \"my_robot\")\n        &gt;&gt;&gt; # Save using format serializers\n        &gt;&gt;&gt; serializer = URDFSerializer()\n        &gt;&gt;&gt; serializer.save(robot, \"robot.urdf\", download_assets=True)\n    \"\"\"\n    # Check for empty kinematic graph\n    if len(kinematic_graph.nodes) == 0:\n        raise ValueError(\n            \"Cannot create robot from empty kinematic graph. \"\n            \"The assembly contains only mate groups with no rigid assemblies or fixed parts. \"\n            \"Cannot determine a root link for the robot. \"\n            \"Mark at least one part or subassembly as fixed in Onshape, or ensure rigid assemblies exist.\"\n        )\n\n    if fetch_mass_properties:\n        asyncio.run(kinematic_graph.cad.fetch_mass_properties_for_parts(client))\n\n    # Generate robot structure from kinematic graph\n    robot = cls(\n        kinematic_graph=kinematic_graph,\n        name=name,\n    )\n    record_robot_config(\n        name=name,\n        fetch_mass_properties=fetch_mass_properties,\n    )\n\n    # Get root node from kinematic graph\n    if kinematic_graph.root is None:\n        raise ValueError(\"Kinematic graph has no root node\")\n\n    root_key = kinematic_graph.root\n    logger.info(f\"Processing root node: {root_key}\")\n\n    root_part = robot.kinematic_graph.nodes[root_key][\"data\"]\n    # NOTE: make sure Pathkey.__str__ produces names without\n    # special characters that are invalid in URDF/MJCF\n    root_default_name = str(root_key)\n    root_name = resolve_part_name(root_default_name)\n    root_link, world_to_root_link, root_asset = get_robot_link(\n        name=root_name,\n        part=root_part,\n        client=client,\n        mate=None,\n    )\n\n    robot.add_node(root_key, data=root_link, asset=root_asset, world_to_link_tf=world_to_root_link)\n    logger.info(f\"Processing {len(kinematic_graph.edges)} edges in the kinematic graph.\")\n\n    used_joint_names: set[str] = set()\n\n    # Process edges in topological order\n    for parent_key, child_key in robot.kinematic_graph.edges:\n        logger.info(f\"Processing edge: {parent_key} \u2192 {child_key}\")\n\n        # Get parent transform\n        world_to_parent_tf = robot.nodes[parent_key][\"world_to_link_tf\"]\n\n        robot.kinematic_graph.nodes[parent_key][\"data\"]\n        child_part: Part = robot.kinematic_graph.nodes[child_key][\"data\"]\n\n        # Get mate data from graph edge\n        mate_data: MateFeatureData = robot.kinematic_graph.get_edge_data(parent_key, child_key)[\"data\"]\n        if mate_data is None:\n            logger.warning(f\"No mate data found for edge {parent_key} \u2192 {child_key}. Skipping.\")\n            continue\n\n        # Check for mate relations (mimic joints)\n        joint_mimic = None\n        # TODO: Implement mate relation support with PathKey system\n        # This will require updating the relation processing to use PathKeys\n\n        # Create/get joint(s)\n        # For spherical joints, dummy links and joints are created\n        joints_dict, links_dict = get_robot_joint(\n            parent_key=parent_key,\n            child_key=child_key,\n            mate=mate_data,\n            world_to_parent_tf=world_to_parent_tf,\n            used_joint_names=used_joint_names,\n            mimic=joint_mimic,\n        )\n\n        # Create child link\n        child_default_name = str(child_key)\n        child_name = resolve_part_name(child_default_name)\n\n        link, world_to_link_tf, asset = get_robot_link(\n            name=child_name,\n            part=child_part,\n            client=client,\n            mate=mate_data,\n        )\n\n        # Add child link if not already in graph\n        if child_key not in robot.nodes:\n            robot.add_node(child_key, data=link, asset=asset, world_to_link_tf=world_to_link_tf)\n        else:\n            # NOTE: possible cause for this: the kinematic graph has a loop\n            logger.warning(f\"Link {child_key} already exists in the robot graph. Skipping.\")\n\n        if links_dict is not None:\n            for _link_key, _link in links_dict.items():\n                if _link_key not in robot.nodes:\n                    robot.add_node(\n                        _link_key,\n                        data=_link,\n                        asset=None,\n                        world_to_link_tf=None,\n                    )\n                else:\n                    logger.warning(f\"Link {_link_key} already exists in the robot graph. Skipping.\")\n\n        # Add joints\n        for _joint_key, _joint_data in joints_dict.items():\n            robot.add_edge(_joint_key[0], _joint_key[1], data=_joint_data)\n\n    return robot\n</code></pre>"},{"location":"api/robot/#onshape_robotics_toolkit.robot.Robot.from_graph--save-using-format-serializers","title":"Save using format serializers","text":"<p>serializer = URDFSerializer() serializer.save(robot, \"robot.urdf\", download_assets=True)</p>"},{"location":"api/robot/#onshape_robotics_toolkit.robot.Robot.show_tree","title":"<code>show_tree()</code>","text":"<p>Display the robot's graph as a tree structure.</p> Source code in <code>onshape_robotics_toolkit/robot.py</code> <pre><code>def show_tree(self) -&gt; None:\n    \"\"\"Display the robot's graph as a tree structure.\"\"\"\n\n    def print_tree(node: str, depth: int = 0) -&gt; None:\n        prefix = \"    \" * depth\n        print(f\"{prefix}{node}\")\n        for child in self.kinematic_graph.successors(node):\n            print_tree(child, depth + 1)\n\n    root_nodes = [n for n in self.kinematic_graph.nodes if self.kinematic_graph.in_degree(n) == 0]\n    for root in root_nodes:\n        print_tree(root)\n</code></pre>"},{"location":"api/robot/#onshape_robotics_toolkit.robot.get_robot_joint","title":"<code>get_robot_joint(parent_key, child_key, mate, world_to_parent_tf, used_joint_names, mimic=None)</code>","text":"<p>Generate a URDF joint from an Onshape mate feature.</p> <p>Parameters:</p> Name Type Description Default <code>parent_key</code> <code>PathKey</code> <p>The PathKey of the parent link.</p> required <code>child_key</code> <code>PathKey</code> <p>The PathKey of the child link.</p> required <code>mate</code> <code>MateFeatureData</code> <p>The Onshape mate feature object.</p> required <code>world_to_parent_tf</code> <code>matrix</code> <p>The transformation matrix from world to parent link origin.</p> required <code>used_joint_names</code> <code>set</code> <p>Set of already used joint names for uniqueness checking.</p> required <code>mimic</code> <code>Optional[JointMimic]</code> <p>The mimic joint object.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[dict[tuple[PathKey, PathKey], BaseJoint], Optional[dict[PathKey, Link]]]</code> <p>tuple[dict[tuple[PathKey, PathKey], BaseJoint], Optional[dict[PathKey, Link]]]: The generated joints dict and optional dummy links dict.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; get_robot_joint(\"root\", \"link1\", mate, np.eye(4))\n(\n    [\n        RevoluteJoint(\n            name='base_link_to_link1',\n            parent='root',\n            child='link1',\n            origin=Origin(...),\n            limits=JointLimits(...),\n            axis=Axis(...),\n            dynamics=JointDynamics(...)\n        )\n    ],\n    None\n)\n</code></pre> Source code in <code>onshape_robotics_toolkit/robot.py</code> <pre><code>def get_robot_joint(\n    parent_key: PathKey,\n    child_key: PathKey,\n    mate: MateFeatureData,\n    world_to_parent_tf: np.matrix,\n    used_joint_names: set,\n    mimic: Optional[JointMimic] = None,\n) -&gt; tuple[dict[tuple[PathKey, PathKey], BaseJoint], Optional[dict[PathKey, Link]]]:\n    \"\"\"\n    Generate a URDF joint from an Onshape mate feature.\n\n    Args:\n        parent_key: The PathKey of the parent link.\n        child_key: The PathKey of the child link.\n        mate: The Onshape mate feature object.\n        world_to_parent_tf: The transformation matrix from world to parent link origin.\n        used_joint_names: Set of already used joint names for uniqueness checking.\n        mimic: The mimic joint object.\n\n    Returns:\n        tuple[dict[tuple[PathKey, PathKey], BaseJoint], Optional[dict[PathKey, Link]]]:\n            The generated joints dict and optional dummy links dict.\n\n    Examples:\n        &gt;&gt;&gt; get_robot_joint(\"root\", \"link1\", mate, np.eye(4))\n        (\n            [\n                RevoluteJoint(\n                    name='base_link_to_link1',\n                    parent='root',\n                    child='link1',\n                    origin=Origin(...),\n                    limits=JointLimits(...),\n                    axis=Axis(...),\n                    dynamics=JointDynamics(...)\n                )\n            ],\n            None\n        )\n\n    \"\"\"\n    links: dict[PathKey, Link] = {}\n    joints: dict[tuple[PathKey, PathKey], BaseJoint] = {}\n\n    world_to_joint_tf = np.eye(4)\n\n    # NOTE: we remapped the mates to always be parent-&gt;child, regardless of\n    # how Onshape considers (parent, child) of a mate\n    parent_part_to_mate = mate.matedEntities[0].matedCS\n    world_to_joint_tf = world_to_parent_tf @ parent_part_to_mate.to_tf\n\n    origin = Origin.from_matrix(world_to_joint_tf)\n    base_name = get_sanitized_name(mate.name)\n    resolved_name = resolve_mate_name(base_name)\n    joint_name = make_unique_name(resolved_name, used_joint_names)\n    used_joint_names.add(joint_name)\n\n    logger.info(f\"Creating robot joint from {parent_key} to {child_key}\")\n\n    parent_link_name = resolve_part_name(str(parent_key))\n    child_link_name = resolve_part_name(str(child_key))\n\n    if mate.mateType == MateType.REVOLUTE:\n        # Extract limits with priority order:\n        # 1. config limits (user overrides)\n        # 2. mate.limits (fetched from API)\n        # 3. None (omit limits for revolute joints)\n        revolute_limits = None\n        limit_source = None\n\n        config_limits = resolve_mate_limits(base_name)\n        if config_limits is not None and \"min\" in config_limits and \"max\" in config_limits:\n            revolute_limits = JointLimits(\n                effort=1.0,\n                velocity=1.0,\n                lower=config_limits[\"min\"],\n                upper=config_limits[\"max\"],\n            )\n            limit_source = \"config\"\n        elif mate.limits is not None and \"min\" in mate.limits and \"max\" in mate.limits:\n            # Fallback to API limits when no override is provided\n            revolute_limits = JointLimits(\n                effort=1.0,\n                velocity=1.0,\n                lower=mate.limits[\"min\"],\n                upper=mate.limits[\"max\"],\n            )\n            limit_source = \"API\"\n\n        if revolute_limits is None:\n            revolute_limits = JointLimits(\n                effort=1.0,\n                velocity=1.0,\n                lower=-2 * np.pi,\n                upper=2 * np.pi,\n            )\n            limit_source = \"default\"\n\n        logger.debug(\n            f\"Using {limit_source} limits for mate '{mate.name}': \"\n            f\"min={revolute_limits.lower:.4f}, max={revolute_limits.upper:.4f}\"\n        )\n\n        joints[(parent_key, child_key)] = RevoluteJoint(\n            name=joint_name,\n            parent=parent_link_name,\n            child=child_link_name,\n            origin=origin,\n            limits=revolute_limits,\n            axis=Axis((0.0, 0.0, -1.0)),\n            # dynamics=JointDynamics(damping=0.1, friction=0.1),\n            mimic=mimic,\n        )\n\n    elif mate.mateType == MateType.FASTENED:\n        joints[(parent_key, child_key)] = FixedJoint(\n            name=joint_name, parent=parent_link_name, child=child_link_name, origin=origin\n        )\n\n    elif mate.mateType == MateType.SLIDER or mate.mateType == MateType.CYLINDRICAL:\n        # For prismatic joints, use fetched limits or defaults (in meters)\n        # NOTE: Onshape limits are defined along +Z axis, but URDF uses -Z axis\n        # So we need to negate and swap min/max to account for the flipped direction\n        prismatic_lower: float | None = None\n        prismatic_upper: float | None = None\n        limit_source = None\n\n        config_limits = resolve_mate_limits(base_name)\n        if config_limits is not None and \"min\" in config_limits and \"max\" in config_limits:\n            prismatic_lower = -config_limits[\"max\"]\n            prismatic_upper = -config_limits[\"min\"]\n            limit_source = \"config\"\n        elif mate.limits is not None and \"min\" in mate.limits and \"max\" in mate.limits:\n            # Swap and negate: Onshape's min becomes URDF's upper (negated)\n            # and Onshape's max becomes URDF's lower (negated)\n            prismatic_lower = -mate.limits[\"max\"]\n            prismatic_upper = -mate.limits[\"min\"]\n            limit_source = \"API\"\n\n        if prismatic_lower is None or prismatic_upper is None:\n            prismatic_lower = -0.1\n            prismatic_upper = 0.1\n            limit_source = \"default\"\n\n        if limit_source == \"default\":\n            logger.debug(\n                f\"No limits available for mate '{mate.name}', using default prismatic range \"\n                f\"lower={prismatic_lower:.4f}, upper={prismatic_upper:.4f}\"\n            )\n        else:\n            logger.debug(\n                f\"Using {limit_source} limits for mate '{mate.name}': \"\n                f\"lower={prismatic_lower:.4f}, upper={prismatic_upper:.4f}\"\n            )\n\n        joints[(parent_key, child_key)] = PrismaticJoint(\n            name=joint_name,\n            parent=parent_link_name,\n            child=child_link_name,\n            origin=origin,\n            limits=JointLimits(\n                effort=1.0,\n                velocity=1.0,\n                lower=prismatic_lower,\n                upper=prismatic_upper,\n            ),\n            axis=Axis((0.0, 0.0, -1.0)),\n            # dynamics=JointDynamics(damping=0.1, friction=0.1),\n            mimic=mimic,\n        )\n\n    elif mate.mateType == MateType.BALL:\n        dummy_x_key = PathKey(\n            path=(*parent_key.path, joint_name, \"x\"),\n            name_path=(*parent_key.name_path, joint_name, \"x\"),\n        )\n        dummy_y_key = PathKey(\n            path=(*parent_key.path, joint_name, \"y\"),\n            name_path=(*parent_key.name_path, joint_name, \"y\"),\n        )\n\n        dummy_x_link = Link(\n            name=str(dummy_x_key),\n            inertial=InertialLink(\n                mass=0.0,\n                inertia=Inertia.zero_inertia(),\n                origin=Origin.zero_origin(),\n            ),\n        )\n        dummy_y_link = Link(\n            name=str(dummy_y_key),\n            inertial=InertialLink(\n                mass=0.0,\n                inertia=Inertia.zero_inertia(),\n                origin=Origin.zero_origin(),\n            ),\n        )\n\n        links[dummy_x_key] = dummy_x_link\n        links[dummy_y_key] = dummy_y_link\n\n        joints[(parent_key, dummy_x_key)] = RevoluteJoint(\n            name=joint_name + \"_x\",\n            parent=parent_link_name,\n            child=str(dummy_x_key),\n            origin=origin,\n            limits=JointLimits(\n                effort=1.0,\n                velocity=1.0,\n                lower=-2 * np.pi,\n                upper=2 * np.pi,\n            ),\n            axis=Axis((1.0, 0.0, 0.0)),\n            # dynamics=JointDynamics(damping=0.1, friction=0.1),\n            mimic=mimic,\n        )\n        joints[(dummy_x_key, dummy_y_key)] = RevoluteJoint(\n            name=joint_name + \"_y\",\n            parent=str(dummy_x_key),\n            child=str(dummy_y_key),\n            origin=Origin.zero_origin(),\n            limits=JointLimits(\n                effort=1.0,\n                velocity=1.0,\n                lower=-2 * np.pi,\n                upper=2 * np.pi,\n            ),\n            axis=Axis((0.0, 1.0, 0.0)),\n            # dynamics=JointDynamics(damping=0.1, friction=0.1),\n            mimic=mimic,\n        )\n        joints[(dummy_y_key, child_key)] = RevoluteJoint(\n            name=joint_name + \"_z\",\n            parent=str(dummy_y_key),\n            child=child_link_name,\n            origin=Origin.zero_origin(),\n            limits=JointLimits(\n                effort=1.0,\n                velocity=1.0,\n                lower=-2 * np.pi,\n                upper=2 * np.pi,\n            ),\n            axis=Axis((0.0, 0.0, -1.0)),\n            # dynamics=JointDynamics(damping=0.1, friction=0.1),\n            mimic=mimic,\n        )\n\n    else:\n        logger.warning(f\"Unsupported joint type: {mate.mateType}\")\n        joints[(parent_key, child_key)] = DummyJoint(\n            name=joint_name, parent=parent_link_name, child=child_link_name, origin=origin\n        )\n\n    return joints, links\n</code></pre>"},{"location":"api/robot/#onshape_robotics_toolkit.robot.get_robot_link","title":"<code>get_robot_link(name, part, client, mate=None, mesh_dir=None)</code>","text":"<p>Generate a URDF link from an Onshape part.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the link.</p> required <code>part</code> <code>Part</code> <p>The Onshape part object.</p> required <code>client</code> <code>Client</code> <p>The Onshape client object to use for sending API requests.</p> required <code>mate</code> <code>Optional[Union[MateFeatureData, None]]</code> <p>MateFeatureData object to use for generating the transformation matrix.</p> <code>None</code> <code>mesh_dir</code> <code>Optional[str]</code> <p>Optional custom directory for mesh files.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[Link, matrix, Asset]</code> <p>tuple[Link, np.matrix]: The generated link object and the transformation matrix from the STL origin to the link origin.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; get_robot_link(\"root\", part, wid, client)\n(\n    Link(name='root', visual=VisualLink(...), collision=CollisionLink(...), inertial=InertialLink(...)),\n    np.matrix([[1., 0., 0., 0.],\n        [0., 1., 0., 0.],\n        [0., 0., 1., 0.],\n        [0., 0., 0., 1.]])\n)\n</code></pre> Source code in <code>onshape_robotics_toolkit/robot.py</code> <pre><code>def get_robot_link(\n    name: str,\n    part: Part,\n    client: Client,\n    mate: Optional[Union[MateFeatureData, None]] = None,\n    mesh_dir: Optional[str] = None,\n) -&gt; tuple[Link, np.matrix, Asset]:\n    \"\"\"\n    Generate a URDF link from an Onshape part.\n\n    Args:\n        name: The name of the link.\n        part: The Onshape part object.\n        client: The Onshape client object to use for sending API requests.\n        mate: MateFeatureData object to use for generating the transformation matrix.\n        mesh_dir: Optional custom directory for mesh files.\n\n    Returns:\n        tuple[Link, np.matrix]: The generated link object\n            and the transformation matrix from the STL origin to the link origin.\n\n    Examples:\n        &gt;&gt;&gt; get_robot_link(\"root\", part, wid, client)\n        (\n            Link(name='root', visual=VisualLink(...), collision=CollisionLink(...), inertial=InertialLink(...)),\n            np.matrix([[1., 0., 0., 0.],\n                [0., 1., 0., 0.],\n                [0., 0., 1., 0.],\n                [0., 0., 0., 1.]])\n        )\n\n    \"\"\"\n    # place link at world origin by default\n    _link_pose_wrt_world = np.eye(4)\n\n    if mate is not None:\n        # NOTE: we remapped the mates to always be parent-&gt;child, regardless of\n        # how Onshape considers (parent, child) of a mate\n        child_part_to_mate: MatedCS = mate.matedEntities[-1].matedCS\n        # NOTE: child link's origin is always at the mate location, and since\n        # the joint origin is already transformed to world coordinates,\n        # we only use the child part's mate location to determine\n        # the child link's origin\n        _link_pose_wrt_world = child_part_to_mate.to_tf\n    else:\n        if part.worldToPartTF is not None:\n            _link_pose_wrt_world = part.worldToPartTF.to_tf\n        else:\n            logger.warning(f\"Part {name} has no worldToPartTF, using identity matrix\")\n\n    world_to_link_tf = np.linalg.inv(_link_pose_wrt_world)\n    _origin = Origin.zero_origin()\n    _principal_axes_rotation = (0.0, 0.0, 0.0)\n\n    # Check if part has mass properties\n    if part.MassProperty is None:\n        # TODO: use downloaded assets + material library to find these values\n        # using numpy-stl library\n        logger.warning(f\"Part {name} has no mass properties, using default values\")\n        _mass = 1.0  # Default mass\n        _com = (0.0, 0.0, 0.0)  # Default center of mass at origin\n        _inertia = np.eye(3)  # Default identity inertia matrix\n    else:\n        _mass = part.MassProperty.mass[0]\n        # Convert ndarray to matrix for compatibility with MassProperty methods\n        world_to_link_matrix = np.matrix(world_to_link_tf)\n        _com = tuple(part.MassProperty.center_of_mass_wrt(world_to_link_matrix))\n        _inertia = part.MassProperty.inertia_wrt(world_to_link_matrix[:3, :3])\n\n    logger.info(f\"Creating robot link for {name}\")\n\n    # Determine workspace type and ID for fetching the mesh\n    mvwid: str\n    if part.documentVersion:\n        # Part from a specific version\n        wtype = WorkspaceType.V.value\n        mvwid = part.documentVersion\n    elif part.isRigidAssembly:\n        # Rigid assembly - use workspace type with its workspace ID\n        # The assembly STL API requires workspace type and workspace ID\n        wtype = WorkspaceType.W.value\n        if part.rigidAssemblyWorkspaceId is not None:\n            mvwid = part.rigidAssemblyWorkspaceId\n        else:\n            logger.error(\"Rigid part is missing workspace ID\")\n    else:\n        # Regular part - use its documentMicroversion with microversion type\n        wtype = WorkspaceType.M.value\n        mvwid = part.documentMicroversion\n\n    asset = Asset(\n        did=part.documentId,\n        wtype=wtype,\n        wid=mvwid,\n        eid=part.elementId,\n        partID=part.partId,\n        client=client,\n        transform=world_to_link_tf,\n        is_rigid_assembly=part.isRigidAssembly,\n        file_name=f\"{name}.stl\",\n        mesh_dir=mesh_dir,\n    )\n    _mesh_path = asset.relative_path\n\n    link = Link(\n        name=name,\n        visual=VisualLink(\n            name=f\"{name}_visual\",\n            origin=_origin,\n            geometry=MeshGeometry(_mesh_path),\n            material=Material.from_color(name=f\"{name}-material\", color=random.SystemRandom().choice(list(Colors))),\n        ),\n        inertial=InertialLink(\n            origin=Origin(\n                xyz=_com,\n                rpy=_principal_axes_rotation,\n            ),\n            mass=_mass,\n            inertia=Inertia(\n                ixx=_inertia[0, 0],\n                ixy=_inertia[0, 1],\n                ixz=_inertia[0, 2],\n                iyy=_inertia[1, 1],\n                iyz=_inertia[1, 2],\n                izz=_inertia[2, 2],\n            ),\n        ),\n        collision=CollisionLink(\n            name=f\"{name}_collision\",\n            origin=_origin,\n            geometry=MeshGeometry(_mesh_path),\n        ),\n    )\n\n    # Convert to matrix for compatibility with downstream code\n    world_to_link_matrix = np.matrix(world_to_link_tf)\n    return link, world_to_link_matrix, asset\n</code></pre>"},{"location":"api/robot/#onshape_robotics_toolkit.robot.set_joint_from_xml","title":"<code>set_joint_from_xml(element)</code>","text":"<p>Set the joint type from an XML element.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element</code> <p>The XML element.</p> required <p>Returns:</p> Name Type Description <code>BaseJoint</code> <code>BaseJoint | None</code> <p>The joint type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; element = ET.Element(\"joint\", type=\"fixed\")\n&gt;&gt;&gt; set_joint_from_xml(element)\n&lt;FixedJoint&gt;\n</code></pre> Source code in <code>onshape_robotics_toolkit/robot.py</code> <pre><code>def set_joint_from_xml(element: ET._Element) -&gt; BaseJoint | None:\n    \"\"\"\n    Set the joint type from an XML element.\n\n    Args:\n        element (ET.Element): The XML element.\n\n    Returns:\n        BaseJoint: The joint type.\n\n    Examples:\n        &gt;&gt;&gt; element = ET.Element(\"joint\", type=\"fixed\")\n        &gt;&gt;&gt; set_joint_from_xml(element)\n        &lt;FixedJoint&gt;\n    \"\"\"\n    joint_type = element.get(\"type\")\n    if joint_type is None:\n        return None\n    if joint_type == JointType.FIXED:\n        return FixedJoint.from_xml(element)\n    elif joint_type == JointType.REVOLUTE:\n        return RevoluteJoint.from_xml(element)\n    elif joint_type == JointType.CONTINUOUS:\n        return ContinuousJoint.from_xml(element)\n    elif joint_type == JointType.PRISMATIC:\n        return PrismaticJoint.from_xml(element)\n    elif joint_type == JointType.FLOATING:\n        return FloatingJoint.from_xml(element)\n    return None\n</code></pre>"},{"location":"api/utilities/","title":"Utilities","text":""},{"location":"api/utilities/#onshape_robotics_toolkit.utilities.CustomJSONEncoder","title":"<code>CustomJSONEncoder</code>","text":"<p>               Bases: <code>JSONEncoder</code></p> <p>Custom JSON encoder that: 1. Converts numpy arrays/matrices to lists 2. Cleans numerical values (removes near-zero noise, rounds to precision) 3. Converts sets to lists</p> Source code in <code>onshape_robotics_toolkit/utilities/helpers.py</code> <pre><code>class CustomJSONEncoder(json.JSONEncoder):\n    \"\"\"\n    Custom JSON encoder that:\n    1. Converts numpy arrays/matrices to lists\n    2. Cleans numerical values (removes near-zero noise, rounds to precision)\n    3. Converts sets to lists\n    \"\"\"\n\n    def __init__(\n        self, *args: Any, clean_numerics: bool = True, threshold: float = 1e-10, decimals: int = 8, **kwargs: Any\n    ):\n        \"\"\"\n        Args:\n            clean_numerics: If True, clean numeric values (default True)\n            threshold: Values below this are set to 0 (default 1e-10)\n            decimals: Number of decimal places to round to (default 8)\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self.clean_numerics = clean_numerics\n        self.threshold = threshold\n        self.decimals = decimals\n\n    def encode(self, obj: Any) -&gt; str:\n        \"\"\"Override encode to clean numerics in the entire structure.\"\"\"\n        if self.clean_numerics:\n            obj = self._clean_object(obj)\n        return super().encode(obj)\n\n    def _clean_object(self, obj: Any) -&gt; Any:\n        \"\"\"Recursively clean numeric values in any object.\"\"\"\n        if isinstance(obj, dict):\n            return {k: self._clean_object(v) for k, v in obj.items()}\n        elif isinstance(obj, (list, tuple)):\n            return [self._clean_object(item) for item in obj]\n        elif isinstance(obj, (float, np.floating)):\n            return clean_numeric_value(float(obj), self.threshold, self.decimals)\n        elif isinstance(obj, (int, np.integer)):\n            return int(obj)\n        elif isinstance(obj, (np.ndarray, np.matrix)):\n            # Convert to list and clean\n            return clean_numeric_list(obj.tolist(), self.threshold, self.decimals)\n        elif isinstance(obj, set):\n            return [self._clean_object(item) for item in obj]\n        else:\n            return obj\n\n    def default(self, obj: Any) -&gt; Any:\n        \"\"\"Handle non-serializable objects.\"\"\"\n        if isinstance(obj, (np.ndarray, np.matrix)):\n            cleaned = clean_numeric_list(obj.tolist(), self.threshold, self.decimals)\n            return cleaned\n        if isinstance(obj, set):\n            return list(obj)\n        return super().default(obj)\n</code></pre>"},{"location":"api/utilities/#onshape_robotics_toolkit.utilities.CustomJSONEncoder.__init__","title":"<code>__init__(*args, clean_numerics=True, threshold=1e-10, decimals=8, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>clean_numerics</code> <code>bool</code> <p>If True, clean numeric values (default True)</p> <code>True</code> <code>threshold</code> <code>float</code> <p>Values below this are set to 0 (default 1e-10)</p> <code>1e-10</code> <code>decimals</code> <code>int</code> <p>Number of decimal places to round to (default 8)</p> <code>8</code> Source code in <code>onshape_robotics_toolkit/utilities/helpers.py</code> <pre><code>def __init__(\n    self, *args: Any, clean_numerics: bool = True, threshold: float = 1e-10, decimals: int = 8, **kwargs: Any\n):\n    \"\"\"\n    Args:\n        clean_numerics: If True, clean numeric values (default True)\n        threshold: Values below this are set to 0 (default 1e-10)\n        decimals: Number of decimal places to round to (default 8)\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.clean_numerics = clean_numerics\n    self.threshold = threshold\n    self.decimals = decimals\n</code></pre>"},{"location":"api/utilities/#onshape_robotics_toolkit.utilities.CustomJSONEncoder.default","title":"<code>default(obj)</code>","text":"<p>Handle non-serializable objects.</p> Source code in <code>onshape_robotics_toolkit/utilities/helpers.py</code> <pre><code>def default(self, obj: Any) -&gt; Any:\n    \"\"\"Handle non-serializable objects.\"\"\"\n    if isinstance(obj, (np.ndarray, np.matrix)):\n        cleaned = clean_numeric_list(obj.tolist(), self.threshold, self.decimals)\n        return cleaned\n    if isinstance(obj, set):\n        return list(obj)\n    return super().default(obj)\n</code></pre>"},{"location":"api/utilities/#onshape_robotics_toolkit.utilities.CustomJSONEncoder.encode","title":"<code>encode(obj)</code>","text":"<p>Override encode to clean numerics in the entire structure.</p> Source code in <code>onshape_robotics_toolkit/utilities/helpers.py</code> <pre><code>def encode(self, obj: Any) -&gt; str:\n    \"\"\"Override encode to clean numerics in the entire structure.\"\"\"\n    if self.clean_numerics:\n        obj = self._clean_object(obj)\n    return super().encode(obj)\n</code></pre>"},{"location":"api/utilities/#onshape_robotics_toolkit.utilities.clean_json_numerics","title":"<code>clean_json_numerics(data, threshold=1e-10, decimals=8)</code>","text":"<p>Recursively clean numeric values in a JSON-like data structure.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>JSON data (dict, list, or scalar)</p> required <code>threshold</code> <code>float</code> <p>Values below this are set to 0</p> <code>1e-10</code> <code>decimals</code> <code>int</code> <p>Number of decimal places to round to</p> <code>8</code> <p>Returns:</p> Type Description <code>Any</code> <p>Cleaned data structure</p> Source code in <code>onshape_robotics_toolkit/utilities/helpers.py</code> <pre><code>def clean_json_numerics(data: Any, threshold: float = 1e-10, decimals: int = 8) -&gt; Any:\n    \"\"\"\n    Recursively clean numeric values in a JSON-like data structure.\n\n    Args:\n        data: JSON data (dict, list, or scalar)\n        threshold: Values below this are set to 0\n        decimals: Number of decimal places to round to\n\n    Returns:\n        Cleaned data structure\n    \"\"\"\n    if isinstance(data, dict):\n        return {k: clean_json_numerics(v, threshold, decimals) for k, v in data.items()}\n    elif isinstance(data, list):\n        return [clean_json_numerics(item, threshold, decimals) for item in data]\n    elif isinstance(data, float):\n        return clean_numeric_value(data, threshold, decimals)\n    else:\n        return data\n</code></pre>"},{"location":"api/utilities/#onshape_robotics_toolkit.utilities.clean_name_for_urdf","title":"<code>clean_name_for_urdf(name)</code>","text":"<p>Clean a name to be URDF-safe by replacing problematic characters.</p> <p>This is similar to get_sanitized_name but specifically for URDF compatibility, following the reference implementation's approach.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name to clean for URDF compatibility.</p> required <p>Returns:</p> Type Description <code>str</code> <p>URDF-safe name.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; clean_name_for_urdf(\"wheel &lt;1&gt;\")\n\"wheel_(1)\"\n&gt;&gt;&gt; clean_name_for_urdf(\"joint/arm\\link\")\n\"joint_arm_link\"\n</code></pre> Source code in <code>onshape_robotics_toolkit/utilities/helpers.py</code> <pre><code>def clean_name_for_urdf(name: str) -&gt; str:\n    \"\"\"\n    Clean a name to be URDF-safe by replacing problematic characters.\n\n    This is similar to get_sanitized_name but specifically for URDF compatibility,\n    following the reference implementation's approach.\n\n    Args:\n        name: Name to clean for URDF compatibility.\n\n    Returns:\n        URDF-safe name.\n\n    Examples:\n        &gt;&gt;&gt; clean_name_for_urdf(\"wheel &lt;1&gt;\")\n        \"wheel_(1)\"\n        &gt;&gt;&gt; clean_name_for_urdf(\"joint/arm\\\\link\")\n        \"joint_arm_link\"\n    \"\"\"\n    name = name.replace(\"&lt;\", \"(\").replace(\"&gt;\", \")\")\n    name = re.sub(r\"\\s+\", \"_\", name)\n    name = re.sub(r\"[/\\\\]+\", \"_\", name)\n    return name\n</code></pre>"},{"location":"api/utilities/#onshape_robotics_toolkit.utilities.clean_numeric_list","title":"<code>clean_numeric_list(data, threshold=1e-10, decimals=8)</code>","text":"<p>Recursively clean numeric values in nested lists/arrays.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Data structure (can be list, nested list, or scalar)</p> required <code>threshold</code> <code>float</code> <p>Values with absolute value below this are set to 0</p> <code>1e-10</code> <code>decimals</code> <code>int</code> <p>Number of decimal places to round to</p> <code>8</code> <p>Returns:</p> Type Description <code>Any</code> <p>Cleaned data structure</p> Source code in <code>onshape_robotics_toolkit/utilities/helpers.py</code> <pre><code>def clean_numeric_list(data: Any, threshold: float = 1e-10, decimals: int = 8) -&gt; Any:\n    \"\"\"\n    Recursively clean numeric values in nested lists/arrays.\n\n    Args:\n        data: Data structure (can be list, nested list, or scalar)\n        threshold: Values with absolute value below this are set to 0\n        decimals: Number of decimal places to round to\n\n    Returns:\n        Cleaned data structure\n    \"\"\"\n    if isinstance(data, (list, tuple)):\n        return [clean_numeric_list(item, threshold, decimals) for item in data]\n    elif isinstance(data, (float, np.floating)):\n        return clean_numeric_value(float(data), threshold, decimals)\n    elif isinstance(data, (int, np.integer)):\n        return int(data)\n    else:\n        return data\n</code></pre>"},{"location":"api/utilities/#onshape_robotics_toolkit.utilities.clean_numeric_value","title":"<code>clean_numeric_value(value, threshold=1e-10, decimals=8)</code>","text":"<p>Clean a numeric value by: 1. Setting values below threshold to exactly 0 2. Rounding to specified decimal places</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The numeric value to clean</p> required <code>threshold</code> <code>float</code> <p>Values with absolute value below this are set to 0 (default 1e-10)</p> <code>1e-10</code> <code>decimals</code> <code>int</code> <p>Number of decimal places to round to (default 8)</p> <code>8</code> <p>Returns:</p> Type Description <code>float</code> <p>Cleaned numeric value</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; clean_numeric_value(5.62050406e-16)\n0.0\n&gt;&gt;&gt; clean_numeric_value(0.123456789012345, decimals=5)\n0.12346\n&gt;&gt;&gt; clean_numeric_value(-1e-11)\n0.0\n</code></pre> Source code in <code>onshape_robotics_toolkit/utilities/helpers.py</code> <pre><code>def clean_numeric_value(value: float, threshold: float = 1e-10, decimals: int = 8) -&gt; float:\n    \"\"\"\n    Clean a numeric value by:\n    1. Setting values below threshold to exactly 0\n    2. Rounding to specified decimal places\n\n    Args:\n        value: The numeric value to clean\n        threshold: Values with absolute value below this are set to 0 (default 1e-10)\n        decimals: Number of decimal places to round to (default 8)\n\n    Returns:\n        Cleaned numeric value\n\n    Examples:\n        &gt;&gt;&gt; clean_numeric_value(5.62050406e-16)\n        0.0\n        &gt;&gt;&gt; clean_numeric_value(0.123456789012345, decimals=5)\n        0.12346\n        &gt;&gt;&gt; clean_numeric_value(-1e-11)\n        0.0\n    \"\"\"\n    # First check if value is below threshold\n    if abs(value) &lt; threshold:\n        return 0.0\n    # Round to specified decimal places\n    return round(value, decimals)\n</code></pre>"},{"location":"api/utilities/#onshape_robotics_toolkit.utilities.format_number","title":"<code>format_number(value)</code>","text":"<p>Format a number to 8 significant figures</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>Number to format</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Formatted number</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; format_number(0.123456789)\n\"0.12345679\"\n</code></pre> <pre><code>&gt;&gt;&gt; format_number(123456789)\n\"123456789\"\n</code></pre> Source code in <code>onshape_robotics_toolkit/utilities/helpers.py</code> <pre><code>def format_number(value: float) -&gt; str:\n    \"\"\"\n    Format a number to 8 significant figures\n\n    Args:\n        value (float): Number to format\n\n    Returns:\n        str: Formatted number\n\n    Examples:\n        &gt;&gt;&gt; format_number(0.123456789)\n        \"0.12345679\"\n\n        &gt;&gt;&gt; format_number(123456789)\n        \"123456789\"\n    \"\"\"\n\n    return f\"{value:.8g}\"\n</code></pre>"},{"location":"api/utilities/#onshape_robotics_toolkit.utilities.generate_uid","title":"<code>generate_uid(values)</code>","text":"<p>Generate a 16-character unique identifier from a list of strings</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>list[str]</code> <p>List of strings to concatenate</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Unique identifier</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; generate_uid([\"hello\", \"world\"])\n\"c4ca4238a0b92382\"\n</code></pre> Source code in <code>onshape_robotics_toolkit/utilities/helpers.py</code> <pre><code>def generate_uid(values: list[str]) -&gt; str:\n    \"\"\"\n    Generate a 16-character unique identifier from a list of strings\n\n    Args:\n        values (list[str]): List of strings to concatenate\n\n    Returns:\n        str: Unique identifier\n\n    Examples:\n        &gt;&gt;&gt; generate_uid([\"hello\", \"world\"])\n        \"c4ca4238a0b92382\"\n    \"\"\"\n\n    _value = \"\".join(values)\n    return hashlib.sha256(_value.encode()).hexdigest()[:16]\n</code></pre>"},{"location":"api/utilities/#onshape_robotics_toolkit.utilities.get_random_files","title":"<code>get_random_files(directory, file_extension, count)</code>","text":"<p>Get random files from a directory with a specific file extension and count</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str</code> <p>Directory path</p> required <code>file_extension</code> <code>str</code> <p>File extension</p> required <code>count</code> <code>int</code> <p>Number of files to select</p> required <p>Returns:</p> Type Description <code>tuple[list[str], list[str]]</code> <p>list[str]: List of file paths</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Not enough files in directory if count exceeds number of files</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; get_random_files(\"json\", \".json\", 1)\n[\"json/file.json\"]\n</code></pre> <pre><code>&gt;&gt;&gt; get_random_files(\"json\", \".json\", 2)\n[\"json/file1.json\", \"json/file2.json\"]\n</code></pre> Source code in <code>onshape_robotics_toolkit/utilities/helpers.py</code> <pre><code>def get_random_files(directory: str, file_extension: str, count: int) -&gt; tuple[list[str], list[str]]:\n    \"\"\"\n    Get random files from a directory with a specific file extension and count\n\n    Args:\n        directory (str): Directory path\n        file_extension (str): File extension\n        count (int): Number of files to select\n\n    Returns:\n        list[str]: List of file paths\n\n    Raises:\n        ValueError: Not enough files in directory if count exceeds number of files\n\n    Examples:\n        &gt;&gt;&gt; get_random_files(\"json\", \".json\", 1)\n        [\"json/file.json\"]\n\n        &gt;&gt;&gt; get_random_files(\"json\", \".json\", 2)\n        [\"json/file1.json\", \"json/file2.json\"]\n    \"\"\"\n\n    _files = [file for file in os.listdir(directory) if file.endswith(file_extension)]\n\n    if len(_files) &lt; count:\n        raise ValueError(\"Not enough files in directory\")\n\n    selected_files = random.sample(_files, count)\n    file_paths = [os.path.join(directory, file) for file in selected_files]\n\n    logger.info(f\"Selected files: {file_paths}\")\n\n    return file_paths, [x.split(\".\")[0] for x in selected_files]\n</code></pre>"},{"location":"api/utilities/#onshape_robotics_toolkit.utilities.get_random_names","title":"<code>get_random_names(directory, count, filename='words.txt')</code>","text":"<p>Generate random names from a list of words in a file</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str</code> <p>Path to directory containing words file</p> required <code>count</code> <code>int</code> <p>Number of random names to generate</p> required <code>filename</code> <code>str</code> <p>File containing list of words. Default is \"words.txt\"</p> <code>'words.txt'</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of random names</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If count exceeds the number of available words</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; get_random_names(directory=\"../\", count=1)\n[\"charizard\"]\n</code></pre> <pre><code>&gt;&gt;&gt; get_random_names(directory=\"../\", count=2)\n[\"charizard\", \"pikachu\"]\n</code></pre> Source code in <code>onshape_robotics_toolkit/utilities/helpers.py</code> <pre><code>def get_random_names(directory: str, count: int, filename: str = \"words.txt\") -&gt; list[str]:\n    \"\"\"\n    Generate random names from a list of words in a file\n\n    Args:\n        directory: Path to directory containing words file\n        count: Number of random names to generate\n        filename: File containing list of words. Default is \"words.txt\"\n\n    Returns:\n        List of random names\n\n    Raises:\n        ValueError: If count exceeds the number of available words\n\n    Examples:\n        &gt;&gt;&gt; get_random_names(directory=\"../\", count=1)\n        [\"charizard\"]\n\n        &gt;&gt;&gt; get_random_names(directory=\"../\", count=2)\n        [\"charizard\", \"pikachu\"]\n    \"\"\"\n\n    words_file_path = os.path.join(directory, filename)\n\n    with open(words_file_path) as file:\n        words = file.read().splitlines()\n\n    if count &gt; len(words):\n        raise ValueError(\"count exceeds the number of available words\")\n\n    return random.sample(words, count)\n</code></pre>"},{"location":"api/utilities/#onshape_robotics_toolkit.utilities.get_sanitized_name","title":"<code>get_sanitized_name(name, replace_with='_', remove_onshape_tags=False)</code>","text":"<p>Sanitize a name by removing special characters, preserving only the specified replacement character, and replacing spaces with it. Ensures no consecutive replacement characters in the result. Optionally preserves a trailing \" \" tag where n is a number. <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name to sanitize.</p> required <code>replace_with</code> <code>str</code> <p>Character to replace spaces and other special characters with (default is '_').</p> <code>'_'</code> <code>remove_onshape_tags</code> <code>bool</code> <p>If True, removes a trailing \" \" tag where n is a number. Default is False. <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Sanitized name.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; get_sanitized_name(\"wheel1 &lt;3&gt;\")\n\"wheel1_3\"\n</code></pre> <pre><code>&gt;&gt;&gt; get_sanitized_name(\"wheel1 &lt;3&gt;\", remove_onshape_tags=True)\n\"wheel1\"\n</code></pre> <pre><code>&gt;&gt;&gt; get_sanitized_name(\"wheel1 &lt;3&gt;\", replace_with='-', remove_onshape_tags=False)\n\"wheel1-3\"\n</code></pre> Source code in <code>onshape_robotics_toolkit/utilities/helpers.py</code> <pre><code>def get_sanitized_name(name: str, replace_with: str = \"_\", remove_onshape_tags: bool = False) -&gt; str:\n    \"\"\"\n    Sanitize a name by removing special characters, preserving only the specified\n    replacement character, and replacing spaces with it. Ensures no consecutive\n    replacement characters in the result.\n    Optionally preserves a trailing \" &lt;n&gt;\" tag where n is a number.\n\n    Args:\n        name (str): Name to sanitize.\n        replace_with (str): Character to replace spaces and other special characters with (default is '_').\n        remove_onshape_tags (bool): If True, removes a trailing \" &lt;n&gt;\" tag where n is a number. Default is False.\n\n    Returns:\n        str: Sanitized name.\n\n    Examples:\n        &gt;&gt;&gt; get_sanitized_name(\"wheel1 &lt;3&gt;\")\n        \"wheel1_3\"\n\n        &gt;&gt;&gt; get_sanitized_name(\"wheel1 &lt;3&gt;\", remove_onshape_tags=True)\n        \"wheel1\"\n\n        &gt;&gt;&gt; get_sanitized_name(\"wheel1 &lt;3&gt;\", replace_with='-', remove_onshape_tags=False)\n        \"wheel1-3\"\n    \"\"\"\n\n    if replace_with not in \"-_\":\n        raise ValueError(\"replace_with must be either '-' or '_'\")\n\n    tag = \"\"\n    if remove_onshape_tags:\n        # Regular expression to detect a trailing \" &lt;n&gt;\" where n is one or more digits\n        tag_pattern = re.compile(r\"\\s&lt;\\d+&gt;$\")\n        match = tag_pattern.search(name)\n        if match:\n            tag = match.group()  # e.g., \" &lt;3&gt;\"\n            if tag:\n                name = name[: match.start()]\n\n    sanitized_name = \"\".join(char if char.isalnum() or char in \"-_ \" else \"\" for char in name)\n    sanitized_name = sanitized_name.replace(\" \", replace_with)\n    sanitized_name = re.sub(f\"{re.escape(replace_with)}{{2,}}\", replace_with, sanitized_name)\n\n    return sanitized_name\n</code></pre>"},{"location":"api/utilities/#onshape_robotics_toolkit.utilities.load_model_from_json","title":"<code>load_model_from_json(model_class, file_path, clean_numerics=True, threshold=1e-10, decimals=8)</code>","text":"<p>Load a Pydantic model from a JSON file with optional numeric cleaning.</p> <p>Parameters:</p> Name Type Description Default <code>model_class</code> <code>type[BaseModel]</code> <p>The Pydantic model class to instantiate</p> required <code>file_path</code> <code>str</code> <p>Path to JSON file</p> required <code>clean_numerics</code> <code>bool</code> <p>If True, clean numeric values before validation (default True)</p> <code>True</code> <code>threshold</code> <code>float</code> <p>Values below this are set to 0 (default 1e-10)</p> <code>1e-10</code> <code>decimals</code> <code>int</code> <p>Number of decimal places to round to (default 8)</p> <code>8</code> <p>Returns:</p> Name Type Description <code>BaseModel</code> <code>BaseModel</code> <p>Instance of the model class populated from JSON</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class TestModel(BaseModel):\n...     a: int\n...     b: str\n...\n&gt;&gt;&gt; model = load_model_from_json(TestModel, \"test.json\")\n&gt;&gt;&gt; print(model.a, model.b)\n1 hello\n</code></pre> <pre><code>&gt;&gt;&gt; from onshape_robotics_toolkit.models import Assembly\n&gt;&gt;&gt; assembly = load_model_from_json(Assembly, \"assembly.json\")\n&gt;&gt;&gt; assembly = load_model_from_json(Assembly, \"assembly.json\", decimals=5)\n</code></pre> Source code in <code>onshape_robotics_toolkit/utilities/helpers.py</code> <pre><code>def load_model_from_json(\n    model_class: type[BaseModel],\n    file_path: str,\n    clean_numerics: bool = True,\n    threshold: float = 1e-10,\n    decimals: int = 8,\n) -&gt; BaseModel:\n    \"\"\"\n    Load a Pydantic model from a JSON file with optional numeric cleaning.\n\n    Args:\n        model_class (type[BaseModel]): The Pydantic model class to instantiate\n        file_path (str): Path to JSON file\n        clean_numerics (bool): If True, clean numeric values before validation (default True)\n        threshold (float): Values below this are set to 0 (default 1e-10)\n        decimals (int): Number of decimal places to round to (default 8)\n\n    Returns:\n        BaseModel: Instance of the model class populated from JSON\n\n    Examples:\n        &gt;&gt;&gt; class TestModel(BaseModel):\n        ...     a: int\n        ...     b: str\n        ...\n        &gt;&gt;&gt; model = load_model_from_json(TestModel, \"test.json\")\n        &gt;&gt;&gt; print(model.a, model.b)\n        1 hello\n\n        &gt;&gt;&gt; from onshape_robotics_toolkit.models import Assembly\n        &gt;&gt;&gt; assembly = load_model_from_json(Assembly, \"assembly.json\")\n        &gt;&gt;&gt; assembly = load_model_from_json(Assembly, \"assembly.json\", decimals=5)\n    \"\"\"\n    with open(file_path) as file:\n        data = json.load(file)\n        if clean_numerics:\n            data = clean_json_numerics(data, threshold, decimals)\n        return model_class.model_validate(data)\n</code></pre>"},{"location":"api/utilities/#onshape_robotics_toolkit.utilities.make_unique_keys","title":"<code>make_unique_keys(keys)</code>","text":"<p>Make a list of keys unique by appending a number to duplicate keys and return a mapping of unique keys to their original indices.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>list[str]</code> <p>List of keys.</p> required <p>Returns:</p> Type Description <code>dict[str, int]</code> <p>A dictionary mapping unique keys to their original indices.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; make_unique_keys([\"a\", \"b\", \"a\", \"a\"])\n{\"a\": 0, \"b\": 1, \"a-1\": 2, \"a-2\": 3}\n</code></pre> Source code in <code>onshape_robotics_toolkit/utilities/helpers.py</code> <pre><code>def make_unique_keys(keys: list[str]) -&gt; dict[str, int]:\n    \"\"\"\n    Make a list of keys unique by appending a number to duplicate keys and\n    return a mapping of unique keys to their original indices.\n\n    Args:\n        keys: List of keys.\n\n    Returns:\n        A dictionary mapping unique keys to their original indices.\n\n    Examples:\n        &gt;&gt;&gt; make_unique_keys([\"a\", \"b\", \"a\", \"a\"])\n        {\"a\": 0, \"b\": 1, \"a-1\": 2, \"a-2\": 3}\n    \"\"\"\n    unique_key_map = {}\n    key_count: dict[str, int] = {}\n\n    for index, key in enumerate(keys):\n        if key in key_count:\n            key_count[key] += 1\n            unique_key = f\"{key}-{key_count[key]}\"\n        else:\n            key_count[key] = 0\n            unique_key = key\n\n        unique_key_map[unique_key] = index\n\n    return unique_key_map\n</code></pre>"},{"location":"api/utilities/#onshape_robotics_toolkit.utilities.make_unique_name","title":"<code>make_unique_name(name, existing_names)</code>","text":"<p>Make a name unique by appending a number to the name if it already exists in a set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name to make unique.</p> required <code>existing_names</code> <code>set[str]</code> <p>Set of existing names.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A unique name.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; make_unique_name(\"name\", {\"name\"})\n\"name-1\"\n&gt;&gt;&gt; make_unique_name(\"name\", {\"name\", \"name-1\"})\n\"name-2\"\n</code></pre> Source code in <code>onshape_robotics_toolkit/utilities/helpers.py</code> <pre><code>def make_unique_name(name: str, existing_names: set[str]) -&gt; str:\n    \"\"\"\n    Make a name unique by appending a number to the name if it already exists in a set.\n\n    Args:\n        name: Name to make unique.\n        existing_names: Set of existing names.\n\n    Returns:\n        A unique name.\n\n    Examples:\n        &gt;&gt;&gt; make_unique_name(\"name\", {\"name\"})\n        \"name-1\"\n        &gt;&gt;&gt; make_unique_name(\"name\", {\"name\", \"name-1\"})\n        \"name-2\"\n    \"\"\"\n    if name not in existing_names:\n        return name\n\n    count = 1\n    while f\"{name}-{count}\" in existing_names:\n        count += 1\n\n    return f\"{name}-{count}\"\n</code></pre>"},{"location":"api/utilities/#onshape_robotics_toolkit.utilities.parse_onshape_expression","title":"<code>parse_onshape_expression(expr)</code>","text":"<p>Parse an Onshape expression string to a float value.</p> <p>Handles common units for angles and lengths. Returns None if the expression is None, empty, or cannot be parsed.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>str | None</code> <p>Onshape expression string (e.g., \"90 deg\", \"0.5 m\", \"100 mm\")</p> required <p>Returns:</p> Type Description <code>float | None</code> <p>Parsed float value with appropriate unit conversion, or None if invalid</p> Unit Conversions <ul> <li>Angles: \"deg\" or \"\u00b0\" \u2192 radians, \"rad\" \u2192 as-is</li> <li>Length: \"m\" \u2192 as-is, \"mm\" \u2192 /1000, \"cm\" \u2192 /100, \"in\" \u2192 *0.0254</li> <li>No unit: return float as-is</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; parse_onshape_expression(\"90 deg\")\n1.5707963267948966\n&gt;&gt;&gt; parse_onshape_expression(\"0.5 m\")\n0.5\n&gt;&gt;&gt; parse_onshape_expression(\"100 mm\")\n0.1\n&gt;&gt;&gt; parse_onshape_expression(\"3.14159\")\n3.14159\n&gt;&gt;&gt; parse_onshape_expression(None)\nNone\n&gt;&gt;&gt; parse_onshape_expression(\"\")\nNone\n</code></pre> Source code in <code>onshape_robotics_toolkit/utilities/helpers.py</code> <pre><code>def parse_onshape_expression(expr: str | None) -&gt; float | None:\n    \"\"\"\n    Parse an Onshape expression string to a float value.\n\n    Handles common units for angles and lengths. Returns None if the expression\n    is None, empty, or cannot be parsed.\n\n    Args:\n        expr: Onshape expression string (e.g., \"90 deg\", \"0.5 m\", \"100 mm\")\n\n    Returns:\n        Parsed float value with appropriate unit conversion, or None if invalid\n\n    Unit Conversions:\n        - Angles: \"deg\" or \"\u00b0\" \u2192 radians, \"rad\" \u2192 as-is\n        - Length: \"m\" \u2192 as-is, \"mm\" \u2192 /1000, \"cm\" \u2192 /100, \"in\" \u2192 *0.0254\n        - No unit: return float as-is\n\n    Examples:\n        &gt;&gt;&gt; parse_onshape_expression(\"90 deg\")\n        1.5707963267948966\n        &gt;&gt;&gt; parse_onshape_expression(\"0.5 m\")\n        0.5\n        &gt;&gt;&gt; parse_onshape_expression(\"100 mm\")\n        0.1\n        &gt;&gt;&gt; parse_onshape_expression(\"3.14159\")\n        3.14159\n        &gt;&gt;&gt; parse_onshape_expression(None)\n        None\n        &gt;&gt;&gt; parse_onshape_expression(\"\")\n        None\n    \"\"\"\n    if expr is None or expr.strip() == \"\":\n        return None\n\n    # Clean the expression\n    expr = expr.strip()\n\n    # Try to parse as plain float first (no units)\n    try:\n        return float(expr)\n    except ValueError:\n        pass\n\n    # Pattern to match number and optional unit\n    # Matches: number (int or float), optional whitespace, optional unit\n    pattern = r\"^([-+]?(?:\\d+\\.?\\d*|\\.\\d+)(?:[eE][-+]?\\d+)?)\\s*([a-zA-Z\u00b0]+)?$\"\n    match = re.match(pattern, expr)\n\n    if not match:\n        logger.warning(f\"Could not parse Onshape expression: '{expr}'\")\n        return None\n\n    value_str, unit = match.groups()\n\n    try:\n        value = float(value_str)\n    except ValueError:\n        logger.warning(f\"Could not convert value to float: '{value_str}' from expression '{expr}'\")\n        return None\n\n    # No unit provided\n    if unit is None or unit == \"\":\n        return value\n\n    # Convert based on unit (case-insensitive)\n    unit_lower = unit.lower()\n\n    # Angle conversions\n    if unit_lower in (\"deg\", \"degree\", \"degrees\", \"\u00b0\"):\n        return float(np.deg2rad(value))\n    elif unit_lower in (\"rad\", \"radian\", \"radians\") or unit_lower in (\"m\", \"meter\", \"meters\"):\n        return value\n    elif unit_lower in (\"mm\", \"millimeter\", \"millimeters\"):\n        return value / 1000.0\n    elif unit_lower in (\"cm\", \"centimeter\", \"centimeters\"):\n        return value / 100.0\n    elif unit_lower in (\"in\", \"inch\", \"inches\"):\n        return value * 0.0254\n    elif unit_lower in (\"ft\", \"foot\", \"feet\"):\n        return value * 0.3048\n\n    else:\n        logger.warning(f\"Unknown unit '{unit}' in expression '{expr}', returning raw value\")\n        return value\n</code></pre>"},{"location":"api/utilities/#onshape_robotics_toolkit.utilities.print_dict","title":"<code>print_dict(d, indent=0)</code>","text":"<p>Print a dictionary with indentation for nested dictionaries</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>Dictionary to print</p> required <code>indent</code> <code>int</code> <p>Number of tabs to indent</p> <code>0</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; print_dict({\"a\": 1, \"b\": {\"c\": 2}})\na\n    1\nb\n    c\n        2\n</code></pre> Source code in <code>onshape_robotics_toolkit/utilities/helpers.py</code> <pre><code>def print_dict(d: dict, indent: int = 0) -&gt; None:\n    \"\"\"\n    Print a dictionary with indentation for nested dictionaries\n\n    Args:\n        d (dict): Dictionary to print\n        indent (int): Number of tabs to indent\n\n    Returns:\n        None\n\n    Examples:\n        &gt;&gt;&gt; print_dict({\"a\": 1, \"b\": {\"c\": 2}})\n        a\n            1\n        b\n            c\n                2\n    \"\"\"\n\n    for key, value in d.items():\n        print()\n        print(\"\\t\" * indent + str(key))\n        if isinstance(value, dict):\n            print_dict(value, indent + 1)\n        else:\n            print(\"\\t\" * (indent + 1) + str(value))\n</code></pre>"},{"location":"api/utilities/#onshape_robotics_toolkit.utilities.print_tf","title":"<code>print_tf(tf)</code>","text":"<p>Print a 4x4 transformation matrix in a readable format</p> <p>Parameters:</p> Name Type Description Default <code>tf</code> <code>ndarray</code> <p>4x4 transformation matrix</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; tf = np.array([[1, 0, 0, 1],\n...                [0, 1, 0, 2],\n...                [0, 0, 1, 3],\n...                [0, 0, 0, 1]])\n&gt;&gt;&gt; print_tf(tf)\n[[1.         0.         0.         1.        ]\n [0.         1.         0.         2.        ]\n [0.         0.         1.         3.        ]\n [0.         0.         0.         1.        ]]\n</code></pre> Source code in <code>onshape_robotics_toolkit/utilities/helpers.py</code> <pre><code>def print_tf(tf: np.ndarray) -&gt; None:\n    \"\"\"\n    Print a 4x4 transformation matrix in a readable format\n\n    Args:\n        tf (np.ndarray): 4x4 transformation matrix\n\n    Returns:\n        None\n\n    Examples:\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; tf = np.array([[1, 0, 0, 1],\n        ...                [0, 1, 0, 2],\n        ...                [0, 0, 1, 3],\n        ...                [0, 0, 0, 1]])\n        &gt;&gt;&gt; print_tf(tf)\n        [[1.         0.         0.         1.        ]\n         [0.         1.         0.         2.        ]\n         [0.         0.         1.         3.        ]\n         [0.         0.         0.         1.        ]]\n    \"\"\"\n    if tf.shape != (4, 4):\n        raise ValueError(\"Input must be a 4x4 matrix\")\n    with np.printoptions(precision=8, suppress=True):\n        print(tf)\n</code></pre>"},{"location":"api/utilities/#onshape_robotics_toolkit.utilities.save_model_as_json","title":"<code>save_model_as_json(model, file_path, indent=4, clean_numerics=True, threshold=1e-10, decimals=8)</code>","text":"<p>Save a Pydantic model as a JSON file with optional numeric cleaning.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>BaseModel</code> <p>Pydantic model to save</p> required <code>file_path</code> <code>str</code> <p>File path to save JSON file</p> required <code>indent</code> <code>int</code> <p>JSON indentation level</p> <code>4</code> <code>clean_numerics</code> <code>bool</code> <p>If True, clean numeric values (default True)</p> <code>True</code> <code>threshold</code> <code>float</code> <p>Values below this are set to 0 (default 1e-10)</p> <code>1e-10</code> <code>decimals</code> <code>int</code> <p>Number of decimal places to round to (default 8)</p> <code>8</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class TestModel(BaseModel):\n...     a: int\n...     b: str\n...\n&gt;&gt;&gt; save_model_as_json(TestModel(a=1, b=\"hello\"), \"test.json\")\n&gt;&gt;&gt; save_model_as_json(model, \"test.json\", decimals=5, threshold=1e-8)\n</code></pre> Source code in <code>onshape_robotics_toolkit/utilities/helpers.py</code> <pre><code>def save_model_as_json(\n    model: BaseModel,\n    file_path: str,\n    indent: int = 4,\n    clean_numerics: bool = True,\n    threshold: float = 1e-10,\n    decimals: int = 8,\n) -&gt; None:\n    \"\"\"\n    Save a Pydantic model as a JSON file with optional numeric cleaning.\n\n    Args:\n        model (BaseModel): Pydantic model to save\n        file_path (str): File path to save JSON file\n        indent (int): JSON indentation level\n        clean_numerics (bool): If True, clean numeric values (default True)\n        threshold (float): Values below this are set to 0 (default 1e-10)\n        decimals (int): Number of decimal places to round to (default 8)\n\n    Returns:\n        None\n\n    Examples:\n        &gt;&gt;&gt; class TestModel(BaseModel):\n        ...     a: int\n        ...     b: str\n        ...\n        &gt;&gt;&gt; save_model_as_json(TestModel(a=1, b=\"hello\"), \"test.json\")\n        &gt;&gt;&gt; save_model_as_json(model, \"test.json\", decimals=5, threshold=1e-8)\n    \"\"\"\n    with open(file_path, \"w\") as file:\n        encoder = CustomJSONEncoder(\n            indent=indent, clean_numerics=clean_numerics, threshold=threshold, decimals=decimals\n        )\n        file.write(encoder.encode(model.model_dump()))\n</code></pre>"},{"location":"api/utilities/#onshape_robotics_toolkit.utilities.setup_console_logging","title":"<code>setup_console_logging(level='INFO', format_string=None, colorize=True)</code>","text":"<p>Add a console (stderr) logging handler.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>str</code> <p>Minimum log level to display (DEBUG, INFO, WARNING, ERROR, CRITICAL)</p> <code>'INFO'</code> <code>format_string</code> <code>str | None</code> <p>Custom format string. If None, uses DEFAULT_CONSOLE_FORMAT</p> <code>None</code> <code>colorize</code> <code>bool</code> <p>Whether to colorize the output</p> <code>True</code> <p>Returns:</p> Type Description <code>int</code> <p>Handler ID that can be used with logger.remove() if needed</p> Example <p>from onshape_robotics_toolkit.utilities import setup_console_logging setup_console_logging(level=\"DEBUG\")</p> Source code in <code>onshape_robotics_toolkit/utilities/helpers.py</code> <pre><code>def setup_console_logging(\n    level: str = \"INFO\",\n    format_string: str | None = None,\n    colorize: bool = True,\n) -&gt; int:\n    \"\"\"Add a console (stderr) logging handler.\n\n    Args:\n        level: Minimum log level to display (DEBUG, INFO, WARNING, ERROR, CRITICAL)\n        format_string: Custom format string. If None, uses DEFAULT_CONSOLE_FORMAT\n        colorize: Whether to colorize the output\n\n    Returns:\n        Handler ID that can be used with logger.remove() if needed\n\n    Example:\n        &gt;&gt;&gt; from onshape_robotics_toolkit.utilities import setup_console_logging\n        &gt;&gt;&gt; setup_console_logging(level=\"DEBUG\")\n    \"\"\"\n    import sys\n\n    fmt = format_string if format_string is not None else DEFAULT_CONSOLE_FORMAT\n\n    handler_id = logger.add(\n        sys.stderr,\n        format=fmt,\n        level=level,\n        colorize=colorize,\n    )\n    return handler_id\n</code></pre>"},{"location":"api/utilities/#onshape_robotics_toolkit.utilities.setup_default_logging","title":"<code>setup_default_logging(console_level='INFO', file_level='DEBUG', file_path='onshape_toolkit.log', clear_existing_handlers=True, delay_file_creation=False)</code>","text":"<p>Configure logging with sensible defaults: console at INFO + file at DEBUG.</p> <p>This is the recommended way to set up logging for most users. It provides: - Colored console output at INFO level or higher - Detailed file logging at DEBUG level or higher - Automatic log rotation (10 MB) and retention (7 days) - Compressed archives of rotated logs</p> <p>Parameters:</p> Name Type Description Default <code>console_level</code> <code>str</code> <p>Minimum level for console output (default: \"INFO\")</p> <code>'INFO'</code> <code>file_level</code> <code>str</code> <p>Minimum level for file output (default: \"DEBUG\")</p> <code>'DEBUG'</code> <code>file_path</code> <code>str</code> <p>Path to the log file (default: \"onshape_toolkit.log\")</p> <code>'onshape_toolkit.log'</code> <code>clear_existing_handlers</code> <code>bool</code> <p>Whether to remove existing handlers first (default: True)</p> <code>True</code> <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>Tuple of (console_handler_id, file_handler_id)</p> Example <p>from onshape_robotics_toolkit.utilities import setup_default_logging setup_default_logging()  # Use all defaults</p> Source code in <code>onshape_robotics_toolkit/utilities/helpers.py</code> <pre><code>def setup_default_logging(\n    console_level: str = \"INFO\",\n    file_level: str = \"DEBUG\",\n    file_path: str = \"onshape_toolkit.log\",\n    clear_existing_handlers: bool = True,\n    delay_file_creation: bool = False,\n) -&gt; tuple[int, int]:\n    \"\"\"Configure logging with sensible defaults: console at INFO + file at DEBUG.\n\n    This is the recommended way to set up logging for most users. It provides:\n    - Colored console output at INFO level or higher\n    - Detailed file logging at DEBUG level or higher\n    - Automatic log rotation (10 MB) and retention (7 days)\n    - Compressed archives of rotated logs\n\n    Args:\n        console_level: Minimum level for console output (default: \"INFO\")\n        file_level: Minimum level for file output (default: \"DEBUG\")\n        file_path: Path to the log file (default: \"onshape_toolkit.log\")\n        clear_existing_handlers: Whether to remove existing handlers first (default: True)\n\n    Returns:\n        Tuple of (console_handler_id, file_handler_id)\n\n    Example:\n        &gt;&gt;&gt; from onshape_robotics_toolkit.utilities import setup_default_logging\n        &gt;&gt;&gt; setup_default_logging()  # Use all defaults\n        &gt;&gt;&gt; # Or customize:\n        &gt;&gt;&gt; setup_default_logging(console_level=\"DEBUG\", file_path=\"my_robot.log\")\n    \"\"\"\n    if clear_existing_handlers:\n        logger.remove()\n\n    console_id = setup_console_logging(level=console_level, colorize=True)\n    file_id = setup_file_logging(file_path=file_path, level=file_level, delay=delay_file_creation)\n\n    _record_logging_config(\n        mode=\"default\",\n        console_level=console_level,\n        file_level=file_level,\n        file_path=file_path,\n        clear_existing_handlers=clear_existing_handlers,\n        delay_file_creation=delay_file_creation,\n    )\n\n    return console_id, file_id\n</code></pre>"},{"location":"api/utilities/#onshape_robotics_toolkit.utilities.setup_default_logging--or-customize","title":"Or customize:","text":"<p>setup_default_logging(console_level=\"DEBUG\", file_path=\"my_robot.log\")</p>"},{"location":"api/utilities/#onshape_robotics_toolkit.utilities.setup_file_logging","title":"<code>setup_file_logging(file_path='onshape_toolkit.log', level='DEBUG', format_string=None, rotation='10 MB', retention='7 days', compression='zip', enqueue=True, delay=False)</code>","text":"<p>Add a file logging handler with rotation and compression.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to the log file</p> <code>'onshape_toolkit.log'</code> <code>level</code> <code>str</code> <p>Minimum log level to write (DEBUG, INFO, WARNING, ERROR, CRITICAL)</p> <code>'DEBUG'</code> <code>format_string</code> <code>str | None</code> <p>Custom format string. If None, uses DEFAULT_FILE_FORMAT</p> <code>None</code> <code>rotation</code> <code>str</code> <p>When to rotate the log file (e.g., \"10 MB\", \"1 day\", \"12:00\")</p> <code>'10 MB'</code> <code>retention</code> <code>str</code> <p>How long to keep old log files (e.g., \"7 days\", \"10 files\")</p> <code>'7 days'</code> <code>compression</code> <code>str</code> <p>Compression format for rotated files (\"zip\", \"gz\", \"bz2\", or None)</p> <code>'zip'</code> <code>enqueue</code> <code>bool</code> <p>Whether to use thread-safe logging (recommended)</p> <code>True</code> <p>Returns:</p> Type Description <code>int</code> <p>Handler ID that can be used with logger.remove() if needed</p> Example <p>from onshape_robotics_toolkit.utilities import setup_file_logging setup_file_logging(\"my_robot.log\", level=\"DEBUG\", rotation=\"50 MB\")</p> Source code in <code>onshape_robotics_toolkit/utilities/helpers.py</code> <pre><code>def setup_file_logging(\n    file_path: str = \"onshape_toolkit.log\",\n    level: str = \"DEBUG\",\n    format_string: str | None = None,\n    rotation: str = \"10 MB\",\n    retention: str = \"7 days\",\n    compression: str = \"zip\",\n    enqueue: bool = True,\n    delay: bool = False,\n) -&gt; int:\n    \"\"\"Add a file logging handler with rotation and compression.\n\n    Args:\n        file_path: Path to the log file\n        level: Minimum log level to write (DEBUG, INFO, WARNING, ERROR, CRITICAL)\n        format_string: Custom format string. If None, uses DEFAULT_FILE_FORMAT\n        rotation: When to rotate the log file (e.g., \"10 MB\", \"1 day\", \"12:00\")\n        retention: How long to keep old log files (e.g., \"7 days\", \"10 files\")\n        compression: Compression format for rotated files (\"zip\", \"gz\", \"bz2\", or None)\n        enqueue: Whether to use thread-safe logging (recommended)\n\n    Returns:\n        Handler ID that can be used with logger.remove() if needed\n\n    Example:\n        &gt;&gt;&gt; from onshape_robotics_toolkit.utilities import setup_file_logging\n        &gt;&gt;&gt; setup_file_logging(\"my_robot.log\", level=\"DEBUG\", rotation=\"50 MB\")\n    \"\"\"\n    fmt = format_string if format_string is not None else DEFAULT_FILE_FORMAT\n\n    handler_id = logger.add(\n        file_path,\n        format=fmt,\n        level=level,\n        rotation=rotation,\n        retention=retention,\n        compression=compression,\n        enqueue=enqueue,\n        delay=delay,\n    )\n    return handler_id\n</code></pre>"},{"location":"api/utilities/#onshape_robotics_toolkit.utilities.setup_minimal_logging","title":"<code>setup_minimal_logging(level='INFO')</code>","text":"<p>Configure minimal console-only logging without file output.</p> <p>Useful for quick scripts or when you don't want log files.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>str</code> <p>Minimum log level to display (default: \"INFO\")</p> <code>'INFO'</code> <p>Returns:</p> Type Description <code>int</code> <p>Handler ID that can be used with logger.remove() if needed</p> Example <p>from onshape_robotics_toolkit.utilities import setup_minimal_logging setup_minimal_logging(level=\"WARNING\")</p> Source code in <code>onshape_robotics_toolkit/utilities/helpers.py</code> <pre><code>def setup_minimal_logging(level: str = \"INFO\") -&gt; int:\n    \"\"\"Configure minimal console-only logging without file output.\n\n    Useful for quick scripts or when you don't want log files.\n\n    Args:\n        level: Minimum log level to display (default: \"INFO\")\n\n    Returns:\n        Handler ID that can be used with logger.remove() if needed\n\n    Example:\n        &gt;&gt;&gt; from onshape_robotics_toolkit.utilities import setup_minimal_logging\n        &gt;&gt;&gt; setup_minimal_logging(level=\"WARNING\")\n    \"\"\"\n    logger.remove()\n    handler_id = setup_console_logging(level=level, format_string=MINIMAL_CONSOLE_FORMAT)\n    _record_logging_config(mode=\"minimal\", console_level=level)\n    return handler_id\n</code></pre>"},{"location":"api/utilities/#onshape_robotics_toolkit.utilities.setup_quiet_logging","title":"<code>setup_quiet_logging(file_path='onshape_toolkit.log', level='DEBUG')</code>","text":"<p>Configure file-only logging with no console output.</p> <p>Useful for background tasks or automated scripts where console output would be distracting.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to the log file (default: \"onshape_toolkit.log\")</p> <code>'onshape_toolkit.log'</code> <code>level</code> <code>str</code> <p>Minimum log level to write (default: \"DEBUG\")</p> <code>'DEBUG'</code> <p>Returns:</p> Type Description <code>int</code> <p>Handler ID that can be used with logger.remove() if needed</p> Example <p>from onshape_robotics_toolkit.utilities import setup_quiet_logging setup_quiet_logging(\"background_task.log\")</p> Source code in <code>onshape_robotics_toolkit/utilities/helpers.py</code> <pre><code>def setup_quiet_logging(file_path: str = \"onshape_toolkit.log\", level: str = \"DEBUG\") -&gt; int:\n    \"\"\"Configure file-only logging with no console output.\n\n    Useful for background tasks or automated scripts where console output\n    would be distracting.\n\n    Args:\n        file_path: Path to the log file (default: \"onshape_toolkit.log\")\n        level: Minimum log level to write (default: \"DEBUG\")\n\n    Returns:\n        Handler ID that can be used with logger.remove() if needed\n\n    Example:\n        &gt;&gt;&gt; from onshape_robotics_toolkit.utilities import setup_quiet_logging\n        &gt;&gt;&gt; setup_quiet_logging(\"background_task.log\")\n    \"\"\"\n    logger.remove()\n    handler_id = setup_file_logging(file_path=file_path, level=level)\n    _record_logging_config(\n        mode=\"quiet\",\n        file_path=file_path,\n        file_level=level,\n        clear_existing_handlers=True,\n    )\n    return handler_id\n</code></pre>"},{"location":"api/utilities/#onshape_robotics_toolkit.utilities.xml_escape","title":"<code>xml_escape(unescaped)</code>","text":"<p>Escape XML characters in a string</p> <p>Parameters:</p> Name Type Description Default <code>unescaped</code> <code>str</code> <p>Unescaped string</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Escaped string</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; xml_escape(\"hello 'world' \"world\"\")\n\"hello &amp;apos;world&amp;apos; &amp;quot;world&amp;quot;\"\n</code></pre> <pre><code>&gt;&gt;&gt; xml_escape(\"hello &lt;world&gt;\")\n\"hello &amp;lt;world&amp;gt;\"\n</code></pre> Source code in <code>onshape_robotics_toolkit/utilities/helpers.py</code> <pre><code>def xml_escape(unescaped: str) -&gt; str:\n    \"\"\"\n    Escape XML characters in a string\n\n    Args:\n        unescaped (str): Unescaped string\n\n    Returns:\n        str: Escaped string\n\n    Examples:\n        &gt;&gt;&gt; xml_escape(\"hello 'world' \\\"world\\\"\")\n        \"hello &amp;apos;world&amp;apos; &amp;quot;world&amp;quot;\"\n\n        &gt;&gt;&gt; xml_escape(\"hello &lt;world&gt;\")\n        \"hello &amp;lt;world&amp;gt;\"\n    \"\"\"\n\n    return escape(unescaped, entities={\"'\": \"&amp;apos;\", '\"': \"&amp;quot;\"})\n</code></pre>"},{"location":"api/variable/","title":"Variable","text":"<p>This module defines data models for variables used in Onshape documents retrieved from Onshape REST API responses.</p> <p>The data models are implemented as Pydantic BaseModel classes, which are used to</p> <pre><code>1. Parse JSON responses from the API into Python objects.\n2. Validate the structure and types of the JSON responses.\n3. Provide type hints for better code clarity and autocompletion.\n</code></pre> <p>These models ensure that the data received from the API adheres to the expected format and types, facilitating easier and safer manipulation of the data within the application.</p> Models <ul> <li>Variable: Represents a variable used in Onshape's Variable Studio.</li> </ul> Enum <ul> <li>VARIABLE_TYPE: Enumerates the possible variable types in Onshape (LENGTH, ANGLE, NUMBER, ANY).</li> </ul>"},{"location":"api/variable/#onshape_robotics_toolkit.models.variable.VARIABLE_TYPE","title":"<code>VARIABLE_TYPE</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enumerates the possible variable types in Onshape</p> <p>Attributes:</p> Name Type Description <code>LENGTH</code> <code>str</code> <p>Length variable type</p> <code>ANGLE</code> <code>str</code> <p>Angle variable type</p> <code>NUMBER</code> <code>str</code> <p>Number variable type</p> <code>ANY</code> <code>str</code> <p>Any variable type</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; VARIABLE_TYPE.LENGTH\n'LENGTH'\n&gt;&gt;&gt; VARIABLE_TYPE.ANGLE\n'ANGLE'\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/variable.py</code> <pre><code>class VARIABLE_TYPE(str, Enum):\n    \"\"\"\n    Enumerates the possible variable types in Onshape\n\n    Attributes:\n        LENGTH (str): Length variable type\n        ANGLE (str): Angle variable type\n        NUMBER (str): Number variable type\n        ANY (str): Any variable type\n\n    Examples:\n        &gt;&gt;&gt; VARIABLE_TYPE.LENGTH\n        'LENGTH'\n        &gt;&gt;&gt; VARIABLE_TYPE.ANGLE\n        'ANGLE'\n    \"\"\"\n\n    LENGTH = \"LENGTH\"\n    ANGLE = \"ANGLE\"\n    NUMBER = \"NUMBER\"\n    ANY = \"ANY\"\n</code></pre>"},{"location":"api/variable/#onshape_robotics_toolkit.models.variable.Variable","title":"<code>Variable</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a variable used in Onshape's Variable Studio.</p> JSON <pre><code>    {\n        \"type\": \"ANGLE\",\n        \"name\": \"forkAngle\",\n        \"value\": null,\n        \"description\": \"Fork angle for front wheel assembly in deg\",\n        \"expression\": \"15 deg\"\n    }\n</code></pre> <p>Attributes:</p> Name Type Description <code>type</code> <code>str</code> <p>The type of the variable (LENGTH, ANGLE, NUMBER, ANY).</p> <code>name</code> <code>str</code> <p>The name of the variable.</p> <code>value</code> <code>str</code> <p>The value of the variable.</p> <code>description</code> <code>str</code> <p>The description of the variable.</p> <code>expression</code> <code>str</code> <p>The expression of the variable.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; variable = Variable(\n...     type=\"ANGLE\",\n...     name=\"forkAngle\",\n...     value=None,\n...     description=\"Fork angle for front wheel assembly in deg\",\n...     expression=\"15 deg\"\n... )\n&gt;&gt;&gt; variable\nVariable(\n    type='ANGLE',\n    name='forkAngle',\n    value=None,\n    description='Fork angle for front wheel assembly in deg',\n    expression='15 deg'\n)\n</code></pre> Source code in <code>onshape_robotics_toolkit/models/variable.py</code> <pre><code>class Variable(BaseModel):\n    \"\"\"\n    Represents a variable used in Onshape's Variable Studio.\n\n    JSON:\n        ```json\n            {\n                \"type\": \"ANGLE\",\n                \"name\": \"forkAngle\",\n                \"value\": null,\n                \"description\": \"Fork angle for front wheel assembly in deg\",\n                \"expression\": \"15 deg\"\n            }\n        ```\n\n    Attributes:\n        type (str): The type of the variable (LENGTH, ANGLE, NUMBER, ANY).\n        name (str): The name of the variable.\n        value (str, optional): The value of the variable.\n        description (str, optional): The description of the variable.\n        expression (str, optional): The expression of the variable.\n\n    Examples:\n        &gt;&gt;&gt; variable = Variable(\n        ...     type=\"ANGLE\",\n        ...     name=\"forkAngle\",\n        ...     value=None,\n        ...     description=\"Fork angle for front wheel assembly in deg\",\n        ...     expression=\"15 deg\"\n        ... )\n        &gt;&gt;&gt; variable\n        Variable(\n            type='ANGLE',\n            name='forkAngle',\n            value=None,\n            description='Fork angle for front wheel assembly in deg',\n            expression='15 deg'\n        )\n    \"\"\"\n\n    type: str = Field(..., description=\"The type of the variable (LENGTH, ANGLE, NUMBER, ANY)\")\n    name: str = Field(..., description=\"The name of the variable\")\n    value: Union[str, None] = Field(None, description=\"The value of the variable\")\n    description: Union[str, None] = Field(None, description=\"The description of the variable\")\n    expression: Union[str, None] = Field(None, description=\"The expression of the variable\")\n\n    @field_validator(\"name\")\n    def validate_name(cls, value: str) -&gt; str:\n        \"\"\"\n        Validate the variable name to ensure it is not empty.\n\n        Args:\n            value (str): The variable name to validate.\n\n        Returns:\n            str: The validated variable name.\n\n        Raises:\n            ValueError: If the variable name is empty.\n        \"\"\"\n        if not value:\n            raise ValueError(\"Variable name cannot be empty\")\n\n        return value\n\n    @field_validator(\"type\")\n    def validate_type(cls, value: str) -&gt; str:\n        \"\"\"\n        Validate the variable type to ensure it is one of the valid types.\n\n        Args:\n            value (str): The variable type to validate.\n\n        Returns:\n            str: The validated variable type.\n\n        Raises:\n            ValueError: If the variable type is not one of the valid types.\n        \"\"\"\n        if value not in VARIABLE_TYPE.__members__.values():\n            raise ValueError(f\"Invalid variable type: {value}\")\n\n        return value\n</code></pre>"},{"location":"api/variable/#onshape_robotics_toolkit.models.variable.Variable.validate_name","title":"<code>validate_name(value)</code>","text":"<p>Validate the variable name to ensure it is not empty.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The variable name to validate.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The validated variable name.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the variable name is empty.</p> Source code in <code>onshape_robotics_toolkit/models/variable.py</code> <pre><code>@field_validator(\"name\")\ndef validate_name(cls, value: str) -&gt; str:\n    \"\"\"\n    Validate the variable name to ensure it is not empty.\n\n    Args:\n        value (str): The variable name to validate.\n\n    Returns:\n        str: The validated variable name.\n\n    Raises:\n        ValueError: If the variable name is empty.\n    \"\"\"\n    if not value:\n        raise ValueError(\"Variable name cannot be empty\")\n\n    return value\n</code></pre>"},{"location":"api/variable/#onshape_robotics_toolkit.models.variable.Variable.validate_type","title":"<code>validate_type(value)</code>","text":"<p>Validate the variable type to ensure it is one of the valid types.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The variable type to validate.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The validated variable type.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the variable type is not one of the valid types.</p> Source code in <code>onshape_robotics_toolkit/models/variable.py</code> <pre><code>@field_validator(\"type\")\ndef validate_type(cls, value: str) -&gt; str:\n    \"\"\"\n    Validate the variable type to ensure it is one of the valid types.\n\n    Args:\n        value (str): The variable type to validate.\n\n    Returns:\n        str: The validated variable type.\n\n    Raises:\n        ValueError: If the variable type is not one of the valid types.\n    \"\"\"\n    if value not in VARIABLE_TYPE.__members__.values():\n        raise ValueError(f\"Invalid variable type: {value}\")\n\n    return value\n</code></pre>"},{"location":"tutorials/edit/","title":"Editing a CAD assembly","text":"<p>In this tutorial, we'll explore how to edit an Onshape CAD assembly by modifying its variables in the Variable Studio and exporting the resulting assembly to a URDF file using the <code>onshape-robotics-toolkit</code> Python library.</p> <p></p>"},{"location":"tutorials/edit/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, make sure you have:</p> <ul> <li>Installed the <code>onshape-robotics-toolkit</code> library:   <pre><code>pip install onshape-robotics-toolkit\n</code></pre></li> <li>API Keys: Set up your Onshape API keys in a <code>.env</code> file as outlined in the Getting Started guide.</li> <li>Access to the Onshape Document: Use a CAD document with a Variable Studio. For this tutorial, we'll use the following example:   Example CAD Document.</li> </ul>"},{"location":"tutorials/edit/#step-by-step-workflow","title":"Step-by-Step Workflow","text":""},{"location":"tutorials/edit/#step-1-initialize-the-onshape-client","title":"Step 1: Initialize the Onshape Client","text":"<p>Set up the Onshape API client for authentication and interaction:</p> <pre><code>from onshape_robotics_toolkit.connect import Client\nfrom onshape_robotics_toolkit.utilities import setup_default_logging\n\n# Configure logging: console at INFO + file at DEBUG\nsetup_default_logging(file_path=\"edit.log\", console_level=\"INFO\")\n\n# Initialize the client\nclient = Client(env=\".env\")\n</code></pre> <p>The toolkit provides convenient logging helpers built on loguru. The <code>setup_default_logging()</code> function configures both console and file logging with sensible defaults. For other logging configurations, see <code>setup_minimal_logging()</code>, <code>setup_quiet_logging()</code>, or use the lower-level <code>setup_console_logging()</code> and <code>setup_file_logging()</code> functions.</p>"},{"location":"tutorials/edit/#step-2-access-the-cad-document-and-variables","title":"Step 2: Access the CAD Document and Variables","text":"<p>Use the CAD document URL to create a <code>Document</code> object and fetch its variables:</p> <pre><code>from onshape_robotics_toolkit.models.document import Document\n\ndoc = Document.from_url(\n    url=\"https://cad.onshape.com/documents/a1c1addf75444f54b504f25c/w/0d17b8ebb2a4c76be9fff3c7/e/a86aaf34d2f4353288df8812\"\n)\n\n# Retrieve the Variable Studio element\nelements = client.get_elements(doc.did, doc.wtype, doc.wid)\nvariables = client.get_variables(doc.did, doc.wid, elements[\"variables\"].id)\n</code></pre>"},{"location":"tutorials/edit/#step-3-modify-variables-in-the-variable-studio","title":"Step 3: Modify Variables in the Variable Studio","text":"<p>Edit the variables to adjust the CAD assembly dimensions. For example, modify the wheel diameter, wheel thickness, and fork angle:</p> <pre><code>variables[\"wheelDiameter\"].expression = \"180 mm\"\nvariables[\"wheelThickness\"].expression = \"71 mm\"\nvariables[\"forkAngle\"].expression = \"20 deg\"\n\n# Save the updated variables back to the Variable Studio\nclient.set_variables(doc.did, doc.wid, elements[\"variables\"].id, variables)\n</code></pre>"},{"location":"tutorials/edit/#step-4-retrieve-and-parse-the-assembly","title":"Step 4: Retrieve and Parse the Assembly","text":"<p>Fetch the assembly data and parse its components:</p> <pre><code>from onshape_robotics_toolkit.parse import (\n    get_instances,\n    get_mates_and_relations,\n    get_occurrences,\n    get_parts,\n    get_subassemblies,\n)\n\n# Retrieve the assembly\nassembly = client.get_assembly(doc.did, doc.wtype, doc.wid, elements[\"assembly\"].id)\n\n# Extract components\ninstances, occurrences, id_to_name_map = get_instances(assembly, max_depth=1)\n\nsubassemblies, rigid_subassemblies = get_subassemblies(assembly, client, instances)\nparts = get_parts(assembly, rigid_subassemblies, client, instances)\n\nmates, relations = get_mates_and_relations(assembly, occurrences, subassemblies, rigid_subassemblies, id_to_name_map, parts)\n</code></pre>"},{"location":"tutorials/edit/#step-5-visualize-the-assembly-graph","title":"Step 5: Visualize the Assembly Graph","text":"<p>Generate a graph visualization of the assembly structure:</p> <pre><code>from onshape_robotics_toolkit.graph import create_graph\nfrom onshape_robotics_toolkit.robot import get_robot\n\n# Create and visualize the assembly graph\ngraph, root_node = create_graph(occurrences=occurrences, instances=instances, parts=parts, mates=mates)\nrobot = get_robot(assembly, graph, root_node, parts, mates, relations, client, \"test\")\nrobot.show_tree()\nrobot.show_graph(\"bike.png\")\n</code></pre> <p></p> <p>This will save an image of the assembly graph (<code>bike.png</code>) in your current working directory.</p>"},{"location":"tutorials/edit/#step-6-export-the-assembly-to-a-urdf-file","title":"Step 6: Export the Assembly to a URDF File","text":"<p>Convert the robot class into a URDF file for robotics applications:</p> <pre><code>robot.save()\n</code></pre> <p></p>"},{"location":"tutorials/edit/#result","title":"Result","text":"<p>After completing the steps, you will have:</p> <ol> <li>A visualization of the updated assembly graph saved as <code>bike.png</code>.</li> <li>A URDF file (<code>bike.urdf</code>) representing the edited assembly.</li> </ol> <p>The URDF file can now be used in robotics simulators like Gazebo or integrated into ROS-based projects.</p>"},{"location":"tutorials/export/","title":"Exporting an Onshape Assembly to URDF","text":"<p>This tutorial demonstrates a streamlined workflow for converting an Onshape assembly to a URDF file using the <code>onshape-robotics-toolkit</code> library. Follow these steps to easily generate a URDF file and visualize your assembly's structure.</p> <p></p>"},{"location":"tutorials/export/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure the following:</p> <ul> <li>Install the library: You have the <code>onshape-robotics-toolkit</code> library installed.   <pre><code>pip install onshape-robotics-toolkit\n</code></pre></li> <li>API Keys: Set up your Onshape API keys in a <code>.env</code> file. Refer to the Getting Started guide if needed.</li> <li>Document URL: Have the URL of the Onshape assembly you want to export. For this example, we'll use a quadruped robot assembly.</li> </ul>"},{"location":"tutorials/export/#workflow-onshape-assembly-to-json-and-graph-visualization","title":"Workflow: Onshape Assembly to JSON and Graph Visualization","text":""},{"location":"tutorials/export/#step-1-set-up-logging-and-initialize-the-client","title":"Step 1: Set Up Logging and Initialize the Client","text":"<p>Start by configuring the logger and initializing the Onshape API client:</p> <pre><code>from onshape_robotics_toolkit.connect import Client\nfrom onshape_robotics_toolkit.utilities import setup_default_logging\n\n# Configure logging: console at INFO + file at DEBUG\nsetup_default_logging(file_path=\"quadruped.log\", console_level=\"INFO\")\n\nclient = Client(env=\".env\")\n</code></pre> <p>The toolkit uses loguru for logging. By default, loguru logs to stderr at DEBUG level. The <code>setup_default_logging()</code> helper provides a convenient way to configure both console and file logging with automatic rotation and retention. You can also use:</p> <ul> <li><code>setup_minimal_logging()</code> for console-only output</li> <li><code>setup_quiet_logging()</code> for file-only output</li> <li><code>setup_console_logging()</code> and <code>setup_file_logging()</code> for fine-grained control</li> </ul>"},{"location":"tutorials/export/#step-2-load-the-onshape-assembly","title":"Step 2: Load the Onshape Assembly","text":"<p>Use the <code>Robot</code> class to load the assembly directly from its Onshape document URL:</p> <pre><code>from onshape_robotics_toolkit.robot import Robot\n\nrobot = Robot.from_url(\n    name=\"quadruped\",\n    url=\"https://cad.onshape.com/documents/cf6b852d2c88d661ac2e17e8/w/c842455c29cc878dc48bdc68/e/b5e293d409dd0b88596181ef\",\n    client=client,\n    max_depth=0,\n    use_user_defined_root=False,\n)\n</code></pre> <p>This will create a <code>Robot</code> object named \"quadruped\" from the specified Onshape document URL. The <code>max_depth</code> parameter controls the level of subassemblies to include, and <code>use_user_defined_root</code> specifies whether to use a user-defined root for the assembly.</p>"},{"location":"tutorials/export/#step-3-save-the-assembly-as-json","title":"Step 3: Save the Assembly as JSON","text":"<p>Export the assembly data to a JSON file for easy analysis or integration with other tools:</p> <pre><code>from onshape_robotics_toolkit.utilities.helpers import save_model_as_json\n\nsave_model_as_json(robot.assembly, \"quadruped.json\")\n</code></pre> <p>This will save the assembly details into a file named <code>quadruped.json</code> in the current working directory.</p>"},{"location":"tutorials/export/#step-4-visualize-the-assembly-graph-optional","title":"Step 4: Visualize the Assembly Graph (Optional)","text":"<p>Generate and save a graphical representation of the assembly's structure:</p> <pre><code>robot.show_graph(file_name=\"quadruped.png\")\n</code></pre> <p>This will create a PNG file named <code>quadruped.png</code> showing the hierarchical structure of the assembly.</p>"},{"location":"tutorials/export/#step-5-save-the-robot-object-as-a-urdf-file","title":"Step 5: Save the Robot Object as a URDF File","text":"<p>If you plan to use the robot in a simulation environment, you can save the robot object as a URDF file:</p> <pre><code>robot.save()\n</code></pre> <p>This saves the robot object to disk as a URDF file named <code>quadruped.robot</code>.</p>"},{"location":"tutorials/export/#result","title":"Result","text":"<p>After running the script, you'll find the following files in your working directory:</p> <ol> <li>Assembly JSON File (<code>quadruped.json</code>): Contains the complete assembly details.</li> <li>Assembly Graph (<code>quadruped.png</code>): A visual representation of the assembly\u2019s structure.</li> <li>Robot URDF File (<code>quadruped.urdf</code>): A URDF file for simulation.</li> </ol> <p>These files can be used for further analysis, simulation, or integration into other workflows.</p>"}]}